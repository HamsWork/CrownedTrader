# Generated by GPT-5.2 on 2026-01-27

from django.db import migrations


def _infer_tp_mode(plan: dict) -> str:
    """
    Infer tp_mode from existing saved plan JSON.
    Rules:
      - If any level has mode in stock-ish values OR has a non-empty stock_price, => "stock"
      - Else => "percent"
    """
    if not isinstance(plan, dict):
        return "percent"

    tp_mode_raw = str(plan.get("tp_mode") or "").strip().lower()
    if tp_mode_raw in ("stock", "stock_price", "underlying", "share_price"):
        return "stock"
    if tp_mode_raw in ("percent", "pct", "%"):
        return "percent"

    levels = plan.get("tp_levels") or []
    if isinstance(levels, list):
        for it in levels:
            if not isinstance(it, dict):
                continue
            m = str(it.get("mode") or "").strip().lower()
            sp = str(it.get("stock_price") or it.get("stockPrice") or "").strip()
            if m in ("stock", "stock_price", "underlying", "share_price") or bool(sp):
                return "stock"
    return "percent"


def backfill_tp_mode(apps, schema_editor):
    UserTradePlanPreset = apps.get_model("signals", "UserTradePlanPreset")
    qs = UserTradePlanPreset.objects.all()
    for obj in qs.iterator():
        plan = obj.plan if isinstance(obj.plan, dict) else {}
        if not isinstance(plan, dict):
            plan = {}
        if str(plan.get("tp_mode") or "").strip():
            continue
        inferred = _infer_tp_mode(plan)
        plan["tp_mode"] = inferred

        # Also normalize per-level "mode" if missing (keep existing if present)
        levels = plan.get("tp_levels")
        if isinstance(levels, list):
            changed = False
            for it in levels:
                if not isinstance(it, dict):
                    continue
                if not str(it.get("mode") or "").strip():
                    it["mode"] = inferred
                    changed = True
            if changed:
                plan["tp_levels"] = levels

        obj.plan = plan
        obj.save(update_fields=["plan"])


def noop_reverse(apps, schema_editor):
    # No safe reverse for data backfill.
    return


class Migration(migrations.Migration):

    dependencies = [
        ("signals", "0011_usertradeplanpreset"),
    ]

    operations = [
        migrations.RunPython(backfill_tp_mode, noop_reverse),
    ]

