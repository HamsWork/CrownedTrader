{% extends 'signals/base.html' %}
{% load static %}

{% block breadcrumbs %}
<a href="{% url 'dashboard' %}">Dashboard</a>
<span>/</span>
<span>Submit Signal</span>
{% endblock %}

{% block extra_css %}
<style>
    .dashboard-page {
        width: 100%;
        max-width: none;
        margin: 0;
    }

    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 30px;
    }

    .page-title-section h1 {
        color: #e0e0e0;
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 10px;
    }

    .page-title-section p {
        color: #888;
        font-size: 1.1em;
    }

    .page-actions {
        display: flex;
        gap: 12px;
    }

    .btn-cancel {
        background: #2d2d2d;
        color: #e0e0e0;
        padding: 12px 24px;
        border: 1px solid #444;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s;
        cursor: pointer;
    }

    .btn-cancel:hover {
        background: #353535;
        border-color: #555;
    }

    .btn-publish {
        background: var(--accent);
        color: #1a1a1a;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-publish:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.3);
    }

    .content-layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) clamp(420px, 34vw, 560px);
        gap: 30px;
        align-items: start;
    }

    .form-container {
        max-width: none;
        min-width: 0;
    }

    .form-section {
        background: rgba(15, 23, 42, 0.72);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        border: 1px solid rgba(42, 55, 95, 0.55);
    }

    .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }

    .section-divider {
        height: 1px;
        width: 100%;
        background: rgba(255, 255, 255, 0.08);
        margin: 14px 0 18px 0;
    }

    .section-icon {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }

    .section-icon.purple {
        background: #9333ea;
        color: white;
    }

    .section-icon.green {
        background: #10b981;
        color: white;
    }

    .section-icon.blue {
        background: #2563eb;
        color: white;
    }

    .section-icon img {
        width: 18px;
        height: 18px;
        display: block;
        filter: invert(100%);
    }

    .section-title {
        color: #e0e0e0;
        font-size: 1.3em;
        font-weight: 600;
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #e0e0e0;
        font-weight: 600;
        font-size: 0.95em;
    }
    
    /* For checkbox inputs, adjust label display */
    .form-group:has(.form-checkbox) {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group:has(.form-checkbox) label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group:has(.form-checkbox) .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }
    
    /* Fallback for browsers that don't support :has() */
    .form-group.checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group.checkbox-group label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group.checkbox-group .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }

    .form-input, .form-textarea, .form-select {
        width: 100%;
        padding: 12px 15px;
        border: 1px solid rgba(42, 55, 95, 0.65);
        border-radius: 12px;
        font-size: 1em;
        transition: all 0.3s;
        font-family: inherit;
        background: rgba(10, 16, 35, 0.72);
        color: #e0e0e0;
    }

    .form-input:hover, .form-textarea:hover, .form-select:hover {
        border-color: rgba(42, 55, 95, 0.9);
    }

    .form-input:focus, .form-textarea:focus, .form-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(var(--accent-rgb), 0.1);
    }

    /* Date input: dark calendar panel + tinted calendar icon */
    .form-input[type="date"] {
        color-scheme: dark;
        accent-color: var(--accent);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator {
        cursor: pointer;
        opacity: 0.95;
        padding: 6px;
        border-radius: 8px;
        background-color: rgba(var(--accent-rgb), 0.14);
        filter: invert(1);
        transition: background-color 180ms ease, transform 180ms ease, opacity 180ms ease;
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:hover {
        background-color: rgba(var(--accent-rgb), 0.22);
        opacity: 1;
        transform: translateY(-1px);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:active {
        transform: translateY(0);
    }

    .form-input::placeholder, .form-textarea::placeholder {
        color: #666;
    }

    /* Select dropdown styling */
    .form-select {
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 40px;
    }

    .form-select option {
        background: #050816;
        color: #e0e0e0;
    }

    .form-textarea {
        resize: vertical;
    }

    .form-checkbox {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }

    /* Mini switch (Embed options + Optional fields) */
    .switch-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .switch-text {
        color: #e8ecff;
        font-weight: 500;
        font-size: 0.95em;
        cursor: pointer;
        user-select: none;
    }

    .mini-switch {
        position: relative;
        width: 40px;
        height: 22px;
        flex: 0 0 auto;
        display: inline-block;
    }

    .mini-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .mini-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .mini-slider::before {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 16px rgba(0, 0, 0, 0.28);
        transition: 180ms ease;
    }

    .mini-switch input:checked + .mini-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .mini-switch input:checked + .mini-slider::before {
        transform: translate(18px, -50%);
        background: var(--accent);
    }

    .mini-switch input:focus + .mini-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    /* Inner cards inside a form-section (Embed Options / Optional Fields) */
    .sub-card {
        margin-top: 20px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.50);
        border: 1px solid rgba(42, 55, 95, 0.55);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Toggle switch (Equity / Shares) ‚Äì matches screenshot */
    .toggle-pill {
        display: flex;
        align-items: center;
        gap: 14px;
        width: 100%;
        padding: 14px 16px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        background: rgba(10, 16, 35, 0.62);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .toggle-switch {
        position: relative;
        width: 46px;
        height: 26px;
        flex: 0 0 auto;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .toggle-slider::before {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
        transition: 180ms ease;
    }

    .toggle-switch input:checked + .toggle-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .toggle-switch input:checked + .toggle-slider::before {
        transform: translate(20px, -50%);
        background: var(--accent);
    }

    .toggle-switch input:focus + .toggle-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    .toggle-label {
        color: #e8ecff;
        font-weight: 600;
        font-size: 0.95em;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .btn-submit {
        background: var(--accent);
        color: #1a1a1a;
        padding: 15px 40px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(var(--accent-rgb), 0.3);
    }

    .btn-submit:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(var(--accent-rgb), 0.4);
    }

    .btn-submit:active {
        transform: translateY(0);
    }

    /* Input with icon */
    .input-with-icon {
        position: relative;
    }

    .input-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
        font-size: 18px;
    }

    .form-input.has-icon {
        padding-right: 40px;
    }

    .recent-signals {
        margin-top: 40px;
        padding-top: 40px;
        border-top: 2px solid #f0f0f0;
    }

    .recent-signals h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 1.8em;
    }

    .signal-card {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 15px;
        border-left: 4px solid #667eea;
        transition: all 0.3s;
    }

    .signal-card:hover {
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .signal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .signal-ticker {
        font-size: 1.3em;
        font-weight: 700;
        color: #333;
    }

    .signal-badge {
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
    }

    .badge-entry {
        background: #d4edda;
        color: #155724;
    }

    .badge-stop_loss {
        background: #f8d7da;
        color: #721c24;
    }

    .badge-take_profit {
        background: #d1ecf1;
        color: #0c5460;
    }

    .signal-info {
        color: #666;
        font-size: 0.95em;
        margin-top: 10px;
        white-space: pre-wrap;
    }

    .signal-time {
        color: #999;
        font-size: 0.85em;
    }

    /* Discord Preview Styles */
    .discord-embed {
        display: flex;
        background: #2f3136;
        border-radius: 4px;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .discord-embed-color-bar {
        width: 4px;
        background: #5865f2;
        flex-shrink: 0;
    }

    .discord-embed-content {
        flex: 1;
        padding: 12px 16px 12px 12px;
        color: #dcddde;
        font-size: 14px;
        line-height: 1.375;
    }

    .discord-embed-title {
        color: #ffffff;
        font-weight: 600;
        font-size: 16px;
        margin-bottom: 8px;
        min-height: 20px;
    }

    .discord-embed-title:empty {
        display: none;
    }

    .discord-embed-description {
        color: #dcddde;
        margin-bottom: 8px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .discord-embed-description:empty {
        display: none;
    }

    .discord-embed-fields {
        margin-top: 8px;
    }

    .discord-embed-field {
        margin-bottom: 8px;
    }

    .discord-embed-field-inline {
        flex: 0 0 calc(33.333% - 11px);
        max-width: calc(33.333% - 11px);
    }

    .discord-embed-field-name {
        color: #ffffff;
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 2px;
        min-height: 16px;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

    .discord-embed-field-name:empty {
        display: none;
    }

    .discord-embed-field-value {
        color: #dcddde;
        font-size: 14px;
        white-space: pre-wrap;
        word-wrap: break-word;
        min-height: 16px;
    }

    .discord-embed-field-value:empty {
        display: none;
    }

    .discord-embed-footer {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        color: #72767d;
        font-size: 12px;
        min-height: 14px;
    }

    .discord-embed-footer:empty {
        display: none;
    }

    /* Discord Markdown Styles */
    .discord-embed-title strong,
    .discord-embed-description strong,
    .discord-embed-field-name strong,
    .discord-embed-field-value strong,
    .discord-embed-footer strong {
        font-weight: 600;
    }

    .discord-embed-title em,
    .discord-embed-description em,
    .discord-embed-field-name em,
    .discord-embed-field-value em,
    .discord-embed-footer em {
        font-style: italic;
    }

    .discord-embed-title u,
    .discord-embed-description u,
    .discord-embed-field-name u,
    .discord-embed-field-value u,
    .discord-embed-footer u {
        text-decoration: underline;
    }

    .discord-embed-title s,
    .discord-embed-description s,
    .discord-embed-field-name s,
    .discord-embed-field-value s,
    .discord-embed-footer s {
        text-decoration: line-through;
    }

    .discord-embed-title code,
    .discord-embed-description code,
    .discord-embed-field-name code,
    .discord-embed-field-value code,
    .discord-embed-footer code {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.9em;
    }

    .discord-embed-title pre,
    .discord-embed-description pre,
    .discord-embed-field-name pre,
    .discord-embed-field-value pre,
    .discord-embed-footer pre {
        background: rgba(0, 0, 0, 0.3);
        padding: 8px;
        border-radius: 4px;
        margin: 4px 0;
        overflow-x: auto;
    }

    .discord-embed-title pre code,
    .discord-embed-description pre code,
    .discord-embed-field-name pre code,
    .discord-embed-field-value pre code,
    .discord-embed-footer pre code {
        background: none;
        padding: 0;
    }

    /* Error messages */
    .form-group .error-message {
        color: #f87171;
        margin-top: 5px;
        font-size: 0.9em;
    }

    /* Responsive design */
    @media (max-width: 1200px) {
        .content-layout {
            grid-template-columns: 1fr;
        }

        .form-container {
            max-width: 100%;
        }

        div[style*="position: sticky"] {
            width: 100% !important;
            position: relative !important;
            top: 0 !important;
            margin-top: 30px !important;
        }
    }

    @media (max-width: 768px) {
        .page-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 20px;
        }

        .page-actions {
            width: 100%;
            justify-content: flex-end;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-page">
    <!-- Page Header -->
    <div class="page-header">
        <div class="page-title-section">
            <h1>Submit New Signal</h1>
            <p>Create and broadcast a new trading signal to your Discord community.</p>
        </div>
        <div class="page-actions">
            <a class="btn-cancel" href="{% url 'dashboard' %}">Cancel</a>
            <button type="submit" form="signalForm" class="btn-publish">
                <span>üì§</span>
                <span>Publish Signal</span>
            </button>
        </div>
    </div>

    <div class="content-layout">
        <div class="form-container">
            <form method="post" id="signalForm">
                {% csrf_token %}
                
                <!-- Signal Configuration Section -->
                <div class="form-section">
                    <div class="section-header">
                        <div class="section-icon blue"><img src="{% static 'signals/icons/layers.svg' %}" alt="" /></div>
                        <div class="section-title">Signal Configuration</div>
                    </div>
                    <div class="section-divider"></div>
                    
                    <div class="form-group">
                        <label for="{{ form.signal_type.id_for_label }}">Signal Type *</label>
                        {{ form.signal_type }}
                        {% if form.signal_type.errors %}
                            <div style="color: #f87171; margin-top: 5px; font-size: 0.9em;">{{ form.signal_type.errors }}</div>
                        {% endif %}
                    </div>

                    <!-- Discord Channel Selection -->
                    {% if discord_channels %}
                    <div class="form-group">
                        <label for="discord_channel">Destination Channel</label>
                        <div class="input-with-icon">
                            {% if discord_channels and discord_channels|length > 0 %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" required>
                                    {% for channel in discord_channels %}
                                    <option value="{{ channel.id }}" {% if channel.is_default %}selected{% elif forloop.first %}selected{% endif %}>
                                        {{ channel.channel_name }}{% if channel.is_default %} (Default){% endif %}
                                    </option>
                                    {% endfor %}
                                </select>
                            {% else %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" disabled>
                                    <option selected>No Discord channels configured</option>
                                </select>
                                <small style="display:block; margin-top:8px; color:#9ca3af;">Add a Discord channel in Settings / User Management, then refresh.</small>
                            {% endif %}
                            <span class="input-icon">üí¨</span>
                        </div>
                    </div>
                    {% endif %}
                </div>

                <!-- Trade Details Section -->
                <div class="form-section" id="tradeDetailsSection">
                    <div class="section-header">
                        <div class="section-icon green"><img src="{% static 'signals/icons/trending_up.svg' %}" alt="" /></div>
                        <div class="section-title">Trade Details</div>
                    </div>
                    <div class="section-divider"></div>

                    <!-- Dynamic Form Fields Container -->
                    <div id="dynamicFields"></div>

                    <!-- Embed Display Options -->
                    <div class="sub-card">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üì± Embed Display Options</div>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div class="switch-item">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showTitleCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showTitleCheckbox">Show title</label>
                            </div>
                            <div class="switch-item">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showDescriptionCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showDescriptionCheckbox">Show description</label>
                            </div>
                        </div>
                    </div>

                    <!-- Optional Fields Checkboxes -->
                    <div id="optionalFieldsSection" class="sub-card" style="display: none;">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üìã Optional Fields</div>
                        <div style="color: #888; font-size: 0.9em; margin-bottom: 15px;">Select which optional fields to include in your Discord message:</div>
                        <div id="optionalFieldsCheckboxesContainer" style="display: flex; flex-direction: column; gap: 10px;"></div>
                        <!-- Container for variables that become visible when optional fields are selected -->
                        <div id="optionalFieldsVariablesContainer" style="margin-top: 20px; display: none;">
                            <div style="color: #e0e0e0; font-size: 0.95em; margin-bottom: 12px; font-weight: 600; padding-top: 15px; border-top: 1px solid #2d2d2d;">üìù Related Variables</div>
                        </div>
                    </div>
                </div>

                

                <!-- Hidden field for data -->
                <input type="hidden" name="data" id="id_data" value="{}" />
                {% if form.data.errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.data.errors }}
                    </div>
                {% endif %}
                {% if form.non_field_errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}
            </form>
        </div>

        <!-- Live Preview Section -->
        <div style="position: sticky; top: 90px; width: 100%; z-index: 10;">
            <div class="form-section" style="margin-bottom: 0;">
                <div class="section-header" style="margin-bottom: 0;">
                    <div class="section-icon purple"><img src="{% static 'signals/icons/eye.svg' %}" alt="" /></div>
                    <div class="section-title">Live Preview</div>
                </div>
                <div class="section-divider"></div>
                <div id="discordPreview" style="max-width: 100%; margin: 0 auto;">
                    <div id="optionalFieldsControls" style="margin-bottom: 15px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; display: none;">
                        <div style="color: #dcddde; font-size: 0.85em; margin-bottom: 8px; font-weight: 600;">Optional Fields:</div>
                        <div id="optionalFieldsCheckboxes" style="display: flex; flex-direction: column; gap: 8px;"></div>
                    </div>
                    <div class="discord-embed">
                        <div class="discord-embed-color-bar" id="previewColorBar"></div>
                        <div class="discord-embed-content">
                            <div class="discord-embed-title" id="previewTitle">Select a signal type to see preview</div>
                            <div class="discord-embed-description" id="previewDescription"></div>
                            <div class="discord-embed-fields" id="previewFields"></div>
                            <div class="discord-embed-footer" id="previewFooter"></div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px; display: flex; align-items: start; gap: 10px;">
                        <span style="color: #60a5fa; font-size: 18px;">‚ÑπÔ∏è</span>
                        <p style="color: #9ca3af; font-size: 0.85em; margin: 0; line-height: 1.5;">This is how your signal will appear in Discord. Update the form to see changes in real-time.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% if recent_signals %}
<div class="form-container" style="margin-top: 40px;">
    <div class="recent-signals">
        <h2>üìä Recent Signals</h2>
        {% for signal in recent_signals %}
        <div class="signal-card">
            <div class="signal-header">
                <span class="signal-ticker">{{ signal.data.ticker }}</span>
                <span class="signal-badge badge-{{ signal.signal_type.name|lower|slugify }}">
                    {{ signal.signal_type.name }}
                </span>
            </div>
            <div class="signal-info">
                <strong>Strike:</strong> {{ signal.data.strike }} | <strong>Expiration:</strong> {{ signal.data.expiration }}
            </div>
            {% if signal.data.extra_info %}
            <div class="signal-info">
                <strong>Extra:</strong> {{ signal.data.extra_info|truncatewords:20 }}
            </div>
            {% endif %}
            <div class="signal-time">{{ signal.created_at|date:"M d, Y H:i" }}</div>
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
{{ signal_types_data|json_script:"signal-types-data" }}
<script>
// Store signal types data with full template information (Django json_script)
const signalTypesDataList = JSON.parse(document.getElementById('signal-types-data').textContent || '[]');
const signalTypesData = {};
signalTypesDataList.forEach((st) => {
    signalTypesData[String(st.id)] = st;
});

// Debug: Log signalTypesData to console
console.log('signalTypesData loaded:', signalTypesData);
console.log('Number of signal types:', Object.keys(signalTypesData).length);

// Track visibility of optional fields (default: hidden)
const optionalFieldsVisibility = {};

// Map variable types to input field types
function getInputType(variableType) {
    const typeMap = {
        'string': 'text',
        'number': 'number',
        'float': 'number',
        'date': 'date',
        'text': 'textarea',
        'boolean': 'checkbox'
    };
    return typeMap[variableType] || 'text';
}

// Treat optional flags robustly (boolean true vs string "true")
function isTruthyOptionalFlag(value) {
    return value === true || value === 'true' || value === 1 || value === '1';
}

function isOptionalField(field) {
    return field && isTruthyOptionalFlag(field.optional);
}

function getNonRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        // v is typically an object: {name, required, ...}
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        // Treat missing required as false (non-required)
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required !== true) set.add(String(name));
    });
    return set;
}

function getRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required === true) set.add(String(name));
    });
    return set;
}

function getFieldReferencedVariables(field) {
    const vars = new Set();
    extractVariablesFromTemplate(field?.name || '').forEach(v => vars.add(v));
    extractVariablesFromTemplate(field?.value || '').forEach(v => vars.add(v));
    return vars;
}

function fieldReferencesAnyRequiredVariable(field, signalType) {
    const required = getRequiredVariableSet(signalType);
    if (required.size === 0) return false;
    const vars = getFieldReferencedVariables(field);
    for (const v of vars) {
        if (required.has(v)) return true;
    }
    return false;
}

function isInferredOptionalField(field, signalType) {
    if (!field || !signalType) return false;
    const nonRequired = getNonRequiredVariableSet(signalType);
    if (nonRequired.size === 0) return false;

    const vars = getFieldReferencedVariables(field);

    // Only infer optional if the field actually depends on variables,
    // and ALL referenced variables are non-required (so required info isn't hideable).
    if (vars.size === 0) return false;
    for (const v of vars) {
        if (!nonRequired.has(v)) return false;
    }
    return true;
}

function isOptionalFieldForSignalType(field, signalType) {
    // Guardrail: required-variable fields should never be hideable
    if (fieldReferencesAnyRequiredVariable(field, signalType)) return false;

    // Honor explicit optional OR inferred optional (non-required variables only)
    return isOptionalField(field) || isInferredOptionalField(field, signalType);
}

// Get label from variable or fall back to default
function getLabel(variable) {
    // If variable has a label property, use it
    if (variable.label) {
        return variable.label;
    }
    // Otherwise, capitalize the name
    const name = variable.name || variable;
    return name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
}

// Parse Discord markdown to HTML
function parseDiscordMarkdown(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    
    // Code blocks (```code```) - must be processed before inline code
    html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
    
    // Inline code (`code`) - protect code from other markdown
    const codeBlocks = [];
    html = html.replace(/`([^`\n]+)`/g, (match, code) => {
        const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
        codeBlocks.push(`<code>${code}</code>`);
        return placeholder;
    });
    
    // Bold and italic combinations (***text***)
    html = html.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
    
    // Bold (**text**)
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // Bold (__text__) - Discord uses __ for bold
    html = html.replace(/__(?![_*])([^_]+)__(?![_*])/g, '<strong>$1</strong>');
    
    // Italic (*text*)
    html = html.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em>$1</em>');
    
    // Italic (_text_) - but not if it's part of bold
    html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');
    
    // Strikethrough (~~text~~)
    html = html.replace(/~~([^~]+)~~/g, '<s>$1</s>');
    
    // Restore code blocks
    codeBlocks.forEach((code, index) => {
        html = html.replace(`__CODE_BLOCK_${index}__`, code);
    });
    
    // Preserve newlines as <br>
    html = html.replace(/\n/g, '<br>');
    
    return html;
}

// Render template by replacing {{variable}} placeholders
function renderTemplate(template, data) {
    if (!template) return '';
    return template.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
        return data[varName] !== undefined ? String(data[varName]) : match;
    });
}

// Extract all variable names from a template string
function extractVariablesFromTemplate(template) {
    if (!template) return [];
    const variables = [];
    const regex = /\{\{(\w+)\}\}/g;
    let match;
    while ((match = regex.exec(template)) !== null) {
        if (!variables.includes(match[1])) {
            variables.push(match[1]);
        }
    }
    return variables;
}

// Get all variables that are currently used in visible templates and fields
function getUsedVariables(signalTypeId) {
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) return { all: new Set(), optionalOnly: new Set() };
    
    const usedVariables = new Set();
    const optionalOnlyVariables = new Set();
    
    // Track variables used in non-optional contexts
    const nonOptionalVariables = new Set();
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Check title template (if visible)
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    if (showTitle && signalType.title_template) {
        extractVariablesFromTemplate(signalType.title_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check description template (if visible)
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    if (showDescription && signalType.description_template) {
        extractVariablesFromTemplate(signalType.description_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check footer template
    if (signalType.footer_template) {
        extractVariablesFromTemplate(signalType.footer_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check fields template (considering optional fields and is_shares)
    if (signalType.fields_template) {
        let fields = signalType.fields_template;
        if (typeof fields === 'string') {
            try {
                fields = JSON.parse(fields);
            } catch (e) {
                fields = [];
            }
        }
        fields = fields || [];
        
        fields.forEach((field, index) => {
            const isOptional = isOptionalFieldForSignalType(field, signalType);
            const fieldKey = `field_${signalTypeId}_${index}`;
            const isOptionalVisible = isOptional && optionalFieldsVisibility[fieldKey];
            
            // Skip optional fields that are hidden
            if (isOptional && !isOptionalVisible) {
                return; // Skip this optional field
            }
            
            // Skip fields that contain strike, expiration when is_shares is checked
            if (isShares) {
                const fieldNameLower = (field.name || '').toLowerCase();
                if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')) {
                    return; // Skip this field
                }
            }
            
            // Extract variables from field name and value
            const fieldVars = new Set();
            if (field.name) {
                extractVariablesFromTemplate(field.name).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            if (field.value) {
                extractVariablesFromTemplate(field.value).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            
            // If this is an optional field, mark its variables as optional-only (if not already in non-optional)
            if (isOptional && isOptionalVisible) {
                fieldVars.forEach(v => {
                    if (!nonOptionalVariables.has(v)) {
                        optionalOnlyVariables.add(v);
                    }
                });
            } else {
                // Non-optional field, mark variables as non-optional
                fieldVars.forEach(v => nonOptionalVariables.add(v));
            }
        });
    }
    
    // Remove variables from optionalOnly if they're also in nonOptional
    nonOptionalVariables.forEach(v => optionalOnlyVariables.delete(v));
    
    return { all: usedVariables, optionalOnly: optionalOnlyVariables };
}

// Update Discord embed preview
function updatePreview() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.warn('Signal type not found for preview:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        return;
    }
    
    // Collect current form values
    const formData = {};
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Option-related fields that should be excluded when is_shares is checked
    const optionFields = ['strike', 'expiration', 'option_type'];
    
    // Collect inputs from both main dynamicFields container and optional fields variables container
    const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
    dynamicInputs.forEach(input => {
        // Skip option-related fields if is_shares is checked
        if (isShares && optionFields.includes(input.name)) {
            return;
        }
        
        // Skip hidden fields (those with data-requires-options when is_shares is true)
        if (input.closest('[data-requires-options="true"]') && isShares) {
            return;
        }
        
        if (input.type === 'checkbox') {
            formData[input.name] = input.checked ? 'true' : 'false';
        } else {
            formData[input.name] = input.value || '';
        }
    });
    
    // Update color bar
    const color = signalType.color || '#000000';
    document.getElementById('previewColorBar').style.backgroundColor = color;
    
    // Update title - check if title should be shown
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    const title = renderTemplate(signalType.title_template, formData);
    const titleEl = document.getElementById('previewTitle');
    if (title && showTitle) {
        titleEl.innerHTML = parseDiscordMarkdown(title);
        titleEl.style.display = 'block';
    } else {
        titleEl.style.display = 'none';
    }
    
    // Update description - check if description should be shown
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    const description = renderTemplate(signalType.description_template, formData);
    const descEl = document.getElementById('previewDescription');
    if (description && showDescription) {
        descEl.innerHTML = parseDiscordMarkdown(description);
        descEl.style.display = 'block';
    } else {
        descEl.style.display = 'none';
    }
    
    // Update fields
    const fieldsContainer = document.getElementById('previewFields');
    fieldsContainer.innerHTML = '';
    
    // Parse fields_template from JSON string if needed
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = fields || [];
    
    // First, collect all fields that should be rendered (with all filtering applied)
    const fieldsToRender = [];
    fields.forEach((field, index) => {
        // Render field name and value first
        const fieldName = renderTemplate(field.name || '', formData);
        const fieldValue = renderTemplate(field.value || '', formData);
        
        // Skip optional fields that are hidden
        if (isOptionalFieldForSignalType(field, signalType)) {
            const fieldKey = `field_${signalTypeId}_${index}`;
            if (!optionalFieldsVisibility[fieldKey]) {
                return; // Skip this optional field
            }
        }
        
        // Skip fields that contain strike, expiration, or option_type when is_shares is checked
        if (isShares) {
            const fieldNameLower = (field.name || '').toLowerCase();
            const fieldValueLower = (field.value || '').toLowerCase();
            const renderedNameLower = (fieldName || '').toLowerCase();
            const renderedValueLower = (fieldValue || '').toLowerCase();
            
            // Check both raw template and rendered values
            // if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration') || fieldNameLower.includes('option') ||
            //     fieldValueLower.includes('{{strike}}') || fieldValueLower.includes('{{expiration}}') || fieldValueLower.includes('{{option_type}}') ||
            //     renderedNameLower.includes('strike') || renderedNameLower.includes('expiration') || renderedNameLower.includes('option') ||
            //     renderedValueLower.includes('strike') || renderedValueLower.includes('expiration') || renderedValueLower.includes('option')) {
            //     return; // Skip this field
            // }
            if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')){
                return;
            }
        }
        
        // Store field data for rendering
        fieldsToRender.push({
            field: field,
            index: index,
            fieldName: fieldName,
            fieldValue: fieldValue
        });
    });
    
    // Remove consecutive blank spacers (keep only one)
    const filteredFields = [];
    let prevWasBlank = false;
    fieldsToRender.forEach((item) => {
        const isBlankSpacer = (!item.fieldName || !item.fieldName.trim()) && 
                             (item.fieldValue === '\u200b' || (item.fieldValue && item.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer && prevWasBlank) {
            return; // Skip consecutive blank spacers
        }
        prevWasBlank = isBlankSpacer;
        filteredFields.push(item);
    });
    
    // Remove trailing blank spacers
    while (filteredFields.length > 0) {
        const lastField = filteredFields[filteredFields.length - 1];
        const isBlankSpacer = (!lastField.fieldName || !lastField.fieldName.trim()) && 
                             (lastField.fieldValue === '\u200b' || (lastField.fieldValue && lastField.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer) {
            filteredFields.pop();
        } else {
            break;
        }
    }
    
    // Use filtered fields for rendering
    const fieldsToRenderFinal = filteredFields;
    
    let currentInlineGroup = null;
    
    // Function to adjust inline field widths based on count in group
    function adjustInlineGroupWidths(inlineGroup) {
        if (!inlineGroup) return;
        const fieldCount = inlineGroup.children.length;
        if (fieldCount === 0) return;
        
        // Calculate width based on number of fields
        let width;
        if (fieldCount === 1) {
            width = 'calc(33.333% - 11px)'; // Single field in a row of 3
        } else if (fieldCount === 2) {
            width = 'calc(50% - 8px)'; // Two fields: each takes 50% minus half the gap
        } else {
            width = 'calc(33.333% - 11px)'; // Three fields: each takes 33.333%
        }
        
        // Apply width to all fields in the group
        Array.from(inlineGroup.children).forEach(field => {
            field.style.flex = `0 0 ${width}`;
            field.style.maxWidth = width;
        });
    }
    
    // Now render the filtered fields
    fieldsToRenderFinal.forEach(({field, index, fieldName, fieldValue}, renderIndex) => {
        
        const fieldEl = document.createElement('div');
        fieldEl.className = 'discord-embed-field';
        
        // Check if this is an inline field
        if (field.inline) {
            // If previous field was not inline, start a new inline group
            if (!currentInlineGroup || (renderIndex > 0 && !fieldsToRenderFinal[renderIndex - 1].field.inline)) {
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            // Check if current group already has 3 fields, start a new row
            if (currentInlineGroup && currentInlineGroup.children.length >= 3) {
                // Adjust widths for the previous group before starting new one
                adjustInlineGroupWidths(currentInlineGroup);
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            fieldEl.classList.add('discord-embed-field-inline');
        } else {
            // Non-inline field, adjust widths for any existing inline group and close it
            adjustInlineGroupWidths(currentInlineGroup);
            currentInlineGroup = null;
        }
        
        const nameEl = document.createElement('div');
        nameEl.className = 'discord-embed-field-name';
        nameEl.innerHTML = fieldName ? parseDiscordMarkdown(fieldName) : '\u200b';
        
        const valueEl = document.createElement('div');
        valueEl.className = 'discord-embed-field-value';
        valueEl.innerHTML = fieldValue ? parseDiscordMarkdown(fieldValue) : '\u200b';
        
        fieldEl.appendChild(nameEl);
        if (fieldValue !== '') {
            fieldEl.appendChild(valueEl);
        }
            
        
        if (field.inline && currentInlineGroup) {
            currentInlineGroup.appendChild(fieldEl);
        } else {
            fieldsContainer.appendChild(fieldEl);
        }
    });
    
    // Adjust widths for any remaining inline group at the end
    adjustInlineGroupWidths(currentInlineGroup);
    
    // Update footer
    const footer = renderTemplate(signalType.footer_template, formData);
    const footerEl = document.getElementById('previewFooter');
    if (footer) {
        footerEl.innerHTML = parseDiscordMarkdown(footer);
        footerEl.style.display = 'block';
    } else {
        footerEl.style.display = 'none';
    }
}

// Create dynamic form fields based on signal type
function createDynamicFields(signalTypeId) {
    console.log('createDynamicFields called with signalTypeId:', signalTypeId);
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    if (!dynamicFieldsContainer) {
        console.error('dynamicFields container not found!');
        return;
    }
    dynamicFieldsContainer.innerHTML = '';
    
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.error('Signal type not found:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        updatePreview();
        return;
    }
    
    console.log('Found signal type:', signalType);
    
    // Parse variables from JSON string if needed
    let variables = signalType.variables;
    if (typeof variables === 'string') {
        try {
            variables = JSON.parse(variables);
        } catch (e) {
            console.error('Error parsing variables:', e, 'Raw value:', variables);
            variables = [];
        }
    }
    variables = variables || [];
    
    console.log('Parsed variables:', variables, 'Count:', variables.length);
    
    if (variables.length === 0) {
        console.warn('No variables found for signal type:', signalTypeId);
        dynamicFieldsContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No variables defined for this signal type.</p>';
        updatePreview();
        return;
    }
    
    // Get used variables to determine visibility
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    variables.forEach(variable => {
        // Check if this variable is used
        // is_shares is a special control variable that should always be visible
        const isSpecialControl = variable.name === 'is_shares';
        const isUsed = usedVariables.has(variable.name) || isSpecialControl;
        const isOptionalOnly = optionalOnlyVariables.has(variable.name);
        
        // Create form group with data attribute for visibility control
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', variable.name);
        // Initially hide if not used (but always show is_shares)
        if (!isUsed) {
            formGroup.style.display = 'none';
        }
        
        const label = document.createElement('label');
        const isRequired = variable.required === true;
        label.textContent = getLabel(variable) + (isRequired ? ' *' : '');
        label.setAttribute('for', `id_${variable.name}`);
        
        let input;
        
        const inputType = getInputType(variable.type);
        
        // Handle select type (dropdown)
        if (variable.type === 'select' && variable.options) {
            input = document.createElement('select');
            input.className = 'form-select';
            
            // Add options directly (no default placeholder)
            variable.options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                if (variable.default && option === variable.default) {
                    optionElement.selected = true;
                }
                input.appendChild(optionElement);
            });
        } else {
            if (inputType === 'textarea') {
                input = document.createElement('textarea');
                input.className = 'form-textarea';
                input.rows = 3;
                // input.placeholder = 'Additional information (optional)';
            } else if (inputType === 'checkbox') {
                // Handle boolean/checkbox (special-case is_shares later for switch UI)
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-checkbox';
                input.checked = variable.default || false;
            } else {
                input = document.createElement('input');
                input.className = 'form-input';
                input.type = inputType;
                
                // For float inputs, add step attribute to allow decimals
                if (variable.type === 'float') {
                    input.step = '0.01';
                }
                
                // Add placeholders
                const placeholders = {
                    'ticker': 'Enter ticker (e.g., AAPL, TSLA)',
                    'strike': 'Enter strike price (e.g., 150.50)',
                    'expiration': 'Enter expiration date (e.g., 2025-11-20)',
                    'price': 'Enter price (e.g., 1.25)',
                    'entry_price': 'Enter entry price (e.g., 1.25)',
                    'exit_price': 'Enter exit price (e.g., 1.50)',
                    'pnl_percent': 'Enter P&L % (e.g., 20.5)'
                };
                input.placeholder = placeholders[variable.name] || '';
            }
        }
        
        input.id = `id_${variable.name}`;
        input.name = variable.name;
        
        // Add HTML5 required attribute if field is required
        if (isRequired) {
            input.required = true;
            // Store that it was originally required for restoration
            input.setAttribute('data-originally-required', 'true');
        }
        
        // Add hint as placeholder if provided (overrides default placeholders)
        if (variable.hint && input.type !== 'checkbox') {
            input.placeholder = variable.hint;
        }
        
        // Add data attribute for conditional visibility based on is_shares
        if (variable.name === 'strike' || variable.name === 'expiration' || variable.name === 'option_type') {
            formGroup.setAttribute('data-requires-options', 'true');
        }
        
        // Special: render is_shares as a modern toggle switch pill (like screenshot)
        if ((variable.type === 'boolean' || inputType === 'checkbox') && variable.name === 'is_shares') {
            const pill = document.createElement('div');
            pill.className = 'toggle-pill';

            const switchWrap = document.createElement('label');
            switchWrap.className = 'toggle-switch';

            // ensure id/name match existing logic
            input.id = `id_${variable.name}`;
            input.name = variable.name;

            const slider = document.createElement('span');
            slider.className = 'toggle-slider';

            switchWrap.appendChild(input);
            switchWrap.appendChild(slider);

            const text = document.createElement('div');
            text.className = 'toggle-label';
            text.textContent = (variable.label || 'Equity / Shares') + ' (Disable Options fields)';

            pill.appendChild(switchWrap);
            pill.appendChild(text);

            // Don't use the normal label for this one
            formGroup.appendChild(pill);
        } else if (variable.type === 'boolean' || inputType === 'checkbox') {
            // Regular checkbox booleans
            formGroup.classList.add('checkbox-group');
            formGroup.appendChild(input);
            formGroup.appendChild(label);
        } else {
            formGroup.appendChild(label);
            formGroup.appendChild(input);
        }
        
        // Place in appropriate container based on whether it's optional-only and visible
        // is_shares should always stay in main container, never in optional container
        const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');
        if (isUsed && isOptionalOnly && optionalFieldsVariablesContainer && !isSpecialControl) {
            optionalFieldsVariablesContainer.appendChild(formGroup);
        } else {
            dynamicFieldsContainer.appendChild(formGroup);
        }
        
        // Add event listeners for real-time preview
        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
    });
    
    // Set up is_shares checkbox handler
    const isSharesCheckbox = document.getElementById('id_is_shares');
    if (isSharesCheckbox) {
        isSharesCheckbox.addEventListener('change', function() {
            toggleOptionFields(this.checked);
            updateVariableVisibility(); // Update variable visibility when is_shares changes
            updatePreview();
        });
        // Initialize on page load
        toggleOptionFields(isSharesCheckbox.checked);
    }
    
    // Create optional fields checkboxes
    createOptionalFieldsCheckboxes(signalTypeId);
    
    // Set checkbox defaults based on signal type
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    if (showTitleCheckbox && signalType.show_title_default !== undefined) {
        showTitleCheckbox.checked = signalType.show_title_default;
        
    }
    
    if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
        showDescriptionCheckbox.checked = signalType.show_description_default;
        
    }
    
    // Update variable visibility after fields are created
    updateVariableVisibility();
    
    // Update preview after fields are created
    updatePreview();
}

// Toggle visibility of option-related fields based on is_shares checkbox
function toggleOptionFields(isShares) {
    const optionFields = document.querySelectorAll('[data-requires-options="true"]');
    optionFields.forEach(field => {
        if (isShares) {
            field.style.display = 'none';
            const input = field.querySelector('input, select');
            if (input) {
                input.removeAttribute('required');
                input.value = '';
            }
        } else {
            field.style.display = 'block';
            const input = field.querySelector('input, select');
            if (input && input.hasAttribute('data-originally-required')) {
                input.setAttribute('required', true);
            }
        }
    });
}

// Update variable visibility based on which variables are currently used
function updateVariableVisibility() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');
    
    // Update visibility of all variable inputs
    const variableInputs = document.querySelectorAll('#dynamicFields [data-variable-name], #optionalFieldsVariablesContainer [data-variable-name]');
    variableInputs.forEach(formGroup => {
        const variableName = formGroup.getAttribute('data-variable-name');
        // is_shares is a special control variable that should always be visible
        const isSpecialControl = variableName === 'is_shares';
        const isUsed = usedVariables.has(variableName) || isSpecialControl;
        const isOptionalOnly = optionalOnlyVariables.has(variableName);
        const currentParent = formGroup.parentElement;
        const isInOptionalContainer = currentParent === optionalFieldsVariablesContainer;
        
        if (isUsed) {
            // Preserve checkbox-group alignment (inline style wins over CSS)
            formGroup.style.display = formGroup.classList.contains('checkbox-group') ? 'flex' : 'block';
            
            // is_shares should always stay in main container, never move to optional container
            if (isSpecialControl && isInOptionalContainer) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            } else if (isOptionalOnly && !isInOptionalContainer && !isSpecialControl) {
                // Move to optional fields container (but not is_shares)
                formGroup.remove();
                optionalFieldsVariablesContainer.appendChild(formGroup);
            } else if (!isOptionalOnly && isInOptionalContainer && !isSpecialControl) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            }
        } else {
            formGroup.style.display = 'none';
            // Clear the value when hiding (except for required fields and is_shares)
            if (!isSpecialControl) {
                const input = formGroup.querySelector('input, textarea, select');
                if (input && !input.hasAttribute('required')) {
                    if (input.type === 'checkbox') {
                        input.checked = false;
                    } else {
                        input.value = '';
                    }
                }
            }
        }
    });
    
    // Show/hide optional fields variables container based on visible variable inputs
    if (optionalFieldsVariablesContainer) {
        // Count visible variable inputs (form groups with data-variable-name that are not hidden)
        const visibleVariables = Array.from(optionalFieldsVariablesContainer.children).filter(child => {
            // Check if it's a form group with data-variable-name that's visible
            const hasVariableName = child.getAttribute && child.getAttribute('data-variable-name');
            const isVisible = child.style && child.style.display !== 'none';
            return hasVariableName && isVisible;
        });
        
        // Only show the container if there are visible variable inputs
        if (visibleVariables.length > 0) {
            optionalFieldsVariablesContainer.style.display = 'block';
        } else {
            optionalFieldsVariablesContainer.style.display = 'none';
        }
    }
}

// Create checkboxes for optional fields
function createOptionalFieldsCheckboxes(signalTypeId) {
    const optionalFieldsSection = document.getElementById('optionalFieldsSection');
    const optionalFieldsContainer = document.getElementById('optionalFieldsCheckboxesContainer');
    
    if (!optionalFieldsSection || !optionalFieldsContainer) {
        return;
    }
    
    // Clear existing checkboxes
    optionalFieldsContainer.innerHTML = '';
    
    // Get signal type data
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        optionalFieldsSection.style.display = 'none';
        return;
    }
    
    // Parse fields_template
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = fields || [];
    
    // Find optional fields
    const optionalFields = [];
    fields.forEach((field, index) => {
        if (isOptionalFieldForSignalType(field, signalType)) {
            // Extract a readable name from the field
            let fieldName = field.name || field.value || `Field ${index + 1}`;
            // Remove markdown, emojis, and variable placeholders, then clean up
            fieldName = fieldName.replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').replace(/\{\{.*?\}\}/g, '').trim();
            if (!fieldName) {
                fieldName = field.value ? field.value.replace(/\{\{.*?\}\}/g, '').replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').trim() : `Field ${index + 1}`;
            }
            if (!fieldName || fieldName === '\u200b') {
                fieldName = `Optional Field ${index + 1}`;
            }
            optionalFields.push({
                index: index,
                name: fieldName,
                field: field
            });
        }
    });
    
    // Show/hide section based on whether there are optional fields
    if (optionalFields.length === 0) {
        optionalFieldsSection.style.display = 'none';
        return;
    }
    
    optionalFieldsSection.style.display = 'block';
    
    // Create checkboxes for each optional field
    optionalFields.forEach(({index, name, field}) => {
        const fieldKey = `field_${signalTypeId}_${index}`;
        
        // Create row container
        const row = document.createElement('div');
        row.className = 'switch-item';

        // Create checkbox (kept as checkbox for logic, styled as switch)
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `optional_field_${fieldKey}`;
        checkbox.checked = optionalFieldsVisibility[fieldKey] || false;

        const switchWrap = document.createElement('label');
        switchWrap.className = 'mini-switch';

        const slider = document.createElement('span');
        slider.className = 'mini-slider';

        switchWrap.appendChild(checkbox);
        switchWrap.appendChild(slider);

        // Create text label
        const label = document.createElement('label');
        label.className = 'switch-text';
        label.htmlFor = checkbox.id;
        label.textContent = name;
        
        // Add change event listener
        checkbox.addEventListener('change', function() {
            optionalFieldsVisibility[fieldKey] = this.checked;
            updateVariableVisibility(); // Update variable visibility when optional fields change
            updatePreview();
        });
        
        row.appendChild(switchWrap);
        row.appendChild(label);
        optionalFieldsContainer.appendChild(row);
    });
}



// Handle title visibility toggle
function toggleTitleVisibility() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowTitle', showTitleCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Handle description visibility toggle
function toggleDescriptionVisibility() {
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowDescription', showDescriptionCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Load visibility preferences from localStorage or signal type defaults
function loadVisibilityPreferences() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    // Check if a signal type is already selected
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    let useSignalTypeDefaults = false;
    
    if (signalTypeSelect && signalTypeSelect.value) {
        const signalTypeId = signalTypeSelect.value;
        const signalTypeIdStr = String(signalTypeId);
        const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
        
        if (signalType && (signalType.show_title_default !== undefined || signalType.show_description_default !== undefined)) {
            useSignalTypeDefaults = true;
            
            if (showTitleCheckbox && signalType.show_title_default !== undefined) {
                showTitleCheckbox.checked = signalType.show_title_default;
                localStorage.setItem('discordShowTitle', signalType.show_title_default ? 'true' : 'false');
            }
            
            if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
                showDescriptionCheckbox.checked = signalType.show_description_default;
                localStorage.setItem('discordShowDescription', signalType.show_description_default ? 'true' : 'false');
            }
        }
    }
    
}

// Handle signal type change
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded - Initializing dashboard...');
    
    // Initialize visibility preferences
    loadVisibilityPreferences();
    
    // Add event listeners to checkboxes
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        showTitleCheckbox.addEventListener('change', toggleTitleVisibility);
    }
    
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        showDescriptionCheckbox.addEventListener('change', toggleDescriptionVisibility);
    }
    
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    const form = document.getElementById('signalForm');
    
    console.log('signalTypeSelect found:', !!signalTypeSelect);
    console.log('signalTypesData keys:', Object.keys(signalTypesData));
    
    if (signalTypeSelect) {
        // Initial load - always create fields for the first/default value
        const defaultValue = signalTypeSelect.value || signalTypeSelect.options[signalTypeSelect.selectedIndex]?.value || Object.keys(signalTypesData)[0];
        console.log('Default value determined:', defaultValue);
        
        if (defaultValue) {
            signalTypeSelect.value = defaultValue;
            console.log('Creating dynamic fields for default value:', defaultValue);
            createDynamicFields(defaultValue);
        } else {
            console.warn('No default value found. signalTypeSelect.value:', signalTypeSelect.value, 'Options:', signalTypeSelect.options.length);
        }
        
        // Handle change
        signalTypeSelect.addEventListener('change', function() {
            console.log('Signal type changed to:', this.value);
            if (this.value) {
                createDynamicFields(this.value);
                // Update preview immediately - createDynamicFields already calls it, but ensure it happens
                updatePreview();
            }
        });
        
        // Handle form submission
        form.addEventListener('submit', function(e) {
            // Get current signal type and its variables
            const currentSignalTypeId = signalTypeSelect.value;
            const currentSignalType = signalTypesData[currentSignalTypeId];
            const currentVariables = currentSignalType ? (currentSignalType.variables || []) : [];
            
            // Validate required fields - include inputs from both containers
            const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
            const errors = [];
            
            // Check if is_shares is checked
            const isSharesCheckbox = document.getElementById('id_is_shares');
            const isShares = isSharesCheckbox && isSharesCheckbox.checked;
            
            dynamicInputs.forEach(input => {
                // Skip validation if field is hidden due to is_shares
                if (input.closest('[data-requires-options="true"]') && isShares) {
                    return;
                }
                
                // Find the variable definition for this input
                const variable = currentVariables.find(v => v.name === input.name);
                
                // Check if field is required
                if (variable && variable.required === true) {
                    let isEmpty = false;
                    
                    // Check if field is empty based on type
                    if (input.type === 'checkbox') {
                        isEmpty = !input.checked;
                    } else {
                        isEmpty = !input.value || input.value.trim() === '';
                    }
                    
                    if (isEmpty) {
                        errors.push(variable.label || variable.name);
                        // Add error styling to the field
                        input.style.borderColor = '#dc3545';
                        const formGroup = input.closest('.form-group');
                        if (formGroup) {
                            formGroup.style.marginBottom = '10px';
                        }
                    } else {
                        // Remove error styling if field is valid
                        input.style.borderColor = '';
                    }
                } else {
                    // Remove error styling for non-required fields
                    input.style.borderColor = '';
                }
            });
            
            // Show errors if any and prevent submission
            if (errors.length > 0) {
                e.preventDefault();
                alert('Please fill in the following required fields:\n' + errors.map(e => '  ‚Ä¢ ' + e).join('\n'));
                return false;
            }
            
            // Collect all dynamic field values into a JSON object
            const signalData = {};
            dynamicInputs.forEach(input => {
                // Handle checkbox
                if (input.type === 'checkbox') {
                    signalData[input.name] = input.checked ? 'true' : 'false';
                } else {
                    signalData[input.name] = input.value;
                }
            });
            
            // Collect optional field selections
            const optionalFieldsIndices = [];
            // currentSignalType already declared above
            if (currentSignalType) {
                let fields = currentSignalType.fields_template;
                if (typeof fields === 'string') {
                    try {
                        fields = JSON.parse(fields);
                    } catch (e) {
                        fields = [];
                    }
                }
                fields = fields || [];
                
                fields.forEach((field, index) => {
                    if (isOptionalFieldForSignalType(field, currentSignalType)) {
                        const fieldKey = `field_${currentSignalTypeId}_${index}`;
                        if (optionalFieldsVisibility[fieldKey] === true) {
                            optionalFieldsIndices.push(index);
                        }
                    }
                });
            }
            
            // Store optional field indices in signalData
            if (optionalFieldsIndices.length > 0) {
                signalData['_optional_fields'] = optionalFieldsIndices;
            }
            
            // Store title and description visibility preferences
            const showTitleCheckbox = document.getElementById('showTitleCheckbox');
            const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
            if (showTitleCheckbox) {
                signalData['_show_title'] = showTitleCheckbox.checked;
            }
            if (showDescriptionCheckbox) {
                signalData['_show_description'] = showDescriptionCheckbox.checked;
            }
            
            // Set the data field value
            const dataInput = form.querySelector('input[name="data"]');
            if (dataInput) {
                dataInput.value = JSON.stringify(signalData);
            } else {
                // If data field doesn't exist, add it to the form
                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = 'data';
                hiddenInput.value = JSON.stringify(signalData);
                form.appendChild(hiddenInput);
            }
            
            // Let form submit naturally if validation passes
        });
    }
});
</script>
{% endblock %}

