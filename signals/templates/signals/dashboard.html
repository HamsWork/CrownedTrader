{% extends 'signals/base.html' %}
{% load static %}

{% block breadcrumbs %}
{% if trade_plan_only %}
<a href="{% url 'saved_trade_plans' %}">Saved Trade plans</a>
<span>/</span>
<span>New Trade Plan</span>
{% else %}
<a href="{% url 'dashboard' %}">Dashboard</a>
<span>/</span>
<span>Submit Signal</span>
{% endif %}
{% endblock %}

{% block extra_css %}
<style>
    .dashboard-page {
        width: 100%;
        max-width: none;
        margin: 0;
    }

    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 30px;
    }

    .page-title-section h1 {
        color: #e0e0e0;
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 10px;
    }

    .page-title-section p {
        color: #888;
        font-size: 1.1em;
    }

    .page-actions {
        display: flex;
        gap: 12px;
    }

    .btn-cancel {
        background: #2d2d2d;
        color: #e0e0e0;
        padding: 12px 24px;
        border: 1px solid #444;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s;
        cursor: pointer;
    }

    .btn-cancel:hover {
        background: #353535;
        border-color: #555;
    }

    /* Disabled button state (make it obvious) */
    .btn-cancel:disabled,
    .btn-submit:disabled,
    .btn-publish:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none !important;
        transform: none !important;
        filter: grayscale(0.35) saturate(0.65);
    }

    .btn-cancel:disabled {
        background: rgba(45, 45, 45, 0.65);
        color: rgba(224, 224, 224, 0.55);
        border-color: rgba(68, 68, 68, 0.55);
    }

    .btn-submit:disabled,
    .btn-publish:disabled {
        background: rgba(var(--accent-rgb), 0.25);
        color: rgba(26, 26, 26, 0.75);
    }

    .btn-cancel:disabled:hover,
    .btn-submit:disabled:hover,
    .btn-publish:disabled:hover {
        background: inherit;
        border-color: inherit;
        transform: none;
        box-shadow: none;
    }

    .btn-publish {
        background: var(--accent);
        color: #1a1a1a;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-publish:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.3);
    }

    .content-layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) clamp(420px, 34vw, 560px);
        gap: 30px;
        align-items: start;
    }

    /* "New Trade Plan" mode: show only Trade Plan + Live Preview */
    .dashboard-page[data-mode="trade_plan_only"] .page-actions {
        display: none;
    }
    .dashboard-page[data-mode="trade_plan_only"] .page-title-section h1 {
        font-size: 2.1em;
    }
    .dashboard-page[data-mode="trade_plan_only"] .page-title-section p {
        max-width: 720px;
    }
    .dashboard-page[data-mode="trade_plan_only"] .form-section#signalConfigSection {
        display: none;
    }
    .dashboard-page[data-mode="trade_plan_only"] .sub-card:not(.trade-plan-group) {
        display: none;
    }
    .dashboard-page[data-mode="trade_plan_only"] #tradeDetailsSection .section-header,
    .dashboard-page[data-mode="trade_plan_only"] #tradeDetailsSection .section-divider {
        display: none;
    }
    /* Remove the extra outer card around Trade Plan in New Trade Plan mode */
    .dashboard-page[data-mode="trade_plan_only"] #tradeDetailsSection.form-section {
        background: transparent;
        border: none;
        padding: 0;
        margin-bottom: 0;
        box-shadow: none;
    }
    /* Ensure New Trade Plan input panel only shows the Trade Plan card */
    .dashboard-page[data-mode="trade_plan_only"] #dynamicFields > *:not(.trade-plan-group) {
        display: none !important;
    }
    .dashboard-page[data-mode="trade_plan_only"] .ticker-type-row,
    .dashboard-page[data-mode="trade_plan_only"] [data-variable-name="ticker"],
    .dashboard-page[data-mode="trade_plan_only"] [data-variable-name="symbol"],
    .dashboard-page[data-mode="trade_plan_only"] [data-variable-name="option_type"],
    .dashboard-page[data-mode="trade_plan_only"] #optionalFieldsSection,
    .dashboard-page[data-mode="trade_plan_only"] #optionalFieldsVariablesContainer,
    .dashboard-page[data-mode="trade_plan_only"] #optionalFieldsCheckboxesContainer,
    .dashboard-page[data-mode="trade_plan_only"] #optionalFieldsControls {
        display: none !important;
    }

    .form-container {
        max-width: none;
        min-width: 0;
    }

    .form-section {
        background: rgba(15, 23, 42, 0.72);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        border: 1px solid rgba(42, 55, 95, 0.55);
    }

    .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }

    .section-divider {
        height: 1px;
        width: 100%;
        background: rgba(255, 255, 255, 0.08);
        margin: 14px 0 18px 0;
    }

    .section-icon {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }

    .section-icon.purple {
        background: #9333ea;
        color: white;
    }

    .section-icon.green {
        background: #10b981;
        color: white;
    }

    .section-icon.blue {
        background: #2563eb;
        color: white;
    }

    .section-icon img {
        width: 18px;
        height: 18px;
        display: block;
        filter: invert(100%);
    }

    .section-title {
        color: #e0e0e0;
        font-size: 1.3em;
        font-weight: 600;
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #e0e0e0;
        font-weight: 600;
        font-size: 0.95em;
    }
    
    /* For checkbox inputs, adjust label display */
    .form-group:has(.form-checkbox) {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group:has(.form-checkbox) label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group:has(.form-checkbox) .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }
    
    /* Fallback for browsers that don't support :has() */
    .form-group.checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group.checkbox-group label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group.checkbox-group .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }

    .form-input, .form-textarea, .form-select {
        width: 100%;
        padding: 12px 15px;
        border: 1px solid rgba(42, 55, 95, 0.65);
        border-radius: 12px;
        font-size: 1em;
        transition: all 0.3s;
        font-family: inherit;
        background: rgba(10, 16, 35, 0.72);
        color: #e0e0e0;
    }

    /* Ticker search dropdown (ticker_select / ticker_type) */
    .ticker-search {
        position: relative;
        width: 100%;
    }

    /* Ticker + is_shares inline row */
    .ticker-type-row {
        display: flex;
        align-items: center;
        gap: 12px;
        width: 100%;
    }

    .ticker-type-row .ticker-search {
        flex: 1 1 auto;
        min-width: 0;
    }

    .ticker-type-row .toggle-pill {
        flex: 0 0 auto;
        width: auto;
        padding: 10px 12px;
        border-radius: 12px;
    }

    .ticker-type-row .toggle-label {
        font-size: 0.9em;
        max-width: 260px;
    }

    .ticker-search-dropdown {
        position: absolute;
        top: calc(100% + 8px);
        left: 0;
        right: 0;
        /* Keep results above other form controls */
        z-index: 2000;
        /* Opaque background so underlying controls (e.g. is_shares toggle) don't show through */
        background: #0a1023;
        border: 1px solid rgba(42, 55, 95, 0.85);
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        max-height: 280px;
        overflow: auto;
        padding: 6px;
        display: none;
    }

    .ticker-search-dropdown.open {
        display: block;
    }

    .ticker-search-item {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 10px;
        border-radius: 10px;
        cursor: pointer;
        border: 1px solid transparent;
        user-select: none;
    }

    .ticker-search-item:hover,
    .ticker-search-item.active {
        background: rgba(var(--accent-rgb), 0.10);
        border-color: rgba(var(--accent-rgb), 0.25);
    }

    .ticker-search-symbol {
        font-weight: 700;
        color: #e5e7eb;
        letter-spacing: 0.2px;
    }

    .ticker-search-name {
        color: #9ca3af;
        font-size: 0.92em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        text-align: right;
    }

    .ticker-search-empty {
        padding: 10px 10px;
        color: #9ca3af;
        font-size: 0.92em;
    }

    .form-input:hover, .form-textarea:hover, .form-select:hover {
        border-color: rgba(42, 55, 95, 0.9);
    }

    .form-input:focus, .form-textarea:focus, .form-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(var(--accent-rgb), 0.1);
    }

    /* Date input: dark calendar panel + tinted calendar icon */
    .form-input[type="date"] {
        color-scheme: dark;
        accent-color: var(--accent);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator {
        cursor: pointer;
        opacity: 0.95;
        padding: 6px;
        border-radius: 8px;
        background-color: rgba(var(--accent-rgb), 0.14);
        filter: invert(1);
        transition: background-color 180ms ease, transform 180ms ease, opacity 180ms ease;
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:hover {
        background-color: rgba(var(--accent-rgb), 0.22);
        opacity: 1;
        transform: translateY(-1px);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:active {
        transform: translateY(0);
    }

    .form-input::placeholder, .form-textarea::placeholder {
        color: #666;
    }

    /* Select dropdown styling */
    .form-select {
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 40px;
    }

    .form-select option {
        background: #050816;
        color: #e0e0e0;
    }

    .form-textarea {
        resize: none;
        overflow-y: hidden;
        min-height: 6em; /* ~3 lines so Related Variables textareas show full hint and don't collapse to 1 line */
    }

    .form-checkbox {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }

    /* Mini switch (Embed options + Optional fields) */
    .switch-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .switch-text {
        color: #e8ecff;
        font-weight: 500;
        font-size: 0.95em;
        cursor: pointer;
        user-select: none;
    }

    .mini-switch {
        position: relative;
        width: 40px;
        height: 22px;
        flex: 0 0 auto;
        display: inline-block;
    }

    .mini-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .mini-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .mini-slider::before {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 16px rgba(0, 0, 0, 0.28);
        transition: 180ms ease;
    }

    .mini-switch input:checked + .mini-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .mini-switch input:checked + .mini-slider::before {
        transform: translate(18px, -50%);
        background: var(--accent);
    }

    .mini-switch input:focus + .mini-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    /* Inner cards inside a form-section (Embed Options / Optional Fields) */
    .sub-card {
        margin-top: 20px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.50);
        border: 1px solid rgba(42, 55, 95, 0.55);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Toggle switch (Is_Shares) */
    .toggle-pill {
        display: flex;
        align-items: center;
        gap: 14px;
        width: 100%;
        padding: 14px 16px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        background: rgba(10, 16, 35, 0.62);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .toggle-switch {
        position: relative;
        width: 46px;
        height: 26px;
        flex: 0 0 auto;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .toggle-slider::before {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
        transition: 180ms ease;
    }

    .toggle-switch input:checked + .toggle-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .toggle-switch input:checked + .toggle-slider::before {
        transform: translate(20px, -50%);
        background: var(--accent);
    }

    .toggle-switch input:focus + .toggle-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    .toggle-label {
        color: #e8ecff;
        font-weight: 600;
        font-size: 0.95em;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .btn-submit {
        background: var(--accent);
        color: #1a1a1a;
        padding: 15px 40px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(var(--accent-rgb), 0.3);
    }

    .btn-submit:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(var(--accent-rgb), 0.4);
    }

    .btn-submit:active {
        transform: translateY(0);
    }

    /* Trade Plan TP remove button (inline with label) */
    /* Take Profit row layout */
    .tp-level-row {
        background: rgba(10, 16, 35, 0.55);
        border: 1px solid rgba(42, 55, 95, 0.55);
        border-radius: 12px;
        padding: 12px;
    }

    .tp-level-row-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
    }

    .tp-level-row-header label {
        margin: 0;
        font-weight: 700;
        color: #e5e7eb;
    }

    .tp-level-row-body {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
    }

    .tp-remove-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: transparent;
        border: none;
        padding: 0;
        color: #ef4444;
        font-weight: 600;
        font-size: 0.92em;
        cursor: pointer;
        user-select: none;
    }

    .tp-remove-btn:hover {
        color: #f87171;
        text-decoration: underline;
    }

    .tp-remove-btn svg {
        width: 14px;
        height: 14px;
        display: block;
        fill: currentColor;
    }

    .tp-actions-panel {
        margin-top: 10px;
        padding: 12px;
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(42, 55, 95, 0.6);
        border-radius: 10px;
        display: block;
    }
    .tp-actions-panel label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        font-size: 0.88em;
        color: #9ca3af;
    }
    .tp-actions-panel select,
    .tp-actions-panel input[type="number"] {
        margin-right: 8px;
        margin-bottom: 8px;
    }

    .tp-level-row-body .form-group {
        margin-bottom: 0;
        min-width: 0;
    }

    .tp-level-row-body .form-group label {
        margin-bottom: 6px;
        font-weight: 600;
        font-size: 0.88em;
        color: #9ca3af;
    }

    .percent-input-wrap {
        position: relative;
    }

    .percent-suffix {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #9ca3af;
        font-weight: 700;
        pointer-events: none;
    }

    /* Input with icon */
    .input-with-icon {
        position: relative;
    }

    .input-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
        font-size: 18px;
    }

    .form-input.has-icon {
        padding-right: 40px;
    }

    .recent-signals {
        margin-top: 40px;
        padding-top: 40px;
        border-top: 2px solid #f0f0f0;
    }

    .recent-signals h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 1.8em;
    }

    .signal-card {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 15px;
        border-left: 4px solid #667eea;
        transition: all 0.3s;
    }

    .signal-card:hover {
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .signal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .signal-ticker {
        font-size: 1.3em;
        font-weight: 700;
        color: #333;
    }

    .signal-badge {
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
    }

    .badge-entry {
        background: #d4edda;
        color: #155724;
    }

    .badge-stop_loss {
        background: #f8d7da;
        color: #721c24;
    }

    .badge-take_profit {
        background: #d1ecf1;
        color: #0c5460;
    }

    .signal-info {
        color: #666;
        font-size: 0.95em;
        margin-top: 10px;
        white-space: pre-wrap;
    }

    .signal-time {
        color: #999;
        font-size: 0.85em;
    }

    /* Discord Preview Styles */
    .discord-embed {
        display: flex;
        background: #2f3136;
        border-radius: 4px;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .discord-embed-color-bar {
        width: 4px;
        background: #5865f2;
        flex-shrink: 0;
    }

    .discord-embed-content {
        flex: 1;
        padding: 12px 16px 12px 12px;
        color: #dcddde;
        font-size: 14px;
        line-height: 1.375;
    }

    .discord-embed-title {
        color: #ffffff;
        font-weight: 600;
        font-size: 16px;
        margin-bottom: 8px;
        min-height: 20px;
    }

    .discord-embed-title:empty {
        display: none;
    }

    .discord-embed-description {
        color: #dcddde;
        margin-bottom: 8px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .discord-embed-description:empty {
        display: none;
    }

    .discord-embed-fields {
        margin-top: 8px;
    }

    .discord-embed-media {
        margin-top: 10px;
        border-radius: 8px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.2);
    }

    .discord-embed-disclaimer {
        color: #dcddde;
        font-size: 0.95em;
        margin-top: 1.2em; /* blank line above Disclaimer in Post a trade Preview */
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .discord-embed-disclaimer:empty {
        display: none;
    }

    .discord-embed-field {
        margin-bottom: 8px;
    }

    .discord-embed-field-inline {
        flex: 0 0 calc(33.333% - 11px);
        max-width: calc(33.333% - 11px);
    }

    .discord-embed-field-name {
        color: #ffffff;
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 2px;
        min-height: 16px;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

    .discord-embed-field-name:empty {
        display: none;
    }

    .discord-embed-field-value {
        color: #dcddde;
        font-size: 14px;
        white-space: pre-wrap;
        word-wrap: break-word;
        min-height: 16px;
    }

    .discord-embed-field-value:empty {
        display: none;
    }

    .discord-embed-footer {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        color: #72767d;
        font-size: 12px;
        min-height: 14px;
    }

    .discord-embed-footer:empty {
        display: none;
    }

    /* TA Media drag & drop (same as Post TA) */
    .ta-drop {
        border: 1px dashed rgba(42, 55, 95, 0.85);
        border-radius: 14px;
        background: rgba(10, 16, 35, 0.62);
        padding: 16px;
        cursor: pointer;
        transition: border-color 180ms ease, background 180ms ease, transform 180ms ease;
        display: grid;
        gap: 8px;
    }
    .ta-drop:hover {
        border-color: rgba(var(--accent-rgb), 0.75);
        background: rgba(var(--accent-rgb), 0.06);
        transform: translateY(-1px);
    }
    .ta-drop.dragover {
        border-color: rgba(var(--accent-rgb), 0.95);
        background: rgba(var(--accent-rgb), 0.10);
    }
    .ta-drop-title {
        color: rgba(232, 236, 255, 0.92);
        font-weight: 900;
    }
    .ta-drop-sub {
        color: rgba(232, 236, 255, 0.62);
        font-size: 0.92em;
    }
    .ta-drop-file {
        margin-top: 6px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(42, 55, 95, 0.55);
        background: rgba(15, 23, 42, 0.50);
        color: rgba(232, 236, 255, 0.88);
        font-weight: 800;
        width: fit-content;
        max-width: 100%;
    }
    .ta-drop-file span {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 520px;
    }
    .ta-drop-preview {
        margin-top: 6px;
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(42, 55, 95, 0.55);
        background: rgba(0, 0, 0, 0.25);
        overflow: hidden;
        display: none;
    }
    .ta-drop-preview img,
    .ta-drop-preview video {
        width: 100%;
        display: block;
        max-height: 260px;
        object-fit: contain;
        background: rgba(0,0,0,0.25);
    }
    .ta-drop-clear {
        height: 28px;
        padding: 0 10px;
        border-radius: 10px;
        border: 1px solid rgba(42, 55, 95, 0.75);
        background: rgba(255, 255, 255, 0.04);
        color: rgba(232, 236, 255, 0.9);
        cursor: pointer;
        font-weight: 900;
    }
    .ta-drop-clear:hover {
        background: rgba(255, 255, 255, 0.06);
    }

    /* Discord Markdown Styles */
    .discord-embed-title strong,
    .discord-embed-description strong,
    .discord-embed-field-name strong,
    .discord-embed-field-value strong,
    .discord-embed-footer strong {
        font-weight: 600;
    }

    .discord-embed-title em,
    .discord-embed-description em,
    .discord-embed-field-name em,
    .discord-embed-field-value em,
    .discord-embed-footer em {
        font-style: italic;
    }

    .discord-embed-title u,
    .discord-embed-description u,
    .discord-embed-field-name u,
    .discord-embed-field-value u,
    .discord-embed-footer u {
        text-decoration: underline;
    }

    .discord-embed-title s,
    .discord-embed-description s,
    .discord-embed-field-name s,
    .discord-embed-field-value s,
    .discord-embed-footer s {
        text-decoration: line-through;
    }

    .discord-embed-title code,
    .discord-embed-description code,
    .discord-embed-field-name code,
    .discord-embed-field-value code,
    .discord-embed-footer code {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.9em;
    }

    .discord-embed-title pre,
    .discord-embed-description pre,
    .discord-embed-field-name pre,
    .discord-embed-field-value pre,
    .discord-embed-footer pre {
        background: rgba(0, 0, 0, 0.3);
        padding: 8px;
        border-radius: 4px;
        margin: 4px 0;
        overflow-x: auto;
    }

    .discord-embed-title pre code,
    .discord-embed-description pre code,
    .discord-embed-field-name pre code,
    .discord-embed-field-value pre code,
    .discord-embed-footer pre code {
        background: none;
        padding: 0;
    }

    /* Error messages */
    .form-group .error-message {
        color: #f87171;
        margin-top: 5px;
        font-size: 0.9em;
    }

    /* Responsive design */
    @media (max-width: 1200px) {
        .content-layout {
            grid-template-columns: 1fr;
        }

        .form-container {
            max-width: 100%;
        }

        div[style*="position: sticky"] {
            width: 100% !important;
            position: relative !important;
            top: 0 !important;
            margin-top: 30px !important;
        }
    }

    @media (max-width: 768px) {
        .page-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 20px;
        }

        .page-actions {
            width: 100%;
            justify-content: flex-end;
        }
    }

    /* Trade Plan: centered modal (theme-matched) */
    .ctp-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 24px;
    }

    .ctp-modal-overlay.open {
        display: flex;
    }

    .ctp-modal {
        width: min(520px, 100%);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(42, 55, 95, 0.7);
        border-radius: 14px;
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        padding: 18px;
        color: #e5e7eb;
    }

    .ctp-modal-title {
        font-size: 1.35em;
        font-weight: 700;
        margin-bottom: 6px;
        color: #e0e0e0;
    }

    .ctp-modal-subtitle {
        font-size: 0.9em;
        color: #9ca3af;
        margin-bottom: 14px;
        line-height: 1.4;
    }

    .ctp-modal-actions {
        margin-top: 14px;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }

    /* Modal button sizing (smaller height than page CTAs) */
    .ctp-modal-actions .btn-cancel,
    .ctp-modal-actions .btn-submit {
        padding: 10px 16px;
        font-size: 0.95em;
        line-height: 1;
        border-radius: 10px;
        box-shadow: none;
    }

    .ctp-modal-error {
        margin-top: 8px;
        color: #f87171;
        font-size: 0.9em;
        display: none;
    }

    .ctp-modal-error.show {
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-page" data-mode="{% if trade_plan_only %}trade_plan_only{% else %}full{% endif %}">
    <!-- Page Header -->
    <div class="page-header">
        <div class="page-title-section">
            {% if trade_plan_only %}
            <h1>New Trade Plan</h1>
            <p>Create or edit your Trade Plan presets and confirm how they will look in the Live Preview.</p>
            {% else %}
            <h1>Submit New Signal</h1>
            <p>Create and broadcast a new trading signal to your Discord community.</p>
            {% endif %}
        </div>
        <div class="page-actions">
            <a class="btn-cancel" href="{% url 'dashboard' %}">Cancel</a>
            <button type="submit" form="signalForm" class="btn-publish">
                <span>üì§</span>
                <span>Publish Signal</span>
            </button>
        </div>
    </div>

    <div class="content-layout">
        <div class="form-container">
            <form method="post" id="signalForm">
                {% csrf_token %}
                
                <!-- Signal Configuration Section -->
                <div class="form-section" id="signalConfigSection">
                    <div class="section-header">
                        <div class="section-icon blue"><img src="{% static 'signals/icons/layers.svg' %}" alt="" /></div>
                        <div class="section-title">Signal Configuration</div>
                    </div>
                    <div class="section-divider"></div>
                    
                    <div class="form-group" id="signalTypeRow" style="display: none;">
                        <label for="{{ form.signal_type.id_for_label }}">Signal Type *</label>
                        {{ form.signal_type }}
                        {% if form.signal_type.errors %}
                            <div style="color: #f87171; margin-top: 5px; font-size: 0.9em;">{{ form.signal_type.errors }}</div>
                        {% endif %}
                    </div>

                    <!-- Discord Channel Selection -->
                    {% if discord_channels %}
                    <div class="form-group">
                        <label for="discord_channel">Destination Channel</label>
                        <div class="input-with-icon">
                            {% if discord_channels and discord_channels|length > 0 %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" required>
                                    {% for channel in discord_channels %}
                                    <option value="{{ channel.id }}" {% if channel.is_default %}selected{% elif forloop.first %}selected{% endif %}>
                                        {{ channel.channel_name }}{% if channel.is_default %} (Default){% endif %}
                                    </option>
                                    {% endfor %}
                                </select>
                            {% else %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" disabled>
                                    <option selected>No Discord channels configured</option>
                                </select>
                                <small style="display:block; margin-top:8px; color:#9ca3af;">Add a Discord channel in Settings / User Management, then refresh.</small>
                            {% endif %}
                            <span class="input-icon">üí¨</span>
                        </div>
                    </div>
                    {% endif %}

                    <!-- Trade Type Selection -->
                    <div class="form-group">
                        <label for="trade_type">Trade Type</label>
                        <div class="input-with-icon">
                            <select name="trade_type" id="trade_type" class="form-input has-icon" required>
                                <option value="Scalp" selected>Scalp</option>
                                <option value="Swing">Swing</option>
                                <option value="Leap">Leap</option>
                            </select>
                            <span class="input-icon">üéØ</span>
                        </div>
                    </div>

                    {% if not trade_plan_only %}
                    <!-- Auto Tracking Mode -->
                    <div class="form-group">
                        <label for="position_mode">Trade Tracking</label>
                        <div class="input-with-icon">
                            <select name="position_mode" id="position_mode" class="form-input has-icon" required>
                                <option value="manual" selected>Manual updates</option>
                                <option value="auto">Automatic updates (system tracked)</option>
                            </select>
                            <span class="input-icon">ü§ñ</span>
                        </div>
                        <small style="display:block; margin-top:8px; color:#9ca3af;">
                            If you choose Automatic, you can switch to Manual any time in Position Management.
                        </small>
                    </div>
                    {% endif %}
                </div>

                <!-- Trade Details Section -->
                <div class="form-section" id="tradeDetailsSection">
                    <div class="section-header">
                        <div class="section-icon green"><img src="{% static 'signals/icons/trending_up.svg' %}" alt="" /></div>
                        <div class="section-title">Trade Details</div>
                    </div>
                    <div class="section-divider"></div>

                    <!-- Dynamic Form Fields Container -->
                    <div id="dynamicFields"></div>
                    <!-- Searchable dropdown source for US ticker symbols -->
                    <datalist id="usTickerList"></datalist>

                    <!-- Embed Display Options -->
                    <div class="sub-card">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üì± Embed Display Options</div>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div class="switch-item">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showTitleCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showTitleCheckbox">Show title</label>
                            </div>
                            <div class="switch-item" style="display: none;">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showDescriptionCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showDescriptionCheckbox">Show description</label>
                            </div>
                        </div>
                    </div>

                    <!-- Optional Fields Checkboxes -->
                    <div id="optionalFieldsSection" class="sub-card" style="display: none;">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üìã Optional Fields</div>
                        <div style="color: #888; font-size: 0.9em; margin-bottom: 15px;">Select which optional fields to include in your Discord message:</div>
                        <div id="optionalFieldsCheckboxesContainer" style="display: flex; flex-direction: column; gap: 10px;"></div>
                        <!-- Container for variables that become visible when optional fields are selected -->
                        <div id="optionalFieldsVariablesContainer" style="margin-top: 20px; display: none;">
                            <div style="color: #e0e0e0; font-size: 0.95em; margin-bottom: 12px; font-weight: 600; padding-top: 15px; border-top: 1px solid #2d2d2d;">üìù Related Variables</div>
                        </div>
                    </div>
                </div>

                

                <!-- Hidden field for data -->
                <input type="hidden" name="data" id="id_data" value="{}" />
                {% if form.data.errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.data.errors }}
                    </div>
                {% endif %}
                {% if form.non_field_errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}
            </form>
        </div>

        <!-- Live Preview Section -->
        <div style="position: sticky; top: 90px; width: 100%; z-index: 10;">
            <div class="form-section" style="margin-bottom: 0;">
                <div class="section-header" style="margin-bottom: 0;">
                    <div class="section-icon purple"><img src="{% static 'signals/icons/eye.svg' %}" alt="" /></div>
                    <div class="section-title">Live Preview</div>
                </div>
                <div class="section-divider"></div>
                <div id="discordPreview" style="max-width: 100%; margin: 0 auto;">
                    <div id="optionalFieldsControls" style="margin-bottom: 15px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; display: none;">
                        <div style="color: #dcddde; font-size: 0.85em; margin-bottom: 8px; font-weight: 600;">Optional Fields:</div>
                        <div id="optionalFieldsCheckboxes" style="display: flex; flex-direction: column; gap: 8px;"></div>
                    </div>
                    <div class="discord-embed">
                        <div class="discord-embed-color-bar" id="previewColorBar"></div>
                        <div class="discord-embed-content">
                            <div class="discord-embed-title" id="previewTitle">Select a signal type to see preview</div>
                            <div class="discord-embed-description" id="previewDescription"></div>
                            <div class="discord-embed-fields" id="previewFields"></div>
                            <div class="discord-embed-media" id="previewMedia" style="display: none;">
                                <img id="previewMediaImg" alt="" style="display: none; max-width: 100%; max-height: 300px; border-radius: 8px; object-fit: contain;" />
                                <video id="previewMediaVid" controls style="display: none; max-width: 100%; max-height: 300px; border-radius: 8px;"></video>
                            </div>
                            <div class="discord-embed-disclaimer" id="previewDisclaimer"></div>
                            <div class="discord-embed-footer" id="previewFooter"></div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px; display: flex; align-items: start; gap: 10px;">
                        <span style="color: #60a5fa; font-size: 18px;">‚ÑπÔ∏è</span>
                        <p style="color: #9ca3af; font-size: 0.85em; margin: 0; line-height: 1.5;">This is how your signal will appear in Discord. Update the form to see changes in real-time.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% if recent_signals %}
<div class="form-container" style="margin-top: 40px;">
    <div class="recent-signals">
        <h2>üìä Recent Signals</h2>
        {% for signal in recent_signals %}
        <div class="signal-card">
            <div class="signal-header">
                <span class="signal-ticker">{{ signal.data.ticker }}</span>
                <span class="signal-badge badge-{{ signal.signal_type.name|lower|slugify }}">
                    {{ signal.signal_type.name }}
                </span>
            </div>
            <div class="signal-info">
                <strong>Strike:</strong> {{ signal.data.strike }} | <strong>Expiration:</strong> {{ signal.data.expiration }}
            </div>
            {% if signal.data.extra_info %}
            <div class="signal-info">
                <strong>Extra:</strong> {{ signal.data.extra_info|truncatewords:20 }}
            </div>
            {% endif %}
            <div class="signal-time">{{ signal.created_at|date:"M d, Y H:i" }}</div>
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
{{ signal_types_data|json_script:"signal-types-data" }}
{{ trade_plan_presets|json_script:"trade-plan-presets-data" }}
<script>
// Store signal types data with full template information (Django json_script)
const signalTypesDataList = JSON.parse(document.getElementById('signal-types-data').textContent || '[]');
const signalTypesData = {};
signalTypesDataList.forEach((st) => {
    signalTypesData[String(st.id)] = st;
});

// Per-user saved Trade Plan presets (dropdown)
let tradePlanPresets = JSON.parse(document.getElementById('trade-plan-presets-data')?.textContent || '[]');
if (!Array.isArray(tradePlanPresets)) tradePlanPresets = [];

// If we just created a preset (Save As), we persist the id through reload
// so the dropdown can auto-select it after the page rerenders.
let pendingTradePlanPresetId = '';
try {
    pendingTradePlanPresetId = String(sessionStorage.getItem('ctp_selected_preset_id') || '');
} catch (_) {
    pendingTradePlanPresetId = '';
}

// Allow deep-linking to a specific preset (e.g. Saved Trade plans -> Edit)
try {
    const urlPresetId = String(new URLSearchParams(window.location.search).get('preset_id') || '').trim();
    if (urlPresetId) pendingTradePlanPresetId = urlPresetId;
} catch (_) {}

function consumePendingTradePlanPresetId() {
    const v = String(pendingTradePlanPresetId || '');
    pendingTradePlanPresetId = '';
    try { sessionStorage.removeItem('ctp_selected_preset_id'); } catch (_) {}
    return v;
}

// Debug: Log signalTypesData to console
console.log('signalTypesData loaded:', signalTypesData);
console.log('Number of signal types:', Object.keys(signalTypesData).length);

// --- CSRF helper for same-origin POSTs (Django) ---
function getCookie(name) {
    const cookies = document.cookie ? document.cookie.split(';') : [];
    for (let i = 0; i < cookies.length; i++) {
        const c = cookies[i].trim();
        if (c.startsWith(name + '=')) return decodeURIComponent(c.substring(name.length + 1));
    }
    return '';
}

function getCsrfToken() {
    return getCookie('csrftoken');
}

async function tradePlanApi(reqPayload) {
    const res = await fetch('/api/trade-plan/', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken(),
        },
        body: JSON.stringify(reqPayload || {}),
    });
    const respPayload = await res.json().catch(() => ({}));
    if (!res.ok) {
        const msg = respPayload?.error || 'Failed to save Trade Plan';
        throw new Error(msg);
    }
    return respPayload;
}

function getDefaultTradePlanPreset() {
    const d = tradePlanPresets.find(p => p && p.is_default);
    return d || tradePlanPresets[0] || null;
}

function getInitialTradePlanPreset() {
    const pendingId = consumePendingTradePlanPresetId();
    if (pendingId) {
        const p = tradePlanPresets.find(x => x && String(x.id) === String(pendingId));
        if (p) return p;
    }
    return getDefaultTradePlanPreset();
}

// Track visibility of optional fields (default: hidden)
const optionalFieldsVisibility = {};

// TA Media drag & drop (same as Post TA) ‚Äì build DOM and wire to file input
function buildTaDropDom() {
    const drop = document.createElement('div');
    drop.className = 'ta-drop';
    drop.innerHTML = '<div class="ta-drop-title">Drag &amp; drop a file here</div><div class="ta-drop-sub">or click to browse (images/videos)</div><div class="ta-drop-file" style="display:none;"><span class="ta-drop-file-name"></span><button type="button" class="ta-drop-clear">Remove</button></div><div class="ta-drop-preview"><img alt="" style="display:none;" /><video controls style="display:none;"></video></div>';
    return drop;
}

function wireTaDropForInput(mediaInput, dropEl, onChange) {
    if (!mediaInput || !dropEl) return;
    const fileRow = dropEl.querySelector('.ta-drop-file');
    const fileNameSpan = dropEl.querySelector('.ta-drop-file-name');
    const clearBtn = dropEl.querySelector('.ta-drop-clear');
    const previewEl = dropEl.querySelector('.ta-drop-preview');
    const imgEl = dropEl.querySelector('.ta-drop-preview img');
    const vidEl = dropEl.querySelector('.ta-drop-preview video');
    let lastObjectUrl = null;

    function fmtBytes(n) {
        const v = Number(n || 0);
        if (!v) return '0B';
        const u = ['B','KB','MB','GB'];
        const i = Math.min(u.length - 1, Math.floor(Math.log(v) / Math.log(1024)));
        return (v / Math.pow(1024, i)).toFixed(i === 0 ? 0 : 2) + u[i];
    }

    function updatePreview() {
        const file = mediaInput.files && mediaInput.files[0] ? mediaInput.files[0] : null;
        if (imgEl) imgEl.style.display = 'none';
        if (vidEl) vidEl.style.display = 'none';
        if (previewEl) previewEl.style.display = 'none';
        if (imgEl) imgEl.removeAttribute('src');
        if (vidEl) vidEl.removeAttribute('src');
        if (lastObjectUrl) { try { URL.revokeObjectURL(lastObjectUrl); } catch (_) {} lastObjectUrl = null; }
        if (!file) { if (typeof onChange === 'function') onChange(); return; }
        const url = URL.createObjectURL(file);
        lastObjectUrl = url;
        const type = (file.type || '').toLowerCase();
        if (type.startsWith('image/')) {
            imgEl.src = url; imgEl.style.display = ''; previewEl.style.display = 'block';
        } else if (type.startsWith('video/')) {
            vidEl.src = url; vidEl.style.display = ''; previewEl.style.display = 'block';
        }
        if (typeof onChange === 'function') onChange();
    }

    function setFile(file) {
        if (!file) {
            try { mediaInput.value = ''; } catch (_) {}
            if (fileRow) fileRow.style.display = 'none';
            if (fileNameSpan) fileNameSpan.textContent = '';
            if (previewEl) previewEl.style.display = 'none';
            if (imgEl) { imgEl.style.display = 'none'; imgEl.removeAttribute('src'); }
            if (vidEl) { vidEl.style.display = 'none'; vidEl.removeAttribute('src'); }
            if (lastObjectUrl) { try { URL.revokeObjectURL(lastObjectUrl); } catch (_) {} lastObjectUrl = null; }
            if (typeof onChange === 'function') onChange();
            return;
        }
        try {
            const dt = new DataTransfer();
            dt.items.add(file);
            mediaInput.files = dt.files;
        } catch (e) { console.warn('Could not set file programmatically:', e); }
        if (fileNameSpan) fileNameSpan.textContent = file.name + ' (' + fmtBytes(file.size) + ')';
        if (fileRow) fileRow.style.display = '';
        updatePreview();
    }

    function accepts(file) {
        const t = (file && file.type) ? String(file.type) : '';
        return t.startsWith('image/') || t.startsWith('video/');
    }

    dropEl.addEventListener('click', (e) => { if (!e.target.closest('.ta-drop-clear')) mediaInput.click(); });
    dropEl.addEventListener('dragover', (e) => { e.preventDefault(); dropEl.classList.add('dragover'); });
    dropEl.addEventListener('dragleave', () => dropEl.classList.remove('dragover'));
    dropEl.addEventListener('drop', (e) => {
        e.preventDefault();
        dropEl.classList.remove('dragover');
        const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0] ? e.dataTransfer.files[0] : null;
        if (!f) return;
        if (!accepts(f)) { alert('Please drop an image or video file.'); return; }
        setFile(f);
    });
    if (clearBtn) clearBtn.addEventListener('click', (e) => { e.stopPropagation(); setFile(null); });
    mediaInput.addEventListener('change', () => {
        const f = mediaInput.files && mediaInput.files[0] ? mediaInput.files[0] : null;
        if (f) {
            if (fileNameSpan) fileNameSpan.textContent = f.name + ' (' + fmtBytes(f.size) + ')';
            if (fileRow) fileRow.style.display = '';
        } else {
            if (fileRow) fileRow.style.display = 'none';
            if (fileNameSpan) fileNameSpan.textContent = '';
        }
        updatePreview();
    });
    mediaInput.style.display = 'none';
    updatePreview();
}

// Cached US ticker list for searchable dropdowns (datalist)
let usTickersLoaded = false;
let usTickersLoadingPromise = null;

function ensureUsTickersLoaded() {
    if (usTickersLoaded) return Promise.resolve(true);
    if (usTickersLoadingPromise) return usTickersLoadingPromise;

    const listEl = document.getElementById('usTickerList');
    if (!listEl) {
        usTickersLoaded = true;
        return Promise.resolve(false);
    }

    usTickersLoadingPromise = fetch('/api/us-tickers/', { credentials: 'same-origin' })
        .then((res) => res.ok ? res.json() : Promise.reject(new Error('Failed to load tickers')))
        .then((payload) => {
            const tickers = Array.isArray(payload?.tickers) ? payload.tickers : [];
            // Populate datalist with <option value="AAPL">Apple Inc.</option>
            listEl.innerHTML = '';
            tickers.forEach((t) => {
                const sym = String(t?.symbol || '').trim().toUpperCase();
                if (!sym) return;
                const opt = document.createElement('option');
                opt.value = sym;
                const name = String(t?.name || '').trim();
                if (name) opt.label = name;
                listEl.appendChild(opt);
            });
            usTickersLoaded = true;
            return true;
        })
        .catch((e) => {
            console.warn('Ticker list load failed:', e);
            usTickersLoaded = true; // Don't keep retrying aggressively
            return false;
        });

    return usTickersLoadingPromise;
}

// --- Ticker search (typeahead) ---
function debounce(fn, waitMs) {
    let t = null;
    return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), waitMs);
    };
}

function getTodayISODate() {
    // YYYY-MM-DD in local time
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

/** Return YYYY-MM-DD for a date + N days */
function addDaysISODate(isoDate, days) {
    const d = new Date(isoDate + 'T12:00:00');
    d.setDate(d.getDate() + days);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

/** Return YYYY-MM-DD for a date + N months */
function addMonthsISODate(isoDate, months) {
    const d = new Date(isoDate + 'T12:00:00');
    d.setMonth(d.getMonth() + months);
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

/** Normalize to YYYY-MM-DD (accepts YYYY-MM-DD or MM/DD/YYYY or similar) */
function normalizeToISODate(val) {
    const s = String(val || '').trim();
    if (!s) return '';
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/) || s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
    if (m) {
        if (m[1].length === 4) return `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
        return `${m[3]}-${m[1].padStart(2, '0')}-${m[2].padStart(2, '0')}`;
    }
    return s;
}

/** Default Time Horizon date: options = expiration date; stock + Leap = 6 months; stock + Swing = 1 week */
function getDefaultTimeHorizonDate() {
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    const tradeType = getSelectedTradeType();
    const today = getTodayISODate();
    if (!isShares) {
        const expEl = findFieldByName('expiration');
        const expRaw = expEl ? String(expEl.value || '').trim() : '';
        const expIso = normalizeToISODate(expRaw);
        return expIso || today;
    }
    if (tradeType === 'leap') return addMonthsISODate(today, 6);
    if (tradeType === 'swing') return addDaysISODate(today, 7);
    return today;
}

/** Set Time Horizon input to default (expiration for options; 1 week for Swing, 6 months for Leap for stock) */
function setTimeHorizonDefault() {
    const el = document.getElementById('id_time_horizon');
    if (!el || el.type !== 'date') return;
    const defaultDate = getDefaultTimeHorizonDate();
    if (defaultDate) {
        el.value = defaultDate;
        const min = getTodayISODate();
        if (el.min !== min) el.min = min;
        if (typeof updatePreview === 'function') updatePreview();
    }
}

function autoResizeTextarea(textarea) {
    if (!textarea) return;
    // Grow/shrink based on content; prevent inner scrollbars. Don't shrink below ~3 lines (show full hint).
    const minLines = Math.max(textarea.rows || 3, 3);
    const lineHeight = 24;
    const minHeight = minLines * lineHeight;
    textarea.style.height = 'auto';
    textarea.style.overflowY = 'hidden';
    const h = Math.max(textarea.scrollHeight, minHeight);
    textarea.style.height = `${h}px`;
}

function wireAutoResizeTextareas(root = document) {
    const textareas = root.querySelectorAll ? root.querySelectorAll('textarea.form-textarea') : [];
    textareas.forEach((ta) => {
        // Avoid attaching multiple times
        if (ta.dataset.autosizeWired === '1') return;
        ta.dataset.autosizeWired = '1';
        ta.style.resize = 'none';
        ta.style.overflowY = 'hidden';
        ta.addEventListener('input', () => autoResizeTextarea(ta));
        // Initial sizing
        setTimeout(() => autoResizeTextarea(ta), 0);
    });
}

// Cache last fetched metadata per symbol so live preview can show company_name/stock_price
const tickerMetaCache = {};

async function fetchTickerSearch(query, { limit = 40, signal } = {}) {
    const q = String(query || '').trim();
    const url = `/api/us-tickers/?source=tradingview&q=${encodeURIComponent(q)}&limit=${encodeURIComponent(String(limit || 40))}`;
    const res = await fetch(url, { credentials: 'same-origin', signal });
    if (!res.ok) throw new Error('Failed to search tickers');
    const payload = await res.json();
    const tickers = Array.isArray(payload?.tickers) ? payload.tickers : [];
    return tickers
        .map(t => ({
            symbol: String(t?.symbol || '').trim().toUpperCase(),
            name: String(t?.name || '').trim()
        }))
        .filter(t => t.symbol);
}

function createTickerSearchControl(variable) {
    const wrap = document.createElement('div');
    wrap.className = 'ticker-search';

    const input = document.createElement('input');
    input.className = 'form-input';
    input.type = 'text';
    input.autocomplete = 'off';
    input.spellcheck = false;
    input.placeholder = variable.hint || 'Search ticker (e.g., AAPL, TSLA)';

    const dropdown = document.createElement('div');
    dropdown.className = 'ticker-search-dropdown';

    wrap.appendChild(input);
    wrap.appendChild(dropdown);

    let activeIndex = -1;
    let currentItems = [];
    let abortController = null;
    let suppressSearch = false;

    function closeDropdown() {
        dropdown.classList.remove('open');
        activeIndex = -1;
    }

    function openDropdown() {
        dropdown.classList.add('open');
    }

    function renderItems(items, { loading = false } = {}) {
        dropdown.innerHTML = '';
        currentItems = items;
        activeIndex = -1;

        if (loading) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = 'Searching...';
            dropdown.appendChild(empty);
            openDropdown();
            return;
        }

        if (!items || items.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = input.value.trim() ? 'No matches.' : 'Start typing to search tickers.';
            dropdown.appendChild(empty);
            openDropdown();
            return;
        }

        items.forEach((t, idx) => {
            const row = document.createElement('div');
            row.className = 'ticker-search-item';
            row.setAttribute('role', 'option');
            row.dataset.index = String(idx);

            const sym = document.createElement('div');
            sym.className = 'ticker-search-symbol';
            sym.textContent = t.symbol;

            const name = document.createElement('div');
            name.className = 'ticker-search-name';
            name.textContent = t.name || '';

            row.appendChild(sym);
            row.appendChild(name);

            const selectItem = (e) => {
                // Prevent blur-before-select on some browsers.
                if (e && typeof e.preventDefault === 'function') e.preventDefault();
                if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
                // Guard: some browsers fire multiple pointer/mouse/click events.
                if (row.dataset.selected === '1') return;
                row.dataset.selected = '1';
                suppressSearch = true;
                input.value = t.symbol;
                closeDropdown();
                // Trigger preview + hidden JSON update paths without re-opening the dropdown search.
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                // Drop focus to make it feel like a "selection".
                try { input.blur(); } catch (_) {}
                // Re-enable searching after this tick.
                setTimeout(() => { suppressSearch = false; }, 0);
            };

            // Use pointerdown only (avoid duplicate selection events)
            row.addEventListener('pointerdown', selectItem);

            dropdown.appendChild(row);
        });

        openDropdown();
    }

    const doSearch = debounce(async () => {
        const q = input.value.trim();
        if (abortController) abortController.abort();
        abortController = new AbortController();
        renderItems([], { loading: true });
        try {
            const items = await fetchTickerSearch(q, { limit: 40, signal: abortController.signal });
            renderItems(items);
        } catch (e) {
            if (String(e?.name) === 'AbortError') return;
            console.warn('Ticker search failed:', e);
            renderItems([]);
        }
    }, 140);

    input.addEventListener('focus', () => {
        // Show suggestions box (empty state) immediately.
        renderItems(currentItems || []);
    });

    input.addEventListener('blur', () => {
        // Allow click selection first.
        setTimeout(() => closeDropdown(), 120);
    });

    input.addEventListener('input', () => {
        if (suppressSearch) return;
        doSearch();
    });

    input.addEventListener('keydown', (e) => {
        if (!dropdown.classList.contains('open')) return;
        const items = Array.from(dropdown.querySelectorAll('.ticker-search-item'));
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIndex = Math.min(activeIndex + 1, items.length - 1);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIndex = Math.max(activeIndex - 1, 0);
        } else if (e.key === 'Enter') {
            if (activeIndex >= 0 && currentItems[activeIndex]) {
                e.preventDefault();
                suppressSearch = true;
                input.value = currentItems[activeIndex].symbol;
                closeDropdown();
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                try { input.blur(); } catch (_) {}
                setTimeout(() => { suppressSearch = false; }, 0);
            }
            return;
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDropdown();
            return;
        } else {
            return;
        }

        items.forEach((el, idx) => el.classList.toggle('active', idx === activeIndex));
        const activeEl = items[activeIndex];
        if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
    });

    return { wrap, input };
}

function createSelectDropdownControlFromSelect(selectEl, { placeholder = '' } = {}) {
    const wrap = document.createElement('div');
    wrap.className = 'ticker-search';

    const input = document.createElement('input');
    input.className = 'form-input';
    input.type = 'text';
    input.autocomplete = 'off';
    input.spellcheck = false;
    input.placeholder = placeholder || 'Select...';
    input.dataset.ignoreDynamic = '1'; // Important: don't include in signalData JSON

    const dropdown = document.createElement('div');
    dropdown.className = 'ticker-search-dropdown';

    wrap.appendChild(input);
    wrap.appendChild(dropdown);

    let options = Array.from(selectEl.options || []).map(o => ({
        value: String(o.value),
        label: String(o.textContent || '').trim(),
        disabled: !!o.disabled,
    }));

    function refreshOptionsFromSelect() {
        options = Array.from(selectEl.options || []).map(o => ({
            value: String(o.value),
            label: String(o.textContent || '').trim(),
            disabled: !!o.disabled,
        }));
        syncFromSelect();
    }

    let activeIndex = -1;
    let currentItems = [];

    function closeDropdown() {
        dropdown.classList.remove('open');
        activeIndex = -1;
    }

    function openDropdown() {
        dropdown.classList.add('open');
    }

    function renderItems(items) {
        dropdown.innerHTML = '';
        currentItems = items;
        activeIndex = -1;

        if (!items.length) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = 'No results';
            dropdown.appendChild(empty);
            return;
        }

        items.forEach((it, idx) => {
            const row = document.createElement('div');
            row.className = 'ticker-search-item';
            row.dataset.index = String(idx);

            const left = document.createElement('div');
            left.className = 'ticker-search-symbol';
            left.textContent = it.label || it.value;

            row.appendChild(left);

            if (it.disabled) {
                row.style.opacity = '0.6';
                row.style.pointerEvents = 'none';
            } else {
                row.addEventListener('mousedown', (e) => {
                    // Use mousedown to beat blur
                    e.preventDefault();
                    selectEl.value = it.value;
                    input.value = it.label || it.value;
                    selectEl.dispatchEvent(new Event('input', { bubbles: true }));
                    selectEl.dispatchEvent(new Event('change', { bubbles: true }));
                    closeDropdown();
                    // Drop focus so next click/focus re-opens as expected
                    try { input.blur(); } catch (_) {}
                });
            }

            dropdown.appendChild(row);
        });
    }

    function syncFromSelect() {
        const selOpt = selectEl.options[selectEl.selectedIndex];
        const label = selOpt ? String(selOpt.textContent || '').trim() : '';
        input.value = label || String(selectEl.value || '');
    }

    function filteredOptions(query) {
        const q = String(query || '').trim().toLowerCase();
        if (!q) return options.filter(o => o.value !== '');
        return options.filter(o => (o.label || o.value).toLowerCase().includes(q));
    }

    input.addEventListener('focus', () => {
        if (selectEl.disabled) return;
        // Show all options on open (unlike ticker search). Filter only after typing.
        renderItems(options.filter(o => o.value !== ''));
        openDropdown();
    });

    input.addEventListener('input', () => {
        if (selectEl.disabled) return;
        renderItems(filteredOptions(input.value));
        openDropdown();
    });

    input.addEventListener('keydown', (e) => {
        if (!dropdown.classList.contains('open')) {
            if (e.key === 'ArrowDown' || e.key === 'Enter') {
                e.preventDefault();
                // Show all options on open; user can type to filter afterwards.
                renderItems(options.filter(o => o.value !== ''));
                openDropdown();
            }
            return;
        }

        const items = Array.from(dropdown.querySelectorAll('.ticker-search-item'));
        if (!items.length) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIndex = Math.min(activeIndex + 1, items.length - 1);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIndex = Math.max(activeIndex - 1, 0);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            const it = currentItems[activeIndex];
            if (it && !it.disabled) {
                selectEl.value = it.value;
                input.value = it.label || it.value;
                selectEl.dispatchEvent(new Event('input', { bubbles: true }));
                selectEl.dispatchEvent(new Event('change', { bubbles: true }));
                closeDropdown();
                try { input.blur(); } catch (_) {}
            }
            return;
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDropdown();
            return;
        } else {
            return;
        }

        items.forEach((el, idx) => el.classList.toggle('active', idx === activeIndex));
        const activeEl = items[activeIndex];
        if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
    });

    input.addEventListener('blur', () => {
        // Small delay so click can register
        setTimeout(() => closeDropdown(), 120);
    });

    // Mirror select state (in case code updates it)
    selectEl.addEventListener('change', syncFromSelect);

    // Init
    syncFromSelect();

    // Disabled?
    if (selectEl.disabled) {
        input.disabled = true;
    }

    return { wrap, input, refreshOptionsFromSelect };
}

function upgradeSelectToTickerDropdown(selectEl, { placeholder = '' } = {}) {
    if (!selectEl || selectEl.dataset.upgradedDropdown === '1') return null;
    selectEl.dataset.upgradedDropdown = '1';

    const control = createSelectDropdownControlFromSelect(selectEl, { placeholder });
    if (control && control.refreshOptionsFromSelect) {
        selectEl._refreshDropdownOptions = control.refreshOptionsFromSelect;
    }
    // Hide original select but keep it for form submission.
    selectEl.style.display = 'none';
    selectEl.insertAdjacentElement('afterend', control.wrap);
    return control;
}

// Auto-fill helpers (avoid overwriting user edits)
function markUserTouched(el) {
    if (!el) return;
    // Ignore programmatic updates (set by setValueIfAllowed/forceSet) so auto-fill can continue
    // to adjust values when upstream inputs (e.g., current_price) change.
    if (el.dataset && el.dataset.suppressUserTouched === '1') {
        delete el.dataset.suppressUserTouched;
        return;
    }
    el.dataset.userTouched = '1';
    if (el.dataset.autoFilled === '1') el.dataset.autoFilled = '0';
}

function canAutoFill(el) {
    if (!el) return false;
    return el.dataset.userTouched !== '1';
}

function setValueIfAllowed(el, value) {
    if (!el) return false;
    const v = (value === null || value === undefined) ? '' : String(value);
    const isEmpty = !String(el.value || '').trim();
    const wasAuto = el.dataset.autoFilled === '1';
    if (!canAutoFill(el)) return false;
    if (!isEmpty && !wasAuto) return false;

    el.value = v;
    el.dataset.autoFilled = '1';
    // Prevent the generic "input => markUserTouched" listeners from marking this as user-edited.
    el.dataset.suppressUserTouched = '1';
    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
    // If a listener didn't clear it, clear it now.
    if (el.dataset.suppressUserTouched === '1') delete el.dataset.suppressUserTouched;
    return true;
}

function formatFloat3(value) {
    if (value === null || value === undefined) return '';
    const n = Number(value);
    if (!Number.isFinite(n)) return String(value);
    return n.toFixed(2);
}

function parsePercent(value) {
    const s = String(value ?? '').trim();
    if (!s) return NaN;
    const cleaned = s.endsWith('%') ? s.slice(0, -1) : s;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : NaN;
}

const MAX_TP_LEVELS = 6;

function updateTpSlPrices() {
    // Take Profit Price: stock-based when is_shares on, option-based when is_shares off
    const isShares = (findFieldByName('is_shares') && findFieldByName('is_shares').checked) || false;
    const currentPriceEl = findFieldByName('current_price');
    const optionPriceEl = findFieldByName('option_price');
    const entryPriceEl = findFieldByName('entry_price');
    const priceEl = findFieldByName('price');
    let baseRaw = isShares
        ? ((currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '')
        : ((optionPriceEl && optionPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '');
    // When is_shares on: fall back to ticker quote cache so Price updates from stock price after quote fetch
    if (isShares && (!baseRaw || !String(baseRaw).trim())) {
        const sym = getCurrentTickerSymbol();
        const cached = sym ? tickerMetaCache[sym] : null;
        if (cached && cached.price != null) baseRaw = String(cached.price);
    }
    const base = Number(String(baseRaw).trim());
    if (!Number.isFinite(base) || base <= 0) return;

    const slPer = parsePercent(findFieldByName('sl_per')?.value);

    const slPriceEl = findFieldByName('sl_price');

    const optTypeEl = findFieldByName('option_type');
    const optTypeRaw = String(optTypeEl ? optTypeEl.value : '').trim().toLowerCase();
    const isSell = isShares && optTypeRaw.includes('put');

    for (let i = 1; i <= MAX_TP_LEVELS; i++) {
        const modeEl = findFieldByName(`tp${i}_mode`);
        const mode = String(modeEl ? modeEl.value : '').trim().toLowerCase();
        // If TP is defined as an underlying stock price target, don't compute option tp_price.
        if (mode === 'stock' || mode === 'stock_price' || mode === 'underlying' || mode === 'share_price') {
            continue;
        }
        const perEl = findFieldByName(`tp${i}_per`);
        const priceElN = findFieldByName(`tp${i}_price`);
        if (!perEl || !priceElN) continue;
        const tpPer = parsePercent(perEl.value);
        if (Number.isFinite(tpPer)) {
            const computed = isSell
                ? formatFloat3(base * (1 - Math.abs(tpPer) / 100))
                : formatFloat3(base * (1 + tpPer / 100));
            setValueIfAllowed(priceElN, computed);
            const priceDisplayEl = document.querySelector(`input[data-tp-price-display][data-tp-level="${i}"]`);
            if (priceDisplayEl) {
                // Always sync Price display to computed value (stock when is_shares on, option when off)
                priceDisplayEl.value = String(computed);
                priceDisplayEl.dataset.autoFilled = '1';
            }
        }
    }
    if (Number.isFinite(slPer)) {
        const slPrice = isSell ? base * (1 + slPer / 100) : base * (1 - slPer / 100);
        setValueIfAllowed(slPriceEl, formatFloat3(slPrice));
        // Also update visible price field if it exists
        const slPriceVisibleEl = findFieldByName('sl_price_visible');
        if (slPriceVisibleEl && (!slPriceVisibleEl.dataset.userTouched)) {
            slPriceVisibleEl.value = formatFloat3(slPrice);
        }
    }

    updateRaiseSlPricesFromPercent(base, isSell);
}

function updateRaiseSlPricesFromPercent(base, isSell) {
    if (!Number.isFinite(base) || base <= 0) return;
    const rows = document.querySelectorAll('.tp-level-row[data-tp-row="1"]');
    rows.forEach(function(r) {
        const raiseSlSelect = r.querySelector('[data-tp-raise-sl-to]');
        if (!raiseSlSelect || raiseSlSelect.value !== 'custom') return;
        const percentWrap = r.querySelector('[data-tp-raise-sl-percent-wrap]');
        if (!percentWrap || percentWrap.style.display === 'none') return;
        const perInput = r.querySelector('[data-tp-raise-sl-custom-per]');
        const priceInput = r.querySelector('[data-tp-raise-sl-custom]');
        if (!perInput || !priceInput) return;
        const perStr = String(perInput.value || '').trim().replace('%', '');
        const per = Number(perStr);
        if (!Number.isFinite(per)) return;
        const p = base * (1 + (isSell ? -Math.abs(per) : per) / 100);
        priceInput.value = String(typeof formatFloat3 === 'function' ? formatFloat3(p) : p.toFixed(2));
        priceInput.dataset.autoFilled = '1';
    });
}

// When Target Type = Stock price ($), default TP stock targets to +10/20/30/40/50/60%
// of the current underlying stock price (without overwriting user edits).
// Base: when is_shares on use same resolution as updateTpSlPrices (current_price/entry/price/cache);
// when is_shares off (options) use underlying from ticker cache first.
// If we have a ticker but no base yet, fetch quote and recalculate.
function updateDefaultTpStockTargets() {
    const modeEl = findFieldByName('tp1_mode');
    const mode = String(modeEl ? modeEl.value : '').trim().toLowerCase();
    const isStock = mode === 'stock' || mode === 'stock_price' || mode === 'underlying' || mode === 'share_price';
    if (!isStock) return;

    const isShares = (findFieldByName('is_shares') && findFieldByName('is_shares').checked) || false;
    const currentPriceEl = findFieldByName('current_price');
    const entryPriceEl = findFieldByName('entry_price');
    const priceEl = findFieldByName('price');
    const sym = getCurrentTickerSymbol();
    const cached = sym ? tickerMetaCache[sym] : null;

    let baseRaw;
    if (isShares) {
        baseRaw = (currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '';
        if (!baseRaw || !String(baseRaw).trim()) {
            if (cached && cached.price != null) baseRaw = String(cached.price);
        }
    } else {
        baseRaw = (cached && cached.price != null ? String(cached.price) : '') ||
            (currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '';
    }
    let base = Number(String(baseRaw).trim());

    // If we have a ticker but no valid base, fetch quote and recalculate so Stock price targets aren't stuck at 0.00
    if ((!Number.isFinite(base) || base <= 0) && sym) {
        fetchQuote(sym).then(function(quote) {
            if (quote && quote.price != null) {
                tickerMetaCache[sym] = { price: quote.price, company_name: quote.company_name || '' };
                const priceStr = Number(quote.price).toFixed(2);
                if (currentPriceEl) setValueIfAllowed(currentPriceEl, priceStr);
                if (entryPriceEl) setValueIfAllowed(entryPriceEl, priceStr);
                if (priceEl) setValueIfAllowed(priceEl, priceStr);
                updateDefaultTpStockTargets();
                updateTpSlPrices();
                if (typeof updatePreview === 'function') updatePreview();
            }
        });
        return;
    }
    if (!Number.isFinite(base) || base < 0) return;

    // BUY (CALL) = +10/+20/... %, SELL (PUT) = -10/-20/... %
    const optTypeEl = findFieldByName('option_type');
    const optTypeRaw = String(optTypeEl ? optTypeEl.value : '').trim().toLowerCase();
    const isPut = optTypeRaw.includes('put');
    const dir = isPut ? -1 : 1;

    const defaults = [10, 20, 30, 40, 50, 60];
    for (let i = 1; i <= defaults.length; i++) {
        const el = findFieldByName(`tp${i}_stock_price`);
        if (!el) continue;
        const target = base * (1 + dir * defaults[i - 1] / 100);
        setValueIfAllowed(el, target.toFixed(2));
    }
}

// When is_shares is on: set TP level % direction from Buy or Sell (CALL = +10/+20/..., PUT = -10/-20/...)
// force: when true (e.g. user changed Buy/Sell), always set; when false, only set if allowed (auto-filled or empty)
function applyTpLevelDirectionForShares(force) {
    const isSharesCheckbox = document.getElementById('id_is_shares');
    if (!isSharesCheckbox || !isSharesCheckbox.checked) return;
    const optTypeEl = findFieldByName('option_type');
    const optTypeRaw = String(optTypeEl ? optTypeEl.value : '').trim().toLowerCase();
    const isPut = optTypeRaw.includes('put');
    const dir = isPut ? -1 : 1;
    const defaults = [10, 20, 30, 40, 50, 60];
    for (let i = 1; i <= defaults.length; i++) {
        const el = findFieldByName(`tp${i}_per`);
        if (!el) continue;
        const val = dir * defaults[i - 1];
        el.setAttribute('min', isPut ? '-100' : '0');
        if (force) {
            el.value = String(val);
            el.dataset.autoFilled = '1';
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
            setValueIfAllowed(el, String(val));
        }
    }
    updateTpSlPrices();
    updatePreview();
}

function findFieldByName(name) {
    return document.querySelector(`#dynamicFields [name="${CSS.escape(name)}"], #optionalFieldsVariablesContainer [name="${CSS.escape(name)}"]`);
}

function getCurrentTickerSymbol() {
    const el = findFieldByName('ticker') || findFieldByName('symbol');
    const v = el ? String(el.value || '').trim().toUpperCase() : '';
    return v;
}

async function fetchQuote(symbol) {
    const sym = String(symbol || '').trim().toUpperCase();
    if (!sym) return null;
    const res = await fetch(`/api/quote/?symbol=${encodeURIComponent(sym)}`, { credentials: 'same-origin' });
    if (!res.ok) return null;
    const payload = await res.json();
    return payload && payload.price != null ? payload : null;
}

async function fetchOptionQuote(symbol, { strike, expiration, side } = {}) {
    const sym = String(symbol || '').trim().toUpperCase();
    const exp = String(expiration || '').trim();
    const s = String(side || '').trim().toLowerCase();
    const k = strike;
    if (!sym || !exp || !k || !['call','put'].includes(s)) return null;
    const url = `/api/option-quote/?symbol=${encodeURIComponent(sym)}&expiration=${encodeURIComponent(exp)}&strike=${encodeURIComponent(String(k))}&side=${encodeURIComponent(s)}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) {
        // Best-effort debug info (shows up in browser console)
        try {
            const errPayload = await res.json();
            console.warn('Option quote failed:', res.status, errPayload);
        } catch (_) {
            console.warn('Option quote failed:', res.status);
        }
        return null;
    }
    const payload = await res.json();
    return payload && payload.price != null ? payload : null;
}

function getSelectedTradeType() {
    const el = document.getElementById('trade_type');
    return String(el ? el.value : '').trim().toLowerCase() || 'swing';
}

/** Show Time Horizon field only for Swing and Leap; hide for Scalp. When showing, set default date. */
function updateTimeHorizonVisibility() {
    const tradeType = getSelectedTradeType();
    const show = tradeType === 'swing' || tradeType === 'leap';
    document.querySelectorAll('[data-show-for-trade-type="swing,leap"]').forEach(function (el) {
        el.style.display = show ? '' : 'none';
    });
    if (show && typeof setTimeHorizonDefault === 'function') setTimeHorizonDefault();
}

async function fetchBestOption(symbol, { tradeType, side } = {}) {
    const sym = String(symbol || '').trim().toUpperCase();
    const tt = String(tradeType || '').trim().toLowerCase() || 'swing';
    const s = String(side || '').trim().toLowerCase() || 'call';
    if (!sym || !['call','put'].includes(s)) return null;
    const url = `/api/best-option/?symbol=${encodeURIComponent(sym)}&trade_type=${encodeURIComponent(tt)}&side=${encodeURIComponent(s)}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) {
        try {
            const errPayload = await res.json();
            console.warn('Best option failed:', res.status, errPayload);
        } catch (_) {
            console.warn('Best option failed:', res.status);
        }
        return null;
    }
    return await res.json();
}

async function maybeAutoPickBestOption() {
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    if (isShares) return;

    const sym = getCurrentTickerSymbol();
    if (!sym) return;

    const optTypeEl = findFieldByName('option_type');
    const raw = optTypeEl ? String(optTypeEl.value || '').trim().toLowerCase() : '';
    const side = raw.includes('put') ? 'put' : (raw.includes('call') ? 'call' : 'call');
    const tradeType = getSelectedTradeType();

    const best = await fetchBestOption(sym, { tradeType, side });
    if (!best || best.error) return;

    const strikeEl = findFieldByName('strike');
    const expEl = findFieldByName('expiration');
    const optionPriceEl = findFieldByName('option_price');
    const entryPriceEl = findFieldByName('entry_price');
    const priceEl = findFieldByName('price');
    const contractEl = findFieldByName('option_contract');

    setValueIfAllowed(strikeEl, best.strike);
    setValueIfAllowed(expEl, best.expiration);
    setValueIfAllowed(optionPriceEl, formatFloat3(best.option_price));
    setValueIfAllowed(entryPriceEl, formatFloat3(best.option_price));
    setValueIfAllowed(priceEl, formatFloat3(best.option_price));
    setValueIfAllowed(contractEl, best.contract);

    if (typeof setTimeHorizonDefault === 'function') setTimeHorizonDefault();
    updateTpSlPrices();
    updatePreview();
}

// Refresh stock and option prices for live preview (called on an interval)
const PREVIEW_REFRESH_INTERVAL_MS = 10000; // 10 seconds
async function refreshPreviewPrices() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) return;
    const sym = getCurrentTickerSymbol();
    if (!sym) return;

    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;

    const quote = await fetchQuote(sym);
    if (quote) {
        tickerMetaCache[sym] = {
            price: quote.price,
            company_name: quote.company_name || '',
        };
    }

    if (isShares) {
        if (quote) {
            const currentPriceEl = findFieldByName('current_price');
            const entryPriceEl = findFieldByName('entry_price');
            const priceEl = findFieldByName('price');
            const companyNameEl = findFieldByName('company_name');
            setValueIfAllowed(currentPriceEl, formatFloat3(quote.price));
            setValueIfAllowed(entryPriceEl, formatFloat3(quote.price));
            setValueIfAllowed(priceEl, formatFloat3(quote.price));
            if (companyNameEl) setValueIfAllowed(companyNameEl, quote.company_name || '');
            updateDefaultTpStockTargets();
        }
        updatePreview();
        return;
    }

    // Options mode: refresh option quote when we have strike, expiration, option_type
    const strikeEl = findFieldByName('strike');
    const expEl = findFieldByName('expiration');
    const optTypeEl = findFieldByName('option_type');
    const strike = strikeEl ? String(strikeEl.value || '').trim() : '';
    const expiration = expEl ? String(expEl.value || '').trim() : '';
    const optTypeRaw = optTypeEl ? String(optTypeEl.value || '').trim().toLowerCase() : '';
    const side = optTypeRaw.includes('put') ? 'put' : 'call';

    if (strike && expiration) {
        const optQuote = await fetchOptionQuote(sym, { strike, expiration, side });
        if (optQuote && optQuote.price != null) {
            const optionPriceEl = findFieldByName('option_price');
            const entryPriceEl = findFieldByName('entry_price');
            const priceEl = findFieldByName('price');
            setValueIfAllowed(optionPriceEl, formatFloat3(optQuote.price));
            setValueIfAllowed(entryPriceEl, formatFloat3(optQuote.price));
            setValueIfAllowed(priceEl, formatFloat3(optQuote.price));
            updateTpSlPrices();
        }
    }
    updatePreview();
}

// Map variable types to input field types
function getInputType(variableType) {
    const typeMap = {
        'string': 'text',
        'number': 'number',
        'float': 'number',
        'date': 'date',
        'text': 'textarea',
        'boolean': 'checkbox',
        'ticker_type': 'text',
        'file': 'file'
    };
    return typeMap[variableType] || 'text';
}

// Treat optional flags robustly (boolean true vs string "true")
function isTruthyOptionalFlag(value) {
    return value === true || value === 'true' || value === 1 || value === '1';
}

function isOptionalField(field) {
    return field && isTruthyOptionalFlag(field.optional);
}

function getNonRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        // v is typically an object: {name, required, ...}
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        // Treat missing required as false (non-required)
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required !== true) set.add(String(name));
    });
    return set;
}

function getRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required === true) set.add(String(name));
    });
    return set;
}

function getFieldReferencedVariables(field) {
    const vars = new Set();
    extractVariablesFromTemplate(field?.name || '').forEach(v => vars.add(v));
    extractVariablesFromTemplate(field?.value || '').forEach(v => vars.add(v));
    return vars;
}

function fieldReferencesAnyRequiredVariable(field, signalType) {
    const required = getRequiredVariableSet(signalType);
    if (required.size === 0) return false;
    const vars = getFieldReferencedVariables(field);
    for (const v of vars) {
        if (required.has(v)) return true;
    }
    return false;
}

function isInferredOptionalField(field, signalType) {
    if (!field || !signalType) return false;
    const nonRequired = getNonRequiredVariableSet(signalType);
    if (nonRequired.size === 0) return false;

    const vars = getFieldReferencedVariables(field);

    // Only infer optional if the field actually depends on variables,
    // and ALL referenced variables are non-required (so required info isn't hideable).
    if (vars.size === 0) return false;
    for (const v of vars) {
        if (!nonRequired.has(v)) return false;
    }
    return true;
}

function isOptionalFieldForSignalType(field, signalType) {
    // Guardrail: required-variable fields should never be hideable
    if (fieldReferencesAnyRequiredVariable(field, signalType)) return false;

    // Honor explicit optional OR inferred optional (non-required variables only)
    return isOptionalField(field) || isInferredOptionalField(field, signalType);
}

// Get label from variable or fall back to default (option_type shown as Buy or Sell only when is_shares is on; see toggleOptionFields)
function getLabel(variable) {
    if (variable && variable.label) {
        return variable.label;
    }
    const name = variable && variable.name ? variable.name : (typeof variable === 'string' ? variable : '');
    return String(name || variable).charAt(0).toUpperCase() + String(name || variable).slice(1).replace(/_/g, ' ');
}

// Parse Discord markdown to HTML
function parseDiscordMarkdown(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    
    // Code blocks (```code```) - must be processed before inline code
    html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
    
    // Inline code (`code`) - protect code from other markdown
    const codeBlocks = [];
    html = html.replace(/`([^`\n]+)`/g, (match, code) => {
        const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
        codeBlocks.push(`<code>${code}</code>`);
        return placeholder;
    });
    
    // Bold and italic combinations (***text***)
    html = html.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
    
    // Bold (**text**)
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // Bold (__text__) - Discord uses __ for bold
    html = html.replace(/__(?![_*])([^_]+)__(?![_*])/g, '<strong>$1</strong>');
    
    // Italic (*text*)
    html = html.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em>$1</em>');
    
    // Italic (_text_) - but not if it's part of bold
    html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');
    
    // Strikethrough (~~text~~)
    html = html.replace(/~~([^~]+)~~/g, '<s>$1</s>');
    
    // Restore code blocks
    codeBlocks.forEach((code, index) => {
        html = html.replace(`__CODE_BLOCK_${index}__`, code);
    });
    
    // Preserve newlines as <br>
    html = html.replace(/\n/g, '<br>');
    
    return html;
}

// Render template by replacing {% templatetag openvariable %}variable{% templatetag closevariable %} placeholders (supports {% templatetag openvariable %}var::stock_price{% templatetag closevariable %})
function renderTemplate(template, data) {
    if (!template) return '';
    return template.replace(/\{\{(\w+)(?:::(\w+))?\}\}/g, (match, varName, modifier) => {
        if (modifier === 'stock_price') {
            // For preview: use whichever price field exists in the form data (already auto-filled).
            const p = data.current_price ?? data.entry_price ?? data.price;
            if (p !== undefined && p !== null && String(p).trim() !== '') return formatFloat3(p);
            const sym = (data && data[varName]) ? String(data[varName]).trim().toUpperCase() : '';
            const cached = sym ? tickerMetaCache[sym] : null;
            return (cached && cached.price != null) ? formatFloat3(cached.price) : '0.00';
        }
        if (modifier === 'company_name') {
            // Preview: use a provided company_name if present, else use cached metadata.
            const name = data.company_name;
            if (name !== undefined && name !== null && String(name).trim() !== '') return String(name);
            const sym = (data && data[varName]) ? String(data[varName]).trim().toUpperCase() : '';
            const cached = sym ? tickerMetaCache[sym] : null;
            return (cached && cached.company_name) ? String(cached.company_name) : 'Company Name';
        }
        if (modifier === 'option_price') {
            // Shares mode: options are disabled, so remove option_price from preview entirely.
            const isSharesCheckbox = document.getElementById('id_is_shares');
            const isShares = isSharesCheckbox && isSharesCheckbox.checked;
            if (isShares) return '';

            // Prefer explicit fields if present; default to 0.0
            const v = data.option_price ?? data.entry_price ?? data.price;
            return (v !== undefined && v !== null && String(v).trim() !== '') ? formatFloat3(v) : '0.00';
        }
        if (modifier && ['tp1_per','tp2_per','tp3_per','tp4_per','tp5_per','tp6_per','sl_per','tp1_takeoff_per','tp2_takeoff_per','tp3_takeoff_per','tp4_takeoff_per','tp5_takeoff_per','tp6_takeoff_per'].includes(modifier)) {
            const v = data[modifier];
            if (v === undefined || v === null || String(v).trim() === '') return '0%';
            const s = String(v).trim();
            return s.endsWith('%') ? s : `${s}%`;
        }
        if (modifier && ['tp1_price','tp2_price','tp3_price','tp4_price','tp5_price','tp6_price','sl_price'].includes(modifier)) {
            const v = data[modifier];
            return (v !== undefined && v !== null && String(v).trim() !== '') ? formatFloat3(v) : '0.00';
        }
        if (modifier && ['tp1_stock_price','tp2_stock_price','tp3_stock_price','tp4_stock_price','tp5_stock_price','tp6_stock_price'].includes(modifier)) {
            const v = data[modifier];
            if (v === undefined || v === null || String(v).trim() === '') return '';
            const n = Number(String(v).trim());
            return Number.isFinite(n) ? n.toFixed(2) : String(v);
        }
        if (modifier && (modifier in data)) {
            // Allow {% templatetag openvariable %}ticker::strike{% templatetag closevariable %} style access (treat modifier as the real variable name).
            const v = data[modifier];
            return (v !== undefined && v !== null) ? String(v) : '';
        }
        return data[varName] !== undefined ? String(data[varName]) : match;
    });
}

// Extract all variable names from a template string
function extractVariablesFromTemplate(template) {
    if (!template) return [];
    const variables = [];
    const regex = /\{\{(\w+)(?:::(\w+))?\}\}/g;
    let match;
    while ((match = regex.exec(template)) !== null) {
        // Track base variable name and (for certain modifiers) also track the modifier as a "real" variable.
        const base = match[1];
        const modifier = match[2];
        if (base && !variables.includes(base)) variables.push(base);

        // If template uses {% templatetag openvariable %}ticker::strike{% templatetag closevariable %},
        // treat "strike" as a used variable so the strike input is shown.
        if (modifier && ['is_shares', 'strike', 'expiration', 'option_type',
            'tp1_per', 'tp2_per', 'tp3_per', 'tp4_per', 'tp5_per', 'tp6_per',
            'tp1_mode', 'tp2_mode', 'tp3_mode', 'tp4_mode', 'tp5_mode', 'tp6_mode',
            'tp1_stock_price', 'tp2_stock_price', 'tp3_stock_price', 'tp4_stock_price', 'tp5_stock_price', 'tp6_stock_price',
            'tp1_takeoff_per', 'tp2_takeoff_per', 'tp3_takeoff_per', 'tp4_takeoff_per', 'tp5_takeoff_per', 'tp6_takeoff_per',
            'sl_per',
            'tp1_price', 'tp2_price', 'tp3_price', 'tp4_price', 'tp5_price', 'tp6_price', 'sl_price'
        ].includes(modifier)) {
            if (!variables.includes(modifier)) variables.push(modifier);
        }
    }
    return variables;
}

// Get all variables that are currently used in visible templates and fields
function getUsedVariables(signalTypeId) {
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) return { all: new Set(), optionalOnly: new Set() };
    
    const usedVariables = new Set();
    const optionalOnlyVariables = new Set();
    
    // Track variables used in non-optional contexts
    const nonOptionalVariables = new Set();
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Check title template (if visible)
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    if (showTitle && signalType.title_template) {
        extractVariablesFromTemplate(signalType.title_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check description template (if visible)
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    if (showDescription && signalType.description_template) {
        extractVariablesFromTemplate(signalType.description_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check footer template
    if (signalType.footer_template) {
        extractVariablesFromTemplate(signalType.footer_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check fields template (considering optional fields and is_shares)
    if (signalType.fields_template) {
        let fields = signalType.fields_template;
        if (typeof fields === 'string') {
            try {
                fields = JSON.parse(fields);
            } catch (e) {
                fields = [];
            }
        }
        fields = fields || [];
        
        fields.forEach((field, index) => {
            const isOptional = isOptionalFieldForSignalType(field, signalType);
            const fieldKey = `field_${signalTypeId}_${index}`;
            const isOptionalVisible = isOptional && optionalFieldsVisibility[fieldKey];
            
            // Skip optional fields that are hidden
            if (isOptional && !isOptionalVisible) {
                return; // Skip this optional field
            }
            
            // Skip fields that contain strike, expiration when is_shares is checked
            if (isShares) {
                const fieldNameLower = (field.name || '').toLowerCase();
                if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')) {
                    return; // Skip this field
                }
            }
            
            // Extract variables from field name and value
            const fieldVars = new Set();
            if (field.name) {
                extractVariablesFromTemplate(field.name).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            if (field.value) {
                extractVariablesFromTemplate(field.value).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            
            // If this is an optional field, mark its variables as optional-only (if not already in non-optional)
            if (isOptional && isOptionalVisible) {
                fieldVars.forEach(v => {
                    if (!nonOptionalVariables.has(v)) {
                        optionalOnlyVariables.add(v);
                    }
                });
            } else {
                // Non-optional field, mark variables as non-optional
                fieldVars.forEach(v => nonOptionalVariables.add(v));
            }
        });
    }
    
    // Remove variables from optionalOnly if they're also in nonOptional
    nonOptionalVariables.forEach(v => optionalOnlyVariables.delete(v));
    
    return { all: usedVariables, optionalOnly: optionalOnlyVariables };
}

// Update Discord embed preview
function updatePreview() {
    // Prevent recursive/re-entrant updates (typing in template, DOM changes, etc.)
    if (window.__ctpIsUpdatingPreview) return;
    window.__ctpIsUpdatingPreview = true;
    const isTradePlanOnlyPage = (document.querySelector('.dashboard-page')?.dataset?.mode === 'trade_plan_only');
    try {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.warn('Signal type not found for preview:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        return;
    }
    
    // Collect current form values
    const formData = {};
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Option-related fields that should be excluded when is_shares is checked
    const optionFields = ['strike', 'expiration', 'option_type'];
    
    // Collect inputs from both main dynamicFields container and optional fields variables container
    const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
    dynamicInputs.forEach(input => {
        // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
        // Include Trade Plan inputs (e.g. tp*_stock_price) in formData even if ignoreDynamic, so Live Preview shows correct target prices when Target Type is Stock price ($)
        if (!input.name || (input.dataset.ignoreDynamic === '1' && !input.closest('.trade-plan-group'))) {
            return;
        }
        // Skip option-related fields if is_shares is checked
        if (isShares && optionFields.includes(input.name)) {
            return;
        }
        
        // Skip hidden fields (those with data-requires-options when is_shares is true),
        // but always include Trade Plan inputs so Preview shows targets and Take Profit Plan like when is_shares is off
        if (input.closest('[data-requires-options="true"]') && isShares && !input.closest('.trade-plan-group')) {
            return;
        }
        
        if (input.type === 'checkbox') {
            formData[input.name] = input.checked ? 'true' : 'false';
        } else {
            formData[input.name] = input.value || '';
        }
    });

    // Include non-dynamic publish controls
    const tradeTypeEl = document.getElementById('trade_type');
    if (tradeTypeEl && tradeTypeEl.value) {
        formData['trade_type'] = tradeTypeEl.value;
    }
    
    // Update color bar
    const color = signalType.color || '#000000';
    document.getElementById('previewColorBar').style.backgroundColor = color;
    
    // Update title - check if title should be shown
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    const title = renderTemplate(signalType.title_template, formData);
    const titleEl = document.getElementById('previewTitle');
    if (isTradePlanOnlyPage) {
        titleEl.innerHTML = parseDiscordMarkdown('üìù Trade Plan');
        titleEl.style.display = 'block';
    } else if (title && showTitle) {
        titleEl.innerHTML = parseDiscordMarkdown(title);
        titleEl.style.display = 'block';
    } else {
        titleEl.style.display = 'none';
    }
    
    // Update description (disclaimer is shown below fields, not in description)
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    const description = renderTemplate(signalType.description_template, formData);
    const descEl = document.getElementById('previewDescription');
    if (!isTradePlanOnlyPage && description && description.trim() && showDescription) {
        descEl.innerHTML = parseDiscordMarkdown(description.trim());
        descEl.style.display = 'block';
    } else {
        descEl.style.display = 'none';
    }

    // Disclaimer: always show below fields (after Take Profit Plan), minimal gap
    const disclaimerText = 'Disclaimer: Not financial advice. Trade at your own risk.';
    const disclaimerEl = document.getElementById('previewDisclaimer');
    if (disclaimerEl) {
        disclaimerEl.innerHTML = parseDiscordMarkdown(disclaimerText);
        disclaimerEl.style.display = isTradePlanOnlyPage ? 'none' : 'block';
    }
    
    // Update fields
    const fieldsContainer = document.getElementById('previewFields');
    fieldsContainer.innerHTML = '';
    
    // Parse fields_template from JSON string if needed
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = (isTradePlanOnlyPage ? [] : (fields || []));
    
    // First, collect all fields that should be rendered (with all filtering applied)
    const fieldsToRender = [];
    fields.forEach((field, index) => {
        // Render field name and value first
        const fieldName = renderTemplate(field.name || '', formData);
        const fieldValue = renderTemplate(field.value || '', formData);
        
        // Skip optional fields that are hidden
        if (isOptionalFieldForSignalType(field, signalType)) {
            const fieldKey = `field_${signalTypeId}_${index}`;
            if (!optionalFieldsVisibility[fieldKey]) {
                return; // Skip this optional field
            }
        }
        
        // Skip fields that contain strike, expiration, or option_type when is_shares is checked
        if (isShares) {
            const fieldNameLower = (field.name || '').toLowerCase();
            const fieldValueLower = (field.value || '').toLowerCase();
            const renderedNameLower = (fieldName || '').toLowerCase();
            const renderedValueLower = (fieldValue || '').toLowerCase();
            
            // Check both raw template and rendered values
            // if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration') || fieldNameLower.includes('option') ||
            //     fieldValueLower.includes('{{strike}}') || fieldValueLower.includes('{{expiration}}') || fieldValueLower.includes('{{option_type}}') ||
            //     renderedNameLower.includes('strike') || renderedNameLower.includes('expiration') || renderedNameLower.includes('option') ||
            //     renderedValueLower.includes('strike') || renderedValueLower.includes('expiration') || renderedValueLower.includes('option')) {
            //     return; // Skip this field
            // }
            if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')){
                return;
            }
            // Also remove any field related to option_price in shares mode.
            if (fieldNameLower.includes('option_price') || fieldValueLower.includes('option_price') ||
                fieldNameLower.includes('option price') || fieldValueLower.includes('option price')) {
                return;
            }
        }
        
        // Store field data for rendering
        fieldsToRender.push({
            field: field,
            index: index,
            fieldName: fieldName,
            fieldValue: fieldValue
        });
    });
    
    // Remove consecutive blank spacers (keep only one)
    const filteredFields = [];
    let prevWasBlank = false;
    fieldsToRender.forEach((item) => {
        const isBlankSpacer = (!item.fieldName || !item.fieldName.trim()) && 
                             (item.fieldValue === '\u200b' || (item.fieldValue && item.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer && prevWasBlank) {
            return; // Skip consecutive blank spacers
        }
        prevWasBlank = isBlankSpacer;
        filteredFields.push(item);
    });
    
    // Remove trailing blank spacers
    while (filteredFields.length > 0) {
        const lastField = filteredFields[filteredFields.length - 1];
        const isBlankSpacer = (!lastField.fieldName || !lastField.fieldName.trim()) && 
                             (lastField.fieldValue === '\u200b' || (lastField.fieldValue && lastField.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer) {
            filteredFields.pop();
        } else {
            break;
        }
    }
    
    // Use filtered fields for rendering
    const fieldsToRenderFinal = filteredFields;

    // Inject Trade Plan preview block (Trade Plan / Targets / Stop Loss) below option-related fields
    // so users don't need to manually add these lines into every signal type template. Show when is_shares on or off.
    const tpBlock = { targetsLine: '', stopLossLine: '', tpPlanText: '' };
        const alreadyHasPlan = fieldsToRenderFinal.some(it => {
            const n = String(it.fieldName || '').toLowerCase();
            const v = String(it.fieldValue || '').toLowerCase();
            return n.includes('trade plan') || n.includes('game plan') || n.includes('targets') || n.includes('stop loss') ||
                   v.includes('trade plan') || v.includes('game plan') || v.includes('targets') || v.includes('stop loss');
        });

        if (!alreadyHasPlan) {
            // Inject Trade Plan block (Targets, Stop Loss, Take Profit Plan) into Live Preview
            const targets = [];
            for (let i = 1; i <= MAX_TP_LEVELS; i++) {
                const modeRaw = String(formData[`tp${i}_mode`] ?? '').trim().toLowerCase();
                const mode = (modeRaw === 'stock' || modeRaw === 'stock_price' || modeRaw === 'underlying' || modeRaw === 'share_price')
                    ? 'stock'
                    : 'percent';
                const takeoff = String(formData[`tp${i}_takeoff_per`] ?? '').trim();
                const takeoffStr = takeoff ? (takeoff.endsWith('%') ? takeoff : `${takeoff}%`) : '';

                if (mode === 'stock') {
                    const spRaw = String(formData[`tp${i}_stock_price`] ?? '').trim();
                    const n = spRaw ? Number(spRaw) : 0;
                    const spStr = Number.isFinite(n) ? n.toFixed(2) : (spRaw || '0.00');
                    // Stock price based targets: show as "TP1. $285.62"
                    targets.push(`TP${i}.$${spStr}`);
                    continue;
                }

                const per = String(formData[`tp${i}_per`] ?? '').trim();
                if (!per) continue;
                const price = String(formData[`tp${i}_price`] ?? '0.00').trim() || '0.00';
                const perNum = parsePercent(per);
                const perFmt = Number.isFinite(perNum) ? `${perNum >= 0 ? '+' : ''}${perNum.toFixed(1)}%` : (per.endsWith('%') ? per : `${per}%`);
                const priceNum = Number(String(price).trim());
                const priceFmt = Number.isFinite(priceNum) ? priceNum.toFixed(2) : String(price);
                // % based targets: show as "$6.24 (+20.0%)" (no takeoff in the summary line)
                targets.push(`$${priceFmt} (${perFmt})`);
            }

            const tps = [];
            const formatPct1 = (raw) => {
                const n = Number(String(raw ?? '').replace('%', '').trim());
                return Number.isFinite(n) ? `${n.toFixed(1)}%` : '';
            };
            const trailingRaw = formatPct1(formData['sl_per']) || '15.0%';
            const tpSteps = [];
            for (let i = 1; i <= MAX_TP_LEVELS; i++) {
                // Ensure Take Profit Plan count matches current TP rows count
                const rowEl = document.querySelector(`.tp-level-row[data-tp-row="1"][data-tp-level="${i}"]`);
                if (!rowEl) break;

                const modeRaw = String(formData[`tp${i}_mode`] ?? '').trim().toLowerCase();
                const mode = (modeRaw === 'stock' || modeRaw === 'stock_price' || modeRaw === 'underlying' || modeRaw === 'share_price')
                    ? 'stock'
                    : 'percent';

                const takePct = formatPct1(formData[`tp${i}_takeoff_per`]);
                const atStr = (() => {
                    if (mode === 'stock') {
                        const spRaw = String(formData[`tp${i}_stock_price`] ?? '').trim();
                        const n = spRaw ? Number(spRaw) : 0;
                        const spStr = Number.isFinite(n) ? n.toFixed(2) : (spRaw || '0.00');
                        // Stock price TP plan: include level label (e.g. "TP1.$0.00")
                        return `TP${i}.$${spStr}`;
                    }
                    const per = formatPct1(formData[`tp${i}_per`]);
                    return per || `${(i * 10).toFixed(1)}%`;
                })();

                // Raise stop loss suffix from row's selection (match selection labels: entry for TP1, TPn-1 for TP2+)
                let raiseSlSuffix = '';
                const raiseSlSelect = rowEl.querySelector('[data-tp-raise-sl-to]');
                const raiseSlTo = raiseSlSelect ? String(raiseSlSelect.value || '').trim().toLowerCase() : '';
                if (raiseSlTo === 'entry') {
                    raiseSlSuffix = i === 1 ? ' and raise stop loss to break even (entry)' : ` and raise stop loss to TP${i - 1}`;
                } else if (raiseSlTo === 'custom') {
                    const customPer = rowEl.querySelector('[data-tp-raise-sl-custom-per]');
                    const customPrice = rowEl.querySelector('[data-tp-raise-sl-custom]');
                    const customStock = rowEl.querySelector('[data-tp-raise-sl-custom-stock]');
                    const perVal = customPer ? String(customPer.value || '').trim() : '';
                    const priceVal = customPrice ? String(customPrice.value || '').trim() : '';
                    const stockVal = customStock ? String(customStock.value || '').trim() : '';
                    const hasCustomStock = mode === 'stock' && stockVal && Number(stockVal) !== 0;
                    const hasCustomPercent = mode === 'percent' && ( (priceVal && Number(priceVal) !== 0) || (perVal && Number(perVal) !== 0) );
                    if (hasCustomStock) {
                        raiseSlSuffix = ` and raise the stop loss to $${Number(stockVal).toFixed(2)} above the entry price`;
                    } else if (hasCustomPercent) {
                        if (perVal && Number(perVal) !== 0) raiseSlSuffix = ` and raise the stop loss to ${perVal}% above the entry price`;
                        else if (priceVal && Number(priceVal) !== 0) raiseSlSuffix = ` and raise the stop loss to $${Number(priceVal).toFixed(2)} above the entry price`;
                    }
                    // When custom is selected but value is empty/zero: no suffix (omit "raise the stop loss to custom level")
                }

                tpSteps.push({ level: i, atStr, takePct, raiseSlSuffix });
            }

            const ensurePeriod = (s) => (String(s || '').trim().endsWith('.') ? String(s || '').trim() : `${String(s || '').trim()}.`);
            tpSteps.forEach((step, idx) => {
                const takeStr = step.takePct
                    ? (idx === 0 ? ` take off ${step.takePct} of position` : ` take off ${step.takePct} of remaining position`)
                    : '';
                const suffix = step.raiseSlSuffix || '';
                const line = ensurePeriod(`Take Profit (${step.level}): At ${step.atStr}${takeStr}${suffix}`);
                tps.push(line);
            });
            const slPerRaw = String(formData['sl_per'] ?? '').trim();
            const slPriceRaw = String(formData['sl_price'] ?? formData['sl_price_visible'] ?? '0.00').trim() || '0.00';
            const slLevelsRaw = String(formData['sl_levels'] ?? '').trim();
            const timeHorizonRaw = String(formData['time_horizon'] ?? '').trim();
            const slPerStr = slPerRaw ? (slPerRaw.endsWith('%') ? slPerRaw : `${slPerRaw}%`) : '';
            
            // Collect stop loss levels from "raise stop loss to" settings in TP plan
            const stopLossLevelsFromTp = [];
            const entryPrice = parseFloat(String(formData['entry_price'] ?? formData['current_price'] ?? formData['price'] ?? '0').replace(/[$,]/g, '')) || 0;
            // Compute initial stop loss price from percentage when price is zero or missing
            const slPerNum = slPerRaw ? parseFloat(String(slPerRaw).replace(/[%,]/g, '')) : NaN;
            const initialSlPriceFromPer = (entryPrice > 0 && !isNaN(slPerNum)) ? entryPrice * (1 + slPerNum / 100) : null;
            const basePrice = isShares ? parseFloat(String(formData['current_price'] ?? formData['stock_price'] ?? '0').replace(/[$,]/g, '')) || entryPrice : parseFloat(String(formData['option_price'] ?? formData['price'] ?? '0').replace(/[$,]/g, '')) || entryPrice;
            
            // Get TP prices for calculating stop loss levels
            const tpPrices = {};
            // Get base price for calculations
            const basePriceForTp = isShares 
                ? (parseFloat(String(formData['current_price'] ?? formData['stock_price'] ?? '0').replace(/[$,]/g, '')) || entryPrice)
                : (parseFloat(String(formData['option_price'] ?? formData['price'] ?? '0').replace(/[$,]/g, '')) || entryPrice);
            
            for (let i = 1; i <= MAX_TP_LEVELS; i++) {
                const tpPriceRaw = String(formData[`tp${i}_price`] ?? '').trim();
                const tpStockPriceRaw = String(formData[`tp${i}_stock_price`] ?? '').trim();
                const tpModeRaw = String(formData[`tp${i}_mode`] ?? '').trim().toLowerCase();
                const isStockMode = tpModeRaw === 'stock' || tpModeRaw === 'stock_price' || tpModeRaw === 'underlying' || tpModeRaw === 'share_price';
                
                if (isStockMode && tpStockPriceRaw) {
                    const tpPrice = parseFloat(tpStockPriceRaw.replace(/[$,]/g, ''));
                    if (!isNaN(tpPrice) && tpPrice > 0) tpPrices[i] = tpPrice;
                } else if (tpPriceRaw) {
                    const tpPrice = parseFloat(tpPriceRaw.replace(/[$,]/g, ''));
                    if (!isNaN(tpPrice) && tpPrice > 0) tpPrices[i] = tpPrice;
                } else {
                    // Calculate TP price from percentage if not stored
                    const tpPerRaw = String(formData[`tp${i}_per`] ?? '').trim();
                    if (tpPerRaw && basePriceForTp > 0) {
                        const tpPer = parseFloat(tpPerRaw.replace(/[%,]/g, ''));
                        if (!isNaN(tpPer) && tpPer !== 0) {
                            // Calculate TP price: base * (1 + percentage/100)
                            const tpPrice = basePriceForTp * (1 + tpPer / 100);
                            if (tpPrice > 0) tpPrices[i] = tpPrice;
                        }
                    }
                }
            }
            
            // Collect stop loss levels from raise stop loss to settings
            for (let i = 1; i <= MAX_TP_LEVELS; i++) {
                const rowEl = document.querySelector(`.tp-level-row[data-tp-row="1"][data-tp-level="${i}"]`);
                if (!rowEl) break;
                
                const raiseSlSelect = rowEl.querySelector('[data-tp-raise-sl-to]');
                const raiseSlTo = raiseSlSelect ? String(raiseSlSelect.value || '').trim().toLowerCase() : '';
                
                // Skip if raise_sl_to is not set (empty, "off", etc.)
                if (!raiseSlTo || raiseSlTo === 'off') {
                    continue;
                }
                
                if (raiseSlTo === 'entry') {
                    if (i === 1 && entryPrice > 0) {
                        // TP1: raise to entry price
                        stopLossLevelsFromTp.push(entryPrice);
                    } else if (i > 1 && tpPrices[i - 1]) {
                        // TP2+: raise to previous TP price
                        stopLossLevelsFromTp.push(tpPrices[i - 1]);
                    }
                } else if (raiseSlTo === 'custom') {
                    const modeRaw = String(formData[`tp${i}_mode`] ?? '').trim().toLowerCase();
                    const mode = (modeRaw === 'stock' || modeRaw === 'stock_price' || modeRaw === 'underlying' || modeRaw === 'share_price') ? 'stock' : 'percent';
                    
                    const customPer = rowEl.querySelector('[data-tp-raise-sl-custom-per]');
                    const customPrice = rowEl.querySelector('[data-tp-raise-sl-custom]');
                    const customStock = rowEl.querySelector('[data-tp-raise-sl-custom-stock]');
                    const perVal = customPer ? parseFloat(String(customPer.value || '').trim().replace('%', '')) : NaN;
                    const priceVal = customPrice ? parseFloat(String(customPrice.value || '').trim().replace(/[$,]/g, '')) : NaN;
                    const stockVal = customStock ? parseFloat(String(customStock.value || '').trim().replace(/[$,]/g, '')) : NaN;
                    
                    if (mode === 'stock' && !isNaN(stockVal) && stockVal > 0 && entryPrice > 0) {
                        stopLossLevelsFromTp.push(entryPrice + stockVal);
                    } else if (!isNaN(priceVal) && priceVal > 0 && entryPrice > 0) {
                        stopLossLevelsFromTp.push(entryPrice + priceVal);
                    } else if (!isNaN(perVal) && perVal > 0 && entryPrice > 0) {
                        stopLossLevelsFromTp.push(entryPrice * (1 + perVal / 100));
                    }
                }
            }
            
            // Combine manual sl_levels with calculated levels from TP plan
            let allStopLossLevels = [];
            // Add initial stop loss price: use explicit price if set, else compute from percentage when price is zero
            const initialSlPrice = (function() {
                if (slPriceRaw && slPriceRaw !== '0.00') {
                    const n = parseFloat(slPriceRaw.replace(/[$,]/g, ''));
                    if (!isNaN(n)) return n;
                }
                return initialSlPriceFromPer;
            })();
            if (initialSlPrice != null && !isNaN(initialSlPrice)) {
                if (!allStopLossLevels.some(l => Math.abs(l - initialSlPrice) < 0.01)) {
                    allStopLossLevels.push(initialSlPrice);
                }
            }
            // Add manual sl_levels if provided
            if (slLevelsRaw) {
                const manualLevels = slLevelsRaw.split(';').map(s => {
                    const num = parseFloat(s.trim().replace(/[$,]/g, ''));
                    return !isNaN(num) && num > 0 ? num : null;
                }).filter(l => l !== null);
                manualLevels.forEach(level => {
                    if (!allStopLossLevels.some(l => Math.abs(l - level) < 0.01)) {
                        allStopLossLevels.push(level);
                    }
                });
            }
            // Add calculated levels from TP plan (avoid duplicates)
            stopLossLevelsFromTp.forEach(level => {
                if (level > 0 && !allStopLossLevels.some(l => Math.abs(l - level) < 0.01)) {
                    allStopLossLevels.push(level);
                }
            });
            // Sort levels (highest to lowest for stop losses)
            allStopLossLevels.sort((a, b) => b - a);
            // Format each stop loss level with price and percentage relative to entry price
            const allStopLossLevelsFormatted = allStopLossLevels.length > 0 
                ? allStopLossLevels.map(l => {
                    const priceStr = l.toFixed(2);
                    let percentStr = '';
                    if (entryPrice > 0) {
                        const percent = ((l - entryPrice) / entryPrice) * 100;
                        percentStr = `${percent >= 0 ? '+' : ''}${percent.toFixed(1)}%`;
                    } else {
                        percentStr = '0%';
                    }
                    return `${priceStr}(${percentStr})`;
                }).join(', ')
                : '';

            // Show Trade Plan even before option price is computed (defaults: 0.00)
            if (targets.length || tps.length || slPerRaw || slPriceRaw || slLevelsRaw || allStopLossLevelsFormatted || timeHorizonRaw) {
                // Find insertion index: after last option-related field (Expiration/Strike/Option/Price)
                let insertAt = -1;
                fieldsToRenderFinal.forEach((it, idx) => {
                    const n = String(it.fieldName || '').toLowerCase();
                    const v = String(it.fieldValue || '').toLowerCase();
                    if (
                        n.includes('expiration') || n.includes('strike') || n.includes('option') || n.includes('price') ||
                        v.includes('expiration') || v.includes('strike') || v.includes('option') || v.includes('price')
                    ) {
                        insertAt = idx;
                    }
                });
                insertAt = insertAt >= 0 ? insertAt + 1 : 0;

                // Remove blank line after options data (single spacer immediately before insertion point)
                if (insertAt > 0) {
                    const prev = fieldsToRenderFinal[insertAt - 1];
                    const prevBlank = !(prev.fieldName || '').trim() && (prev.fieldValue === '\u200b' || (prev.fieldValue || '').trim() === '\u200b');
                    if (prevBlank) {
                        fieldsToRenderFinal.splice(insertAt - 1, 1);
                        insertAt -= 1;
                    }
                }

                const injected = [];
                // Blank line before Trade Plan (like before Take Profit Plan)
                injected.push({ field: { inline: false }, index: -1000, fieldName: '', fieldValue: '\u200b' });
                injected.push({ field: { inline: false }, index: -1001, fieldName: 'üìù **Trade Plan**', fieldValue: '' });
                // When is_shares on: show Targets line directly below Trade Plan in Discord preview
                const showTargetsLine = targets.length > 0 || isShares;
                if (showTargetsLine) {
                    const joiner = targets.some(t => String(t || '').startsWith('TP')) ? ',  ' : ', ';
                    const targetsText = targets.length ? targets.join(joiner) : '‚Äî';
                    tpBlock.targetsLine = `üéØ Targets: ${targetsText}`;
                    injected.push({
                        field: { inline: false },
                        index: -1002,
                        fieldName: `üéØ Targets: ${targetsText}`,
                        fieldValue: '',
                    });
                }
                // Stop Loss: show multiple levels if provided (from manual input or calculated from TP plan), otherwise single price or percentage
                if (allStopLossLevelsFormatted) {
                    tpBlock.stopLossLine = `üõë Stop Loss: ${allStopLossLevelsFormatted}`;
                    injected.push({
                        field: { inline: false },
                        index: -1003,
                        fieldName: `üõë Stop Loss: ${allStopLossLevelsFormatted}`,
                        fieldValue: '',
                    });
                } else {
                    // Single stop loss: use explicit price or compute from percentage when price is zero
                    const slPrice = initialSlPrice != null && !isNaN(initialSlPrice)
                        ? initialSlPrice
                        : (slPriceRaw && slPriceRaw !== '0.00' ? parseFloat(slPriceRaw.replace(/[$,]/g, '')) : NaN);
                    const slPriceStr = (!isNaN(slPrice) && slPrice !== null) ? slPrice.toFixed(2) : slPriceRaw;
                    let percentStr = '';
                    if (entryPrice > 0 && !isNaN(slPrice)) {
                        const percent = ((slPrice - entryPrice) / entryPrice) * 100;
                        percentStr = `(${percent >= 0 ? '+' : ''}${percent.toFixed(1)}%)`;
                    } else if (slPerStr) {
                        percentStr = `(${slPerStr})`;
                    }
                    if (slPriceStr !== '0.00' || percentStr || slPerStr) {
                        tpBlock.stopLossLine = `üõë Stop Loss: ${slPriceStr}${percentStr}`;
                        injected.push({
                            field: { inline: false },
                            index: -1003,
                            fieldName: `üõë Stop Loss: ${slPriceStr}${percentStr}`,
                            fieldValue: '',
                        });
                    } else if (slPerStr) {
                        tpBlock.stopLossLine = `üõë Stop Loss: ${slPerStr}`;
                        injected.push({
                            field: { inline: false },
                            index: -1003,
                            fieldName: `üõë Stop Loss: ${slPerStr}`,
                            fieldValue: '',
                        });
                    }
                }
                // Time Horizon (for leaps/swings only; show in preview when trade type is Swing or Leap)
                const tradeTypeForPreview = String(formData['trade_type'] ?? '').trim().toLowerCase();
                if (timeHorizonRaw && (tradeTypeForPreview === 'swing' || tradeTypeForPreview === 'leap')) {
                    injected.push({
                        field: { inline: false },
                        index: -1004,
                        fieldName: `‚è±Ô∏è Time Horizon: ${timeHorizonRaw}`,
                        fieldValue: '',
                    });
                }
                // Move Take Profit Plan AFTER Stop Loss
                if (tps.length) {
                    // Spacer before Take Profit Plan
                    injected.push({ field: { inline: false }, index: -1003.5, fieldName: '', fieldValue: '\u200b' });
                    tpBlock.tpPlanText = `üí∞ Take Profit Plan\n${tps.join('\n')}`;
                    injected.push({
                        field: { inline: false },
                        index: -1004,
                        fieldName: 'üí∞ Take Profit Plan',
                        fieldValue: tps.join('\n'),
                    });
                }

                fieldsToRenderFinal.splice(insertAt, 0, ...injected);
            }
        }

    // New Trade Plan page: no extra message template (Trade Plan block only)
    
    let currentInlineGroup = null;
    
    // Function to adjust inline field widths based on count in group
    function adjustInlineGroupWidths(inlineGroup) {
        if (!inlineGroup) return;
        const fieldCount = inlineGroup.children.length;
        if (fieldCount === 0) return;
        
        // Calculate width based on number of fields
        let width;
        if (fieldCount === 1) {
            width = 'calc(33.333% - 11px)'; // Single field in a row of 3
        } else if (fieldCount === 2) {
            width = 'calc(50% - 8px)'; // Two fields: each takes 50% minus half the gap
        } else {
            width = 'calc(33.333% - 11px)'; // Three fields: each takes 33.333%
        }
        
        // Apply width to all fields in the group
        Array.from(inlineGroup.children).forEach(field => {
            field.style.flex = `0 0 ${width}`;
            field.style.maxWidth = width;
        });
    }
    
    // Now render the filtered fields
    fieldsToRenderFinal.forEach(({field, index, fieldName, fieldValue}, renderIndex) => {
        
        const fieldEl = document.createElement('div');
        fieldEl.className = 'discord-embed-field';
        
        // Check if this is an inline field
        if (field.inline) {
            // If previous field was not inline, start a new inline group
            if (!currentInlineGroup || (renderIndex > 0 && !fieldsToRenderFinal[renderIndex - 1].field.inline)) {
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            // Check if current group already has 3 fields, start a new row
            if (currentInlineGroup && currentInlineGroup.children.length >= 3) {
                // Adjust widths for the previous group before starting new one
                adjustInlineGroupWidths(currentInlineGroup);
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            fieldEl.classList.add('discord-embed-field-inline');
        } else {
            // Non-inline field, adjust widths for any existing inline group and close it
            adjustInlineGroupWidths(currentInlineGroup);
            currentInlineGroup = null;
        }
        
        const nameEl = document.createElement('div');
        nameEl.className = 'discord-embed-field-name';
        nameEl.innerHTML = fieldName ? parseDiscordMarkdown(fieldName) : '\u200b';
        
        const valueEl = document.createElement('div');
        valueEl.className = 'discord-embed-field-value';
        valueEl.innerHTML = fieldValue ? parseDiscordMarkdown(fieldValue) : '\u200b';
        
        fieldEl.appendChild(nameEl);
        if (fieldValue !== '') {
            fieldEl.appendChild(valueEl);
        }
            
        
        if (field.inline && currentInlineGroup) {
            currentInlineGroup.appendChild(fieldEl);
        } else {
            fieldsContainer.appendChild(fieldEl);
        }
    });
    
    // Adjust widths for any remaining inline group at the end
    adjustInlineGroupWidths(currentInlineGroup);
    
    // Update footer (custom template only; disclaimer is in description)
    const footer = renderTemplate(signalType.footer_template, formData);
    const footerEl = document.getElementById('previewFooter');
    if (footerEl) {
        if (footer && footer.trim()) {
            footerEl.innerHTML = parseDiscordMarkdown(footer.trim());
            footerEl.style.display = 'block';
        } else {
            footerEl.style.display = 'none';
        }
    }

    // TA Media (Chart Analysis) preview: show image/video in Discord-style embed when file is selected
    const previewMediaEl = document.getElementById('previewMedia');
    const previewMediaImg = document.getElementById('previewMediaImg');
    const previewMediaVid = document.getElementById('previewMediaVid');
    if (previewMediaEl && previewMediaImg && previewMediaVid) {
        if (window._previewMediaObjectUrl) {
            try { URL.revokeObjectURL(window._previewMediaObjectUrl); } catch (_) {}
            window._previewMediaObjectUrl = null;
        }
        const chartInput = document.querySelector('#optionalFieldsVariablesContainer input[name="chart_analysis"]');
        const file = chartInput && chartInput.files && chartInput.files[0] ? chartInput.files[0] : null;
        previewMediaImg.style.display = 'none';
        previewMediaVid.style.display = 'none';
        previewMediaImg.removeAttribute('src');
        previewMediaVid.removeAttribute('src');
        previewMediaEl.style.display = 'none';
        if (file) {
            const url = URL.createObjectURL(file);
            window._previewMediaObjectUrl = url;
            const type = (file.type || '').toLowerCase();
            if (type.startsWith('image/')) {
                previewMediaImg.src = url;
                previewMediaImg.style.display = 'block';
                previewMediaEl.style.display = 'block';
            } else if (type.startsWith('video/')) {
                previewMediaVid.src = url;
                previewMediaVid.style.display = 'block';
                previewMediaEl.style.display = 'block';
            }
        }
    }

    } finally {
        window.__ctpIsUpdatingPreview = false;
    }
}

// Create dynamic form fields based on signal type
function createDynamicFields(signalTypeId) {
    console.log('createDynamicFields called with signalTypeId:', signalTypeId);
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    if (!dynamicFieldsContainer) {
        console.error('dynamicFields container not found!');
        return;
    }
    dynamicFieldsContainer.innerHTML = '';
    
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.error('Signal type not found:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        updatePreview();
        return;
    }
    
    console.log('Found signal type:', signalType);
    
    // Parse variables from JSON string if needed
    let variables = signalType.variables;
    if (typeof variables === 'string') {
        try {
            variables = JSON.parse(variables);
        } catch (e) {
            console.error('Error parsing variables:', e, 'Raw value:', variables);
            variables = [];
        }
    }
    variables = variables || [];
    
    console.log('Parsed variables:', variables, 'Count:', variables.length);
    
    if (variables.length === 0) {
        console.warn('No variables found for signal type:', signalTypeId);
        dynamicFieldsContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No variables defined for this signal type.</p>';
        updatePreview();
        return;
    }
    
    // Get used variables to determine visibility
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    let tickerTypeToggleSlot = null;
    let isSharesPill = null;
    let isSharesFormGroup = null;
    const hasIsSharesVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'is_shares');
    const hasStrikeVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'strike');
    const hasExpirationVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'expiration');
    const hasOptionTypeVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_type');
    const hasOptionPriceVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_price');
    const hasOptionContractVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_contract');

    function createSyntheticIsSharesPill() {
        // Create the same pill UI used for real is_shares variables, but without needing it in the template variables list.
        const pill = document.createElement('div');
        pill.className = 'toggle-pill';

        const switchWrap = document.createElement('label');
        switchWrap.className = 'toggle-switch';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'form-checkbox';
        input.id = 'id_is_shares';
        input.name = 'is_shares';
        input.checked = false;

        const slider = document.createElement('span');
        slider.className = 'toggle-slider';

        switchWrap.appendChild(input);
        switchWrap.appendChild(slider);

        const text = document.createElement('div');
        text.className = 'toggle-label';
        text.textContent = 'Is_Shares (Disable Options fields)';

        pill.appendChild(switchWrap);
        pill.appendChild(text);

        return { pill, input };
    }

    function createSyntheticOptionField(name) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = ({
            strike: 'Strike',
            expiration: 'Expiration',
            option_type: 'Option Type',
        })[name] || name;
        label.setAttribute('for', `id_${name}`);

        let input;
        if (name === 'strike') {
            input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'form-input';
            input.placeholder = 'Enter strike price (e.g., 150.50)';
        } else if (name === 'expiration') {
            input = document.createElement('input');
            input.type = 'date';
            input.className = 'form-input';
            const today = getTodayISODate();
            input.min = today;
            if (!input.value) input.value = today;
            input.addEventListener('change', function() {
                if (typeof setTimeHorizonDefault === 'function') setTimeHorizonDefault();
            });
            input.addEventListener('input', function() {
                if (typeof setTimeHorizonDefault === 'function') setTimeHorizonDefault();
            });
        } else if (name === 'option_type') {
            input = document.createElement('select');
            input.className = 'form-select';
            ['CALL', 'PUT'].forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt;
                o.textContent = opt;
                input.appendChild(o);
            });
        } else {
            input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-input';
        }

        input.id = `id_${name}`;
        input.name = name;

        formGroup.appendChild(label);
        formGroup.appendChild(input);

        // match event behavior of other dynamic inputs
        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));

        // When synthetic option_type (Buy/Sell) changes: update Trade Plan targets and preview; when is_shares off, pick best option.
        if (name === 'option_type') {
            input.dataset.optionTypeChangeWired = '1';
            const onOptionTypeChange = async () => {
                const isSharesCheckbox = document.getElementById('id_is_shares');
                if (isSharesCheckbox && isSharesCheckbox.checked) {
                    applyTpLevelDirectionForShares(true);
                    updateTpSlPrices();
                    updatePreview();
                } else {
                    updateDefaultTpStockTargets();
                    if (typeof maybeAutoPickBestOption === 'function') await maybeAutoPickBestOption();
                    updateTpSlPrices();
                    updatePreview();
                }
            };
            input.addEventListener('change', onOptionTypeChange);
            input.addEventListener('input', () => {
                const isSharesCheckbox = document.getElementById('id_is_shares');
                if (isSharesCheckbox && isSharesCheckbox.checked) onOptionTypeChange();
            });
        }

        return formGroup;
    }

    function createSyntheticHiddenField(name, defaultValue = '') {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');
        // Mark as auto-filled so setValueIfAllowed can overwrite it later.
        input.dataset.autoFilled = '1';

        const wrapper = document.createElement('div');
        wrapper.className = 'form-group';
        wrapper.classList.add('synthetic-hidden');
        wrapper.style.display = 'none';
        wrapper.setAttribute('data-variable-name', name);
        wrapper.appendChild(input);

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        return wrapper;
    }

    function createSyntheticPercentField(name, defaultValue, labelText, { showPercentSuffix = false, allowNegative = false } = {}) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = labelText || name;
        label.setAttribute('for', `id_${name}`);

        const input = document.createElement('input');
        input.type = 'number';
        // Allow more precision for stop loss percentage (was 0.1, now 0.01 for better precision)
        input.step = name === 'sl_per' ? '0.01' : '0.1';
        input.min = allowNegative ? '-100' : '0';
        input.className = 'form-input';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');

        formGroup.appendChild(label);
        if (showPercentSuffix) {
            const wrap = document.createElement('div');
            wrap.className = 'percent-input-wrap';
            wrap.appendChild(input);
            const suffix = document.createElement('span');
            suffix.className = 'percent-suffix';
            suffix.textContent = '%';
            wrap.appendChild(suffix);
            input.style.paddingRight = '34px';
            formGroup.appendChild(wrap);
        } else {
            formGroup.appendChild(input);
        }

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));
        input.addEventListener('input', () => updateTpSlPrices());
        input.addEventListener('change', () => updateTpSlPrices());

        return formGroup;
    }

    function createSyntheticPriceField(name, defaultValue, labelText, { showDollarPrefix = true } = {}) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = labelText || name;
        label.setAttribute('for', `id_${name}`);

        const input = document.createElement('input');
        input.type = 'number';
        input.step = '0.01';
        input.min = '0';
        input.className = 'form-input';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');

        formGroup.appendChild(label);
        if (showDollarPrefix) {
            const wrap = document.createElement('div');
            wrap.className = 'percent-input-wrap';
            const prefix = document.createElement('span');
            prefix.className = 'percent-suffix';
            prefix.textContent = '$';
            prefix.style.left = '10px';
            prefix.style.right = 'auto';
            prefix.style.padding = '0';
            // Reuse the existing wrap/suffix styles; position prefix on the left
            wrap.style.position = 'relative';
            wrap.appendChild(input);
            wrap.appendChild(prefix);
            input.style.paddingLeft = '26px';
            formGroup.appendChild(wrap);
        } else {
            formGroup.appendChild(input);
        }

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));
        return formGroup;
    }

    function createTakeProfitRow(level, defaultPer, defaultTakeoffPer, { defaultMode = 'percent', defaultStockPrice = '', defaultRaiseSlTo = '', defaultRaiseSlCustom = '', defaultRaiseSlCustomPer = '', defaultRaiseSlCustomStock = '', isLastLevel = false } = {}) {
        const rowWrap = document.createElement('div');
        rowWrap.className = 'tp-level-row';
        rowWrap.dataset.tpRow = '1';
        rowWrap.dataset.tpLevel = String(level);

        const header = document.createElement('div');
        header.className = 'tp-level-row-header';
        rowWrap.appendChild(header);

        // Hidden per-row mode (percent or stock; set by Target Type selector)
        const modeHidden = document.createElement('input');
        modeHidden.type = 'hidden';
        modeHidden.id = `id_tp${level}_mode`;
        modeHidden.name = `tp${level}_mode`;
        const modeVal = (defaultMode === 'stock' || defaultMode === 'stock_price' || defaultMode === 'underlying' || defaultMode === 'share_price') ? 'stock' : 'percent';
        modeHidden.value = modeVal;
        rowWrap.appendChild(modeHidden);

        // Add a remove button (we'll only show it on the last row)
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tp-remove-btn';
        btn.style.display = 'none';

        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        icon.setAttribute('viewBox', '0 0 24 24');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M9 3h6l1 2h5v2H3V5h5l1-2zm1 7h2v9h-2v-9zm4 0h2v9h-2v-9zM7 10h2v9H7v-9z');
        icon.appendChild(path);

        const text = document.createElement('span');
        text.textContent = 'Remove';
        btn.appendChild(icon);
        btn.appendChild(text);

        // Body: two columns (Target + Take Off %)
        const body = document.createElement('div');
        body.className = 'tp-level-row-body';
        body.style.gridTemplateColumns = '2.2fr 0.8fr';

        // Left column: target value (driven by global mode) ‚Äî percent col and stock col toggled by Target Type
        const targetCol = document.createElement('div');
        targetCol.style.display = 'flex';
        targetCol.style.flexDirection = 'column';
        targetCol.style.gap = '10px';

        const percentCol = document.createElement('div');
        percentCol.dataset.tpPercentCol = '1';

        // TP % input (label goes in header); allowNegative for SELL (is_shares on, negative %)
        const tpGroup = createSyntheticPercentField(`tp${level}_per`, defaultPer, `TP %`, { showPercentSuffix: true, allowNegative: true });
        const tpLabel = tpGroup.querySelector('label');
        if (tpLabel) {
            // Put "Take Profit N" in header, remove inner label to avoid duplication
            tpLabel.textContent = `Take Profit ${level}`;
            header.appendChild(tpLabel);
        } else {
            const fallbackLabel = document.createElement('label');
            fallbackLabel.textContent = `Take Profit ${level}`;
            header.appendChild(fallbackLabel);
        }
        header.appendChild(btn);

        // If we moved the label, ensure it isn't still inside the group
        const innerLabel = tpGroup.querySelector('label');
        if (innerLabel) innerLabel.remove();

        // Add a small label above the level percent input (inside the row body)
        const levelLabel = document.createElement('label');
        levelLabel.textContent = 'Level %';
        levelLabel.setAttribute('for', `id_tp${level}_per`);
        const tpWrapEl = tpGroup.querySelector('.percent-input-wrap');
        if (tpWrapEl) {
            tpGroup.insertBefore(levelLabel, tpWrapEl);
        } else {
            const tpInput = tpGroup.querySelector('input, select, textarea');
            if (tpInput && tpInput.parentElement === tpGroup) {
                tpGroup.insertBefore(levelLabel, tpInput);
            } else if (tpInput && tpInput.parentElement) {
                tpGroup.insertBefore(levelLabel, tpInput.parentElement);
            } else {
                tpGroup.appendChild(levelLabel);
            }
        }

        // Price display (left of Level %) when Target type is % based: show computed price, edit to drive %
        const priceRow = document.createElement('div');
        priceRow.style.display = 'flex';
        priceRow.style.gap = '10px';
        priceRow.style.alignItems = 'flex-end';
        priceRow.style.flexWrap = 'wrap';
        const priceLabel = document.createElement('label');
        priceLabel.textContent = 'Price';
        const priceDisplayInput = document.createElement('input');
        priceDisplayInput.type = 'number';
        priceDisplayInput.step = '0.01';
        priceDisplayInput.min = '0';
        priceDisplayInput.className = 'form-input';
        priceDisplayInput.dataset.tpPriceDisplay = '1';
        priceDisplayInput.dataset.tpLevel = String(level);
        priceDisplayInput.placeholder = '0.00';
        priceDisplayInput.dataset.ignoreDynamic = '1';

        const levelWrap = document.createElement('div');
        levelWrap.style.flex = '1';
        levelWrap.style.minWidth = '80px';
        levelWrap.appendChild(levelLabel);
        levelWrap.appendChild(tpWrapEl || tpGroup.querySelector('input'));

        const priceWrap = document.createElement('div');
        priceWrap.style.flex = '1';
        priceWrap.style.minWidth = '120px';
        priceWrap.appendChild(priceLabel);
        priceWrap.appendChild(priceDisplayInput);

        // Place Level % first, Price second
        priceRow.appendChild(levelWrap);
        priceRow.appendChild(priceWrap);
        tpGroup.innerHTML = '';
        tpGroup.appendChild(priceRow);

        const perInput = tpGroup.querySelector(`input[name="tp${level}_per"]`);
        const setPriceDisplaySilent = (val) => {
            priceDisplayInput.value = String(val ?? '');
            priceDisplayInput.dataset.autoFilled = '1';
        };
        function getTpBasePrice() {
            const isShares = (findFieldByName('is_shares') && findFieldByName('is_shares').checked) || false;
            const currentPriceEl = findFieldByName('current_price');
            const optionPriceEl = findFieldByName('option_price');
            const entryPriceEl = findFieldByName('entry_price');
            const priceEl = findFieldByName('price');
            const baseRaw = isShares
                ? ((currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '')
                : ((optionPriceEl && optionPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '');
            const base = Number(String(baseRaw).trim());
            return Number.isFinite(base) ? base : NaN;
        }
        function applyPriceFromPercent() {
            if (priceDisplayInput.dataset.skipNextInput === '1') {
                delete priceDisplayInput.dataset.skipNextInput;
                return;
            }
            const base = getTpBasePrice();
            if (!Number.isFinite(base) || base <= 0) return;
            const per = parsePercent(perInput?.value);
            if (Number.isFinite(per)) {
                const p = base * (1 + per / 100);
                setPriceDisplaySilent(formatFloat3(p));
            }
            updateTpSlPrices();
            updatePreview();
        }
        function applyPercentFromPrice() {
            if (priceDisplayInput.dataset.skipNextInput === '1') {
                delete priceDisplayInput.dataset.skipNextInput;
                return;
            }
            const base = getTpBasePrice();
            if (!Number.isFinite(base) || base <= 0) return;
            const price = Number(String(priceDisplayInput.value || '').trim());
            if (!Number.isFinite(price) || price <= 0) return;
            const per = (price / base - 1) * 100;
            if (perInput) {
                // Prevent percent->price sync from immediately overwriting the user-edited price.
                priceDisplayInput.dataset.skipNextInput = '1';
                perInput.value = String(Number(per.toFixed(1)));
                perInput.dataset.autoFilled = '1';
                // Allow future auto-fill updates, but treat this as a programmatic sync.
                delete perInput.dataset.userTouched;
                updateTpSlPrices();
                updatePreview();
            }
        }
        // Listen to input only (change duplicates on some browsers)
        priceDisplayInput.addEventListener('input', () => markUserTouched(priceDisplayInput));
        priceDisplayInput.addEventListener('input', applyPercentFromPrice);
        priceDisplayInput.addEventListener('focus', () => { priceDisplayInput.select?.(); });
        if (perInput) {
            perInput.addEventListener('input', applyPriceFromPercent);
            // change duplicates on some browsers
        }
        rowWrap._tpPriceDisplayEl = priceDisplayInput;
        rowWrap._tpApplyPriceFromPercent = applyPriceFromPercent;

        percentCol.appendChild(tpGroup);

        // Stock price target column (shown when Target Type = Stock price ($))
        const stockCol = document.createElement('div');
        stockCol.dataset.tpStockCol = '1';
        stockCol.style.display = 'none';
        const stockLabel = document.createElement('label');
        stockLabel.textContent = 'Stock price ($)';
        stockLabel.setAttribute('for', `id_tp${level}_stock_price`);
        const stockInput = document.createElement('input');
        stockInput.type = 'number';
        stockInput.step = '0.01';
        stockInput.min = '0';
        stockInput.className = 'form-input';
        stockInput.id = `id_tp${level}_stock_price`;
        stockInput.name = `tp${level}_stock_price`;
        stockInput.placeholder = '0.00';
        stockInput.value = String(defaultStockPrice ?? '').trim();
        stockInput.dataset.ignoreDynamic = '1';
        // Mark as auto-filled when empty so updateDefaultTpStockTargets can set correct stock price targets
        if (!String(defaultStockPrice ?? '').trim()) stockInput.dataset.autoFilled = '1';
        stockCol.appendChild(stockLabel);
        stockCol.appendChild(stockInput);
        stockInput.addEventListener('input', () => { updateTpSlPrices(); updatePreview(); });
        stockInput.addEventListener('change', () => { updateTpSlPrices(); updatePreview(); });

        targetCol.appendChild(percentCol);
        targetCol.appendChild(stockCol);

        // Right column: takeoff % (capital removed when TP hits)
        const takeoffDefaults = { 1: 50, 2: 50, 3: 100 };
        const takeoffGroup = createSyntheticPercentField(
            `tp${level}_takeoff_per`,
            (defaultTakeoffPer ?? takeoffDefaults[level] ?? 0),
            'Take Off',
            { showPercentSuffix: true }
        );
        // Treat defaults as auto-filled so we can safely re-default when adding/removing TP rows.
        try {
            const takeoffInput = takeoffGroup.querySelector('input');
            if (takeoffInput) takeoffInput.dataset.autoFilled = '1';
        } catch (_) {}
        takeoffGroup.dataset.tpTakeoffGroup = '1';

        body.appendChild(targetCol);
        body.appendChild(takeoffGroup);
        rowWrap.appendChild(body);

        if (!isLastLevel) {
        // Raise stop loss: visible on all TP levels except the last (last is always off)
        const actionsPanel = document.createElement('div');
        actionsPanel.className = 'tp-actions-panel';
        actionsPanel.dataset.tpActionsPanel = '1';
        const actionsLabel = document.createElement('label');
        actionsLabel.textContent = 'Raise stop loss to:';
        const raiseSlSelect = document.createElement('select');
        raiseSlSelect.className = 'form-input';
        raiseSlSelect.dataset.tpRaiseSlTo = '1';
        raiseSlSelect.dataset.tpLevel = String(level);
        const optOff = document.createElement('option');
        optOff.value = 'off';
        optOff.textContent = 'Off';
        raiseSlSelect.appendChild(optOff);
        const optEntry = document.createElement('option');
        optEntry.value = 'entry';
        optEntry.textContent = level === 1 ? 'Break even (entry)' : `Break even (TP${level - 1})`;
        raiseSlSelect.appendChild(optEntry);
        const optCustom = document.createElement('option');
        optCustom.value = 'custom';
        optCustom.textContent = 'Custom level';
        raiseSlSelect.appendChild(optCustom);
        const customWrap = document.createElement('div');
        customWrap.style.display = 'none';
        customWrap.dataset.tpRaiseSlCustomWrap = '1';
        const currentTpMode = () => (typeof globalModeSelect !== 'undefined' && globalModeSelect && (globalModeSelect.value === 'stock' || globalModeSelect.value === 'stock_price')) ? 'stock' : 'percent';
        const showPercentCustom = () => currentTpMode() === 'percent';
        const showStockCustom = () => currentTpMode() === 'stock';

        // Percent mode: Level % + Price inputs on the same line (synced like TP row)
        const customPercentWrap = document.createElement('div');
        customPercentWrap.dataset.tpRaiseSlPercentWrap = '1';
        customPercentWrap.style.display = showPercentCustom() ? 'flex' : 'none';
        customPercentWrap.style.gap = '14px';
        customPercentWrap.style.flexWrap = 'nowrap';
        customPercentWrap.style.marginTop = '8px';
        customPercentWrap.style.alignItems = 'flex-end';
        const perLabel = document.createElement('label');
        perLabel.textContent = 'Level %';
        const perInputCustom = document.createElement('input');
        perInputCustom.type = 'text';
        perInputCustom.className = 'form-input';
        perInputCustom.placeholder = '0';
        perInputCustom.dataset.tpRaiseSlCustomPer = '1';
        perInputCustom.dataset.tpLevel = String(level);
        const priceLabelCustom = document.createElement('label');
        priceLabelCustom.textContent = 'Price';
        const customPriceInput = document.createElement('input');
        customPriceInput.type = 'number';
        customPriceInput.step = '0.01';
        customPriceInput.min = '0';
        customPriceInput.className = 'form-input';
        customPriceInput.placeholder = '0.00';
        customPriceInput.dataset.tpRaiseSlCustom = '1';
        customPriceInput.dataset.tpLevel = String(level);
        const perBlock = document.createElement('div');
        perBlock.style.display = 'flex';
        perBlock.style.flexDirection = 'column';
        perBlock.style.gap = '4px';
        perBlock.style.minWidth = '80px';
        perBlock.appendChild(perLabel);
        perBlock.appendChild(perInputCustom);
        const priceBlock = document.createElement('div');
        priceBlock.style.display = 'flex';
        priceBlock.style.flexDirection = 'column';
        priceBlock.style.gap = '4px';
        priceBlock.style.minWidth = '100px';
        priceBlock.appendChild(priceLabelCustom);
        priceBlock.appendChild(customPriceInput);
        customPercentWrap.appendChild(perBlock);
        customPercentWrap.appendChild(priceBlock);
        function getRaiseSlBasePrice() {
            const isShares = (findFieldByName('is_shares') && findFieldByName('is_shares').checked) || false;
            const currentPriceEl = findFieldByName('current_price');
            const optionPriceEl = findFieldByName('option_price');
            const entryPriceEl = findFieldByName('entry_price');
            const priceEl = findFieldByName('price');
            const baseRaw = isShares
                ? ((currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '')
                : ((optionPriceEl && optionPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '');
            const base = Number(String(baseRaw).trim());
            return Number.isFinite(base) ? base : NaN;
        }
        function parsePct(val) {
            const s = String(val || '').trim().replace('%', '');
            const n = Number(s);
            return Number.isFinite(n) ? n : NaN;
        }
        function applyRaiseSlPriceFromPercent() {
            const base = getRaiseSlBasePrice();
            if (Number.isFinite(base) && base > 0) {
                const per = parsePct(perInputCustom.value);
                if (Number.isFinite(per)) {
                    const p = base * (1 + per / 100);
                    customPriceInput.value = String(typeof formatFloat3 === 'function' ? formatFloat3(p) : p.toFixed(2));
                }
            }
            if (typeof updatePreview === 'function') updatePreview();
        }
        function applyRaiseSlPercentFromPrice() {
            const base = getRaiseSlBasePrice();
            if (Number.isFinite(base) && base > 0) {
                const price = Number(String(customPriceInput.value || '').trim());
                if (Number.isFinite(price) && price > 0) {
                    const per = (price / base - 1) * 100;
                    perInputCustom.value = String(Number(per.toFixed(1)));
                }
            }
            if (typeof updatePreview === 'function') updatePreview();
        }
        perInputCustom.addEventListener('input', applyRaiseSlPriceFromPercent);
        perInputCustom.addEventListener('change', () => { applyRaiseSlPriceFromPercent(); });
        customPriceInput.addEventListener('input', applyRaiseSlPercentFromPrice);
        customPriceInput.addEventListener('change', () => { applyRaiseSlPercentFromPrice(); });

        // Stock mode: Stock price ($) input
        const customStockWrap = document.createElement('div');
        customStockWrap.dataset.tpRaiseSlStockWrap = '1';
        customStockWrap.style.display = showStockCustom() ? 'block' : 'none';
        customStockWrap.style.marginTop = '8px';
        const stockLabelCustom = document.createElement('label');
        stockLabelCustom.textContent = 'Stock price ($)';
        const customStockInput = document.createElement('input');
        customStockInput.type = 'number';
        customStockInput.step = '0.01';
        customStockInput.min = '0';
        customStockInput.className = 'form-input';
        customStockInput.placeholder = '0.00';
        customStockInput.dataset.tpRaiseSlCustomStock = '1';
        customStockInput.dataset.tpLevel = String(level);
        customStockWrap.appendChild(stockLabelCustom);
        customStockWrap.appendChild(customStockInput);
        customStockInput.addEventListener('input', () => { if (typeof updatePreview === 'function') updatePreview(); });
        customStockInput.addEventListener('change', () => { if (typeof updatePreview === 'function') updatePreview(); });

        perInputCustom.value = defaultRaiseSlCustomPer ? String(defaultRaiseSlCustomPer).trim() : '5';
        if (defaultRaiseSlCustom) customPriceInput.value = String(defaultRaiseSlCustom).trim();
        if (defaultRaiseSlCustomStock) customStockInput.value = String(defaultRaiseSlCustomStock).trim();

        customWrap.appendChild(customPercentWrap);
        customWrap.appendChild(customStockWrap);

        const setRaiseSlValue = (v) => {
            const norm = String(v || '').trim().toLowerCase();
            const allowed = ['off', 'entry', 'break_even', 'custom'];
            const value = (norm === 'break_even' ? 'entry' : (allowed.includes(norm) ? norm : 'off'));
            if (value === '' || value === 'off') raiseSlSelect.value = 'off';
            else raiseSlSelect.value = value;
            if (raiseSlSelect.value === 'custom') customWrap.style.display = 'block';
            else customWrap.style.display = 'none';
        };
        setRaiseSlValue(defaultRaiseSlTo || '');
        raiseSlSelect.addEventListener('change', () => {
            customWrap.style.display = raiseSlSelect.value === 'custom' ? 'block' : 'none';
            if (raiseSlSelect.value === 'custom') applyRaiseSlPriceFromPercent();
            if (typeof updatePreview === 'function') updatePreview();
        });
        raiseSlSelect.addEventListener('input', () => {
            if (typeof updatePreview === 'function') updatePreview();
        });
        actionsPanel.appendChild(actionsLabel);
        actionsPanel.appendChild(raiseSlSelect);
        actionsPanel.appendChild(customWrap);
        rowWrap.appendChild(actionsPanel);
        }

        // --- Percent <-> Price sync (Option price targets) ---
        const tpPerInput = tpGroup.querySelector('input');
        const optPriceInput = priceDisplayInput;
        let isSyncing = false;

        function getOptionBasePrice() {
            const isShares = (findFieldByName('is_shares') && findFieldByName('is_shares').checked) || false;
            const currentPriceEl = findFieldByName('current_price');
            const optionPriceEl = findFieldByName('option_price');
            const entryPriceEl = findFieldByName('entry_price');
            const priceEl = findFieldByName('price');
            const baseRaw = isShares
                ? ((currentPriceEl && currentPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '')
                : ((optionPriceEl && optionPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '');
            const base = Number(String(baseRaw).trim());
            return Number.isFinite(base) ? base : NaN;
        }

        function setInputValue(el, value) {
            if (!el) return;
            el.value = String(value ?? '');
            el.dataset.autoFilled = '1';
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        function syncPriceFromPercent() {
            if (!tpPerInput || !optPriceInput) return;
            const m = String(modeHidden.value || '').trim().toLowerCase();
            if (m !== 'percent') return;
            const base = getOptionBasePrice();
            if (!Number.isFinite(base) || base <= 0) return;
            const per = parsePercent(tpPerInput.value);
            if (!Number.isFinite(per)) return;
            const price = base * (1 + per / 100);
            // Update visible option price + hidden tp{level}_price
            const hiddenPriceEl = findFieldByName(`tp${level}_price`);
            isSyncing = true;
            optPriceInput.value = price.toFixed(2);
            optPriceInput.dataset.autoFilled = '1';
            if (hiddenPriceEl) {
                hiddenPriceEl.value = price.toFixed(2);
                hiddenPriceEl.dataset.autoFilled = '1';
            }
            isSyncing = false;
        }

        function syncPercentFromPrice() {
            if (!tpPerInput || !optPriceInput) return;
            const m = String(modeHidden.value || '').trim().toLowerCase();
            if (m !== 'percent') return;
            const base = getOptionBasePrice();
            if (!Number.isFinite(base) || base <= 0) return;
            const price = Number(String(optPriceInput.value || '').trim());
            if (!Number.isFinite(price)) return;
            const per = ((price / base) - 1) * 100;
            isSyncing = true;
            tpPerInput.value = per.toFixed(1);
            tpPerInput.dataset.autoFilled = '1';
            const hiddenPriceEl = findFieldByName(`tp${level}_price`);
            if (hiddenPriceEl) {
                hiddenPriceEl.value = price.toFixed(2);
                hiddenPriceEl.dataset.autoFilled = '1';
            }
            isSyncing = false;
            updateTpSlPrices();
            updatePreview();
        }

        if (tpPerInput) {
            tpPerInput.addEventListener('input', () => {
                if (isSyncing) return;
                syncPriceFromPercent();
            });
            tpPerInput.addEventListener('change', () => {
                if (isSyncing) return;
                syncPriceFromPercent();
            });
        }
        if (optPriceInput) {
            optPriceInput.addEventListener('input', () => {
                if (isSyncing) return;
                syncPercentFromPrice();
            });
            optPriceInput.addEventListener('change', () => {
                if (isSyncing) return;
                syncPercentFromPrice();
            });
        }

        // Initialize option price from default percent
        syncPriceFromPercent();
        return rowWrap;
    }

    function createSyntheticTradePlanGroup(children) {
        const wrap = document.createElement('div');
        wrap.className = 'sub-card trade-plan-group';
        wrap.dataset.tradePlanGroup = '1';

        const title = document.createElement('div');
        title.style.color = '#e0e0e0';
        title.style.fontSize = '1em';
        title.style.marginBottom = '12px';
        title.style.fontWeight = '600';
        title.textContent = 'üìù Trade Plan';

        wrap.appendChild(title);
        const body = document.createElement('div');
        body.style.display = 'flex';
        body.style.flexDirection = 'column';
        body.style.gap = '12px';

        (children || []).forEach((c) => {
            if (c) body.appendChild(c);
        });
        wrap.appendChild(body);
        return wrap;
    }

    function attachIsSharesToTickerType() {
        if (!tickerTypeToggleSlot || !isSharesPill) return;
        tickerTypeToggleSlot.innerHTML = '';
        tickerTypeToggleSlot.appendChild(isSharesPill);
        // Remove the original container if we rendered it separately first.
        if (isSharesFormGroup && isSharesFormGroup.parentNode) {
            isSharesFormGroup.parentNode.removeChild(isSharesFormGroup);
        }
    }

    variables.forEach(variable => {
        // Check if this variable is used
        // is_shares is a special control variable that should always be visible
        // Also treat 'ticker' with type 'string' as ticker_type for Common Trade Alert compatibility
        const isTickerType = variable.type === 'ticker_type' || (variable.name === 'ticker' && (variable.type === 'string' || variable.type === 'text'));
        const isSpecialControl = variable.name === 'is_shares' || isTickerType;
        const isUsed = usedVariables.has(variable.name) || isSpecialControl;
        const isOptionalOnly = optionalOnlyVariables.has(variable.name);
        
        // Create form group with data attribute for visibility control
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', variable.name);
        // Initially hide if not used (but always show is_shares)
        if (!isUsed) {
            formGroup.style.display = 'none';
        }
        
        const label = document.createElement('label');
        const isRequired = variable.required === true;
        label.textContent = getLabel(variable) + (isRequired ? ' *' : '');
        label.setAttribute('for', `id_${variable.name}`);
        
        let input;
        
        const inputType = getInputType(variable.type);
        
        // Handle select type (dropdown) ‚Äî option_type label/options updated by toggleOptionFields when is_shares toggles
        if (variable.type === 'select' && variable.options) {
            input = document.createElement('select');
            input.className = 'form-select';
            variable.options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                if (variable.default && option === variable.default) {
                    optionElement.selected = true;
                }
                input.appendChild(optionElement);
            });
        } else if (variable.type === 'ticker_select') {
            // If custom options exist, render a select; otherwise use the global US ticker datalist.
            const hasOptions = Array.isArray(variable.options) && variable.options.length > 0;
            if (hasOptions) {
                input = document.createElement('select');
                input.className = 'form-select';
                variable.options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    if (variable.default && option === variable.default) {
                        optionElement.selected = true;
                    }
                    input.appendChild(optionElement);
                });
            } else {
                const control = createTickerSearchControl(variable);
                input = control.input;
                input._tickerSearchWrap = control.wrap;
            }
        } else if (isTickerType) {
            // Searchable input backed by server-side search (avoid loading full ticker universe)
            // Handle both ticker_type and ticker (string/text) for Common Trade Alert compatibility
            const control = createTickerSearchControl(variable);
            input = control.input;
            input._tickerSearchWrap = control.wrap;

            // If the template didn't define an is_shares variable, add the toggle inline by default.
            if (!hasIsSharesVariable && !isSharesPill) {
                const created = createSyntheticIsSharesPill();
                isSharesPill = created.pill;
                // Keep behavior consistent with normal inputs
                created.input.addEventListener('input', updatePreview);
                created.input.addEventListener('change', updatePreview);
            }

            // If template didn't define option fields, add them by default (they'll be hidden when is_shares is true).
            formGroup._afterSyntheticGroups = [];
            // Strike/Expiration are auto-selected; keep them as hidden fields only.
            if (!hasStrikeVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('strike', ''));
            if (!hasExpirationVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('expiration', ''));
            if (!hasOptionTypeVariable) formGroup._afterSyntheticGroups.push(createSyntheticOptionField('option_type'));
            // Add TP/SL inputs grouped under "Trade Plan" behind Option Type.
            // Prices are auto-calculated from option_price and stored in hidden fields for template use.
            const tpContainer = document.createElement('div');
            tpContainer.dataset.requiresOptions = 'true';

        // --- Preset selector row (dropdown) ---
        const presetBar = document.createElement('div');
        presetBar.style.display = 'flex';
        presetBar.style.flexWrap = 'wrap';
        presetBar.style.alignItems = 'center';
        presetBar.style.gap = '10px';
        presetBar.style.marginBottom = '14px';

        const presetLabel = document.createElement('div');
        presetLabel.style.color = '#9ca3af';
        presetLabel.style.fontSize = '0.9em';
        presetLabel.style.fontWeight = '600';
        presetLabel.textContent = 'Saved Plans';

        const presetSelect = document.createElement('select');
        presetSelect.className = 'form-select';
        presetSelect.style.width = 'auto';
        presetSelect.style.minWidth = '220px';

        const savePresetBtn = document.createElement('button');
        savePresetBtn.type = 'button';
        savePresetBtn.textContent = 'Save';
        savePresetBtn.className = 'btn-cancel';
        savePresetBtn.style.padding = '8px 10px';
        savePresetBtn.style.fontSize = '0.85em';
        savePresetBtn.style.width = 'auto';
        savePresetBtn.style.borderRadius = '10px';

        const saveAsPresetBtn = document.createElement('button');
        saveAsPresetBtn.type = 'button';
        saveAsPresetBtn.textContent = 'Save As';
        saveAsPresetBtn.className = 'btn-submit';
        saveAsPresetBtn.style.padding = '8px 10px';
        saveAsPresetBtn.style.fontSize = '0.85em';
        saveAsPresetBtn.style.width = 'auto';
        saveAsPresetBtn.style.borderRadius = '10px';

        const deletePresetBtn = document.createElement('button');
        deletePresetBtn.type = 'button';
        deletePresetBtn.textContent = 'Delete';
        deletePresetBtn.className = 'btn-cancel';
        deletePresetBtn.style.padding = '8px 10px';
        deletePresetBtn.style.fontSize = '0.85em';
        deletePresetBtn.style.width = 'auto';
        deletePresetBtn.style.borderRadius = '10px';
        deletePresetBtn.style.opacity = '0.85';

        const defaultPresetBtn = document.createElement('button');
        defaultPresetBtn.type = 'button';
        defaultPresetBtn.textContent = 'Set as Default';
        defaultPresetBtn.className = 'btn-cancel';
        defaultPresetBtn.style.padding = '8px 10px';
        defaultPresetBtn.style.fontSize = '0.85em';
        defaultPresetBtn.style.width = 'auto';
        defaultPresetBtn.style.borderRadius = '10px';
        defaultPresetBtn.style.opacity = '0.85';

        presetBar.appendChild(presetLabel);
        presetBar.appendChild(presetSelect);

            const tpHeader = document.createElement('div');
            tpHeader.style.display = 'flex';
            tpHeader.style.alignItems = 'center';
            tpHeader.style.justifyContent = 'space-between';
            tpHeader.style.gap = '12px';

            const tpTitle = document.createElement('div');
            tpTitle.style.color = '#9ca3af';
            tpTitle.style.fontSize = '0.95em';
            tpTitle.style.fontWeight = '600';
            tpTitle.textContent = 'Take Profit Levels';

            // One Target Type selector for ALL TP levels
            let globalTpMode = 'percent';

            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.textContent = 'Add Take Profit';
            addBtn.className = 'btn-submit';
            addBtn.style.padding = '8px 10px';
            addBtn.style.fontSize = '0.85em';
            addBtn.style.width = 'auto';
            addBtn.style.borderRadius = '10px';

            tpHeader.appendChild(tpTitle);
            const rightBtns = document.createElement('div');
            rightBtns.style.display = 'flex';
            rightBtns.style.gap = '8px';

            const globalModeWrap = document.createElement('div');
            globalModeWrap.style.display = 'flex';
            globalModeWrap.style.alignItems = 'center';
            globalModeWrap.style.gap = '8px';

            const globalModeLabel = document.createElement('span');
            globalModeLabel.textContent = 'Target Type';
            globalModeLabel.style.color = '#9ca3af';
            globalModeLabel.style.fontSize = '0.85em';
            globalModeLabel.style.fontWeight = '600';
            globalModeLabel.style.whiteSpace = 'nowrap';

            const globalModeSelect = document.createElement('select');
            globalModeSelect.className = 'form-select tp-target-type-select';
            globalModeSelect.dataset.tpTargetTypeSelect = '1';
            globalModeSelect.style.width = 'auto';
            globalModeSelect.style.minWidth = '170px';
            globalModeSelect.style.padding = '8px 10px';
            globalModeSelect.style.fontSize = '0.9em';
            [
                { value: 'percent', text: '% based (Option)' },
                { value: 'stock', text: 'Stock price ($)' },
            ].forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt.value;
                o.textContent = opt.text;
                globalModeSelect.appendChild(o);
            });

            globalModeWrap.appendChild(globalModeLabel);
            globalModeWrap.appendChild(globalModeSelect);
            rightBtns.appendChild(globalModeWrap);
            rightBtns.appendChild(addBtn);
            tpHeader.appendChild(rightBtns);
        tpContainer.appendChild(presetBar);
            tpContainer.appendChild(tpHeader);

            const tpRows = document.createElement('div');
            tpRows.style.display = 'flex';
            tpRows.style.flexDirection = 'column';
            tpRows.style.gap = '10px';
            tpRows.style.marginTop = '10px';
            tpContainer.appendChild(tpRows);

            const tpHiddenHolder = document.createElement('div');
            tpHiddenHolder.style.display = 'none';
            tpContainer.appendChild(tpHiddenHolder);

            const ensureTpPriceHidden = (lvl) => {
                const existing = findFieldByName(`tp${lvl}_price`);
                if (existing) return;
                const hiddenGroup = createSyntheticHiddenField(`tp${lvl}_price`, '0.00');
                tpHiddenHolder.appendChild(hiddenGroup);
            };

            const removeTpPriceHidden = (lvl) => {
                const priceGroup = document.querySelector(
                    `#dynamicFields [data-variable-name="tp${lvl}_price"], #optionalFieldsVariablesContainer [data-variable-name="tp${lvl}_price"]`
                );
                if (priceGroup && priceGroup.parentElement) priceGroup.parentElement.removeChild(priceGroup);
            };

            const readTpState = () => {
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                return rows.map((r) => {
                    const lvl = Number(r.dataset.tpLevel || '');
                    const per = findFieldByName(`tp${lvl}_per`)?.value ?? '';
                    const takeoff = findFieldByName(`tp${lvl}_takeoff_per`)?.value ?? '';
                    const stock_price = findFieldByName(`tp${lvl}_stock_price`)?.value ?? '';
                    const raiseSlSelect = r.querySelector('[data-tp-raise-sl-to]');
                    const raiseSlCustomPer = r.querySelector('[data-tp-raise-sl-custom-per]');
                    const raiseSlCustom = r.querySelector('[data-tp-raise-sl-custom]');
                    const raiseSlCustomStock = r.querySelector('[data-tp-raise-sl-custom-stock]');
                    const raise_sl_to = raiseSlSelect ? String(raiseSlSelect.value || '').trim() : '';
                    const raise_sl_custom_per = raiseSlCustomPer ? String(raiseSlCustomPer.value || '').trim() : '';
                    const raise_sl_custom = raiseSlCustom ? String(raiseSlCustom.value || '').trim() : '';
                    const raise_sl_custom_stock = raiseSlCustomStock ? String(raiseSlCustomStock.value || '').trim() : '';
                    return { per: String(per), takeoff: String(takeoff), stock_price: String(stock_price).trim(), raise_sl_to, raise_sl_custom, raise_sl_custom_per, raise_sl_custom_stock };
                });
            };

            function applyGlobalTpModeToRows() {
                globalTpMode = (globalModeSelect.value === 'stock' || globalModeSelect.value === 'stock_price') ? 'stock' : 'percent';
                globalModeSelect.value = globalTpMode;
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                rows.forEach((r) => {
                    const modeEl = r.querySelector('input[name^="tp"][name$="_mode"]');
                    if (modeEl) modeEl.value = globalTpMode;
                    const percentCol = r.querySelector('[data-tp-percent-col]');
                    const stockCol = r.querySelector('[data-tp-stock-col]');
                    if (percentCol) percentCol.style.display = globalTpMode === 'percent' ? '' : 'none';
                    if (stockCol) stockCol.style.display = globalTpMode === 'stock' ? '' : 'none';
                    const percentWrap = r.querySelector('[data-tp-raise-sl-percent-wrap]');
                    const stockWrap = r.querySelector('[data-tp-raise-sl-stock-wrap]');
                    if (percentWrap) percentWrap.style.display = globalTpMode === 'percent' ? 'block' : 'none';
                    if (stockWrap) stockWrap.style.display = globalTpMode === 'stock' ? 'block' : 'none';
                });
                updateDefaultTpStockTargets();
                updateTpSlPrices();
                updatePreview();
            }

            const renderTpRows = (state) => {
                tpRows.innerHTML = '';
                const s = Array.isArray(state) ? state : [];
                // On add/remove, normalize: last TP takes 100%, all others 50%.
                const normalizedTakeoffFor = (lvl, total) => (lvl === total ? 100 : 50);
                s.forEach((it, idx) => {
                    const lvl = idx + 1;
                    ensureTpPriceHidden(lvl);
                    const perRaw = String(it?.per ?? '').trim();
                    const perNum = Number(perRaw);
                    const perVal = Number.isFinite(perNum) ? perNum : (lvl * 10);
                    const takeoffVal = normalizedTakeoffFor(lvl, s.length);
                    const stockPriceRaw = String(it?.stock_price ?? it?.stockPrice ?? '').trim();
                    let raiseSlTo = String(it?.raise_sl_to ?? '').trim();
                    if (!raiseSlTo) raiseSlTo = (lvl === 1) ? 'entry' : 'off';
                    const raiseSlCustom = String(it?.raise_sl_custom ?? '').trim();
                    const raiseSlCustomPer = String(it?.raise_sl_custom_per ?? '').trim();
                    const raiseSlCustomStock = String(it?.raise_sl_custom_stock ?? '').trim();
                    const isLastLevel = (lvl === s.length);
                    const rowEl = createTakeProfitRow(lvl, perVal, takeoffVal, { defaultMode: globalTpMode, defaultStockPrice: stockPriceRaw, defaultRaiseSlTo: raiseSlTo, defaultRaiseSlCustom: raiseSlCustom, defaultRaiseSlCustomPer: raiseSlCustomPer, defaultRaiseSlCustomStock: raiseSlCustomStock, isLastLevel });
                    // Wire remove: allowed for TP2+; removing reindexes rows so tp1/tp2/... stay stable.
                    const btn = rowEl.querySelector('.tp-level-row-header .tp-remove-btn');
                    if (btn) {
                        btn.addEventListener('click', () => {
                            if (lvl <= 1) return;
                            const current = readTpState();
                            if (current.length <= 1) return;
                            current.splice(lvl - 1, 1);
                            removeTpPriceHidden(current.length + 1); // remove old highest tp_price
                            renderTpRows(current);
                        });
                    }
                    tpRows.appendChild(rowEl);
                });
                refreshTpRemoveButtons();
                applyGlobalTpModeToRows();
            };

            globalModeSelect.addEventListener('change', () => {
                applyGlobalTpModeToRows();
            });

            const refreshTpRemoveButtons = () => {
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                rows.forEach((r) => {
                    const b = r.querySelector('.tp-level-row-header .tp-remove-btn');
                    if (!b) return;
                    // Show remove on all rows except TP1
                    const lvl = Number(r.dataset.tpLevel || '');
                    b.style.display = (lvl > 1) ? 'inline-flex' : 'none';
                });
                addBtn.disabled = rows.length >= MAX_TP_LEVELS;
                addBtn.style.opacity = addBtn.disabled ? '0.6' : '1';
            };

            addBtn.addEventListener('click', () => {
                const state = readTpState();
                const next = state.length + 1;
                if (next > MAX_TP_LEVELS) return;
                // Leave takeoff empty so defaults apply; last TP will be 100%.
                state.push({ per: String(next * 10), takeoff: '' });
                renderTpRows(state);
                updateTpSlPrices();
            });

            // Prefill from selected preset if present; otherwise defaults.
            const defaultTp = [{ per: '10', takeoff: '50' }, { per: '20', takeoff: '50' }, { per: '30', takeoff: '100' }];
            const defaultSl = 10;
            const initialPreset = getInitialTradePlanPreset();
            const initialPlan = (initialPreset && typeof initialPreset === 'object') ? (initialPreset.plan || {}) : {};
            const initialTp = Array.isArray(initialPlan?.tp_levels) && initialPlan.tp_levels.length ? initialPlan.tp_levels : defaultTp;
            const initialSlNum = Number(String(initialPlan?.sl_per ?? '').trim());
            const initialSl = Number.isFinite(initialSlNum) && initialSlNum > 0 ? initialSlNum : defaultSl;

            // Initial TP rows (from saved plan or defaults)
            renderTpRows(initialTp);
            updateTpSlPrices();

            const slGroup = createSyntheticPercentField('sl_per', initialSl, 'Stop Loss', { showPercentSuffix: true });
            
            // Add visible stop loss price input field (for direct price entry with precision)
            const slPriceGroup = createSyntheticPriceField('sl_price_visible', '', 'Stop Loss Price ($)', { showDollarPrefix: true });
            const slPriceVisibleInput = slPriceGroup.querySelector('input[name="sl_price_visible"]');
            if (slPriceVisibleInput) {
                slPriceVisibleInput.step = '0.01'; // Allow 2 decimal places for precise stops
                slPriceVisibleInput.placeholder = '0.00';
                // Sync with hidden sl_price field
                const slPriceHidden = findFieldByName('sl_price');
                if (slPriceHidden && slPriceHidden.value && slPriceHidden.value !== '0.00') {
                    slPriceVisibleInput.value = slPriceHidden.value;
                }
                slPriceVisibleInput.addEventListener('input', function() {
                    const val = this.value;
                    if (slPriceHidden) slPriceHidden.value = val || '0.00';
                    updatePreview();
                });
                slPriceVisibleInput.addEventListener('change', function() {
                    const val = this.value;
                    if (slPriceHidden) slPriceHidden.value = val || '0.00';
                    updatePreview();
                });
            }
            
            // Add support for multiple stop loss levels (array)
            const slLevelsGroup = document.createElement('div');
            slLevelsGroup.className = 'form-group';
            slLevelsGroup.setAttribute('data-variable-name', 'sl_levels');
            const slLevelsLabel = document.createElement('label');
            slLevelsLabel.textContent = 'Stop Loss Levels ($)';
            slLevelsLabel.setAttribute('for', 'id_sl_levels');
            const slLevelsInput = document.createElement('input');
            slLevelsInput.type = 'text';
            slLevelsInput.className = 'form-input';
            slLevelsInput.id = 'id_sl_levels';
            slLevelsInput.name = 'sl_levels';
            slLevelsInput.placeholder = 'e.g., 96; 89; 86';
            slLevelsInput.title = 'Enter multiple stop loss levels separated by semicolons (e.g., $96; $89; $86)';
            slLevelsGroup.appendChild(slLevelsLabel);
            slLevelsGroup.appendChild(slLevelsInput);
            slLevelsInput.addEventListener('input', updatePreview);
            slLevelsInput.addEventListener('change', updatePreview);
            
            // Add Time Horizon field (for leaps/swings only; date selection, under Stop Loss in Trade Plan)
            const timeHorizonGroup = document.createElement('div');
            timeHorizonGroup.className = 'form-group';
            timeHorizonGroup.setAttribute('data-variable-name', 'time_horizon');
            timeHorizonGroup.setAttribute('data-show-for-trade-type', 'swing,leap');
            const timeHorizonLabel = document.createElement('label');
            timeHorizonLabel.textContent = 'Time Horizon';
            timeHorizonLabel.setAttribute('for', 'id_time_horizon');
            const timeHorizonInput = document.createElement('input');
            timeHorizonInput.type = 'date';
            timeHorizonInput.className = 'form-input';
            timeHorizonInput.id = 'id_time_horizon';
            timeHorizonInput.name = 'time_horizon';
            timeHorizonInput.min = getTodayISODate();
            timeHorizonInput.title = 'How long you expect for this trade to play out. Options: expiration date. Stock + Leap: 6 months. Stock + Swing: 1 week.';
            timeHorizonGroup.appendChild(timeHorizonLabel);
            timeHorizonGroup.appendChild(timeHorizonInput);
            timeHorizonInput.addEventListener('input', updatePreview);
            timeHorizonInput.addEventListener('change', updatePreview);
            // Set default when field is first created (Swing/Leap visible): option = expiration, stock Leap = 6mo, stock Swing = 1wk
            setTimeHorizonDefault();

            // Action buttons row (goes at the end of the Trade Plan panel)
            const presetActionsBar = document.createElement('div');
            presetActionsBar.style.display = 'flex';
            presetActionsBar.style.justifyContent = 'flex-end';
            presetActionsBar.style.gap = '10px';
            presetActionsBar.style.marginTop = '6px';
            presetActionsBar.appendChild(savePresetBtn);
            presetActionsBar.appendChild(saveAsPresetBtn);
            presetActionsBar.appendChild(defaultPresetBtn);
            presetActionsBar.appendChild(deletePresetBtn);

            const LIVE_CUSTOM_VALUE = '__live_custom__';
            let selectedPresetId = initialPreset ? String(initialPreset.id) : ''; // DB id (only when a saved plan is selected)
            let selectedPresetName = initialPreset ? String(initialPreset.name || 'Default') : '';
            // What the dropdown currently shows as selected
            let selectedPresetValue = selectedPresetId || (tradePlanPresets.length ? '' : LIVE_CUSTOM_VALUE);

            function setLiveCustomMode({ reset = true } = {}) {
                selectedPresetId = '';
                selectedPresetName = '';
                selectedPresetValue = LIVE_CUSTOM_VALUE;
                // In Live Custom there is no saved preset selected, so disable actions that require an id.
                // (Save As remains available.)
                savePresetBtn.disabled = true;
                deletePresetBtn.disabled = true;
                defaultPresetBtn.disabled = true;

                if (reset) {
                    renderTpRows(defaultTp);
                    applyGlobalTpModeToRows();
                    updateDefaultTpStockTargets(); // show default stock targets in Stock price mode (even if price is 0)
                    const slEl = findFieldByName('sl_per');
                    if (slEl) {
                        slEl.value = String(defaultSl);
                        slEl.dataset.autoFilled = '1';
                        delete slEl.dataset.userTouched;
                        slEl.dispatchEvent(new Event('input', { bubbles: true }));
                        slEl.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                    updateTpSlPrices();
                    updatePreview();
                }
            }

            function rebuildPresetSelect() {
                presetSelect.innerHTML = '';
                const none = document.createElement('option');
                none.value = '';
                none.textContent = '‚Äî Select a saved plan ‚Äî';
                presetSelect.appendChild(none);

                tradePlanPresets.forEach((p) => {
                    if (!p || p.id == null) return;
                    const opt = document.createElement('option');
                    opt.value = String(p.id);
                    opt.textContent = `${p.is_default ? '‚òÖ ' : ''}${String(p.name || 'Untitled')}`;
                    presetSelect.appendChild(opt);
                });

                // Put Live Custom at the end of the list
                const live = document.createElement('option');
                live.value = LIVE_CUSTOM_VALUE;
                live.textContent = 'Live Custom';
                presetSelect.appendChild(live);
                presetSelect.value = selectedPresetValue || '';
                deletePresetBtn.disabled = !selectedPresetId;
                defaultPresetBtn.disabled = !selectedPresetId;
            }

            function applyPresetById(id) {
                const pid = String(id || '');
                selectedPresetId = pid;
                selectedPresetValue = pid;
                const p = tradePlanPresets.find(x => x && String(x.id) === pid) || null;
                deletePresetBtn.disabled = !p;
                defaultPresetBtn.disabled = !p;
                if (!p) return;
                selectedPresetName = String(p.name || '');
                const plan = (p.plan && typeof p.plan === 'object') ? p.plan : {};
                const tp = Array.isArray(plan.tp_levels) && plan.tp_levels.length ? plan.tp_levels : defaultTp;
                const slNum = Number(String(plan.sl_per ?? '').trim());
                const slVal = Number.isFinite(slNum) && slNum > 0 ? slNum : defaultSl;
                const planMode = String(plan.tp_mode ?? '').trim().toLowerCase();
                if (planMode === 'stock' || planMode === 'stock_price') {
                    globalTpMode = 'stock';
                    globalModeSelect.value = 'stock';
                } else {
                    globalTpMode = 'percent';
                    globalModeSelect.value = 'percent';
                }
                renderTpRows(tp);
                updateTpSlPrices();
                const slEl = findFieldByName('sl_per');
                if (slEl) {
                    slEl.value = String(slVal);
                    slEl.dataset.autoFilled = '1';
                    delete slEl.dataset.userTouched;
                    slEl.dispatchEvent(new Event('input', { bubbles: true }));
                    slEl.dispatchEvent(new Event('change', { bubbles: true }));
                }
                updateTpSlPrices();
                updatePreview();
            }

            rebuildPresetSelect();
            // If there are no saved presets, default to Live Custom.
            if (!tradePlanPresets.length && !selectedPresetId) {
                setLiveCustomMode({ reset: false });
            }
            presetSelect.value = selectedPresetValue || '';

            presetSelect.addEventListener('change', () => {
                const v = String(presetSelect.value || '');
                if (!v) {
                    selectedPresetId = '';
                    selectedPresetName = '';
                    selectedPresetValue = '';
                    // No preset selected: allow Save (will create a new preset), disable id-only actions.
                    savePresetBtn.disabled = false;
                    deletePresetBtn.disabled = true;
                    defaultPresetBtn.disabled = true;
                    return;
                }
                if (v === LIVE_CUSTOM_VALUE) {
                    setLiveCustomMode({ reset: true });
                    return;
                }
                applyPresetById(v);
                // Saved preset selected: enable Save.
                savePresetBtn.disabled = false;
            });

            function currentPlanPayload() {
                return {
                    version: 1,
                    tp_mode: globalTpMode,
                    tp_levels: readTpState(),
                    sl_per: String(findFieldByName('sl_per')?.value ?? '').trim(),
                };
            }

            async function refreshPresetsFromServer() {
                // Avoid stale cached responses after create/delete/default changes
                const url = `/api/trade-plan/?_ts=${Date.now()}`;
                const res = await fetch(url, { credentials: 'same-origin', cache: 'no-store' });
                const data = await res.json().catch(() => ({}));
                if (res.ok && Array.isArray(data?.plans)) {
                    tradePlanPresets = data.plans;
                }
            }

            async function refreshPresetsAndUpdateDropdown() {
                await refreshPresetsFromServer();

                // If the selected preset was deleted, clear selection.
                if (selectedPresetValue === LIVE_CUSTOM_VALUE) {
                    // Stay in Live Custom mode.
                    selectedPresetId = '';
                    selectedPresetName = '';
                    savePresetBtn.disabled = true;
                } else {
                    const hasSelected = selectedPresetId && tradePlanPresets.some(p => p && String(p.id) === String(selectedPresetId));
                    if (!hasSelected) {
                        selectedPresetId = '';
                        selectedPresetName = '';
                        selectedPresetValue = tradePlanPresets.length ? '' : LIVE_CUSTOM_VALUE;
                        savePresetBtn.disabled = (selectedPresetValue === LIVE_CUSTOM_VALUE);
                    } else {
                        const p = tradePlanPresets.find(x => x && String(x.id) === String(selectedPresetId));
                        if (p) selectedPresetName = String(p.name || '');
                        selectedPresetValue = String(selectedPresetId);
                        savePresetBtn.disabled = false;
                    }
                }

                rebuildPresetSelect();
                presetSelect.value = selectedPresetValue || '';
                deletePresetBtn.disabled = !selectedPresetId;
                defaultPresetBtn.disabled = !selectedPresetId;
            }

            function ensureTradePlanNameModal() {
                let overlay = document.getElementById('ctpNameModalOverlay');
                if (overlay) return overlay;

                overlay = document.createElement('div');
                overlay.id = 'ctpNameModalOverlay';
                overlay.className = 'ctp-modal-overlay';
                overlay.innerHTML = `
                    <div class="ctp-modal" role="dialog" aria-modal="true" aria-labelledby="ctpNameModalTitle">
                        <div class="ctp-modal-title" id="ctpNameModalTitle">Name your Trade Plan</div>
                        <div class="ctp-modal-subtitle" id="ctpNameModalSubtitle">Enter a name to save this plan.</div>
                        <div class="form-group" style="margin: 0;">
                            <label for="ctpNameModalInput" style="margin-bottom: 8px;">Plan name</label>
                            <input id="ctpNameModalInput" class="form-input" type="text" placeholder="e.g., Swing Default" />
                            <div class="ctp-modal-error" id="ctpNameModalError">Name is required.</div>
                        </div>
                        <div class="ctp-modal-actions">
                            <button type="button" class="btn-cancel" id="ctpNameModalCancel">Cancel</button>
                            <button type="button" class="btn-submit" id="ctpNameModalSave">Save</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlay);
                return overlay;
            }

            function showTradePlanNameModal({ title = 'Name your Trade Plan', subtitle = 'Enter a name to save this plan.', initialValue = '' } = {}) {
                return new Promise((resolve) => {
                    const overlay = ensureTradePlanNameModal();
                    const titleEl = overlay.querySelector('#ctpNameModalTitle');
                    const subEl = overlay.querySelector('#ctpNameModalSubtitle');
                    const input = overlay.querySelector('#ctpNameModalInput');
                    const err = overlay.querySelector('#ctpNameModalError');
                    const btnCancel = overlay.querySelector('#ctpNameModalCancel');
                    const btnSave = overlay.querySelector('#ctpNameModalSave');

                    const close = (val) => {
                        overlay.classList.remove('open');
                        overlay.style.display = '';
                        cleanup();
                        resolve(val);
                    };

                    const showError = (msg) => {
                        if (!err) return;
                        err.textContent = msg || 'Name is required.';
                        err.classList.add('show');
                    };

                    const clearError = () => {
                        if (!err) return;
                        err.classList.remove('show');
                    };

                    const onOverlayClick = (e) => {
                        // click outside closes (cancel)
                        if (e.target === overlay) close('');
                    };

                    const onCancel = () => close('');

                    const onSave = () => {
                        const name = String(input?.value ?? '').trim();
                        if (!name) {
                            showError('Please enter a plan name.');
                            try { input?.focus(); } catch (_) {}
                            return;
                        }
                        close(name);
                    };

                    const onKeyDown = (e) => {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            close('');
                        } else if (e.key === 'Enter') {
                            // Enter submits when focus is in the input
                            if (document.activeElement === input) {
                                e.preventDefault();
                                onSave();
                            }
                        }
                    };

                    const cleanup = () => {
                        overlay.removeEventListener('click', onOverlayClick);
                        btnCancel?.removeEventListener('click', onCancel);
                        btnSave?.removeEventListener('click', onSave);
                        document.removeEventListener('keydown', onKeyDown);
                    };

                    if (titleEl) titleEl.textContent = title;
                    if (subEl) subEl.textContent = subtitle;
                    if (input) input.value = String(initialValue ?? '');
                    clearError();

                    overlay.classList.add('open');
                    overlay.addEventListener('click', onOverlayClick);
                    btnCancel?.addEventListener('click', onCancel);
                    btnSave?.addEventListener('click', onSave);
                    document.addEventListener('keydown', onKeyDown);

                    // Focus
                    setTimeout(() => {
                        try { input?.focus(); input?.select?.(); } catch (_) {}
                    }, 0);
                });
            }

            savePresetBtn.addEventListener('click', async () => {
                try {
                    savePresetBtn.disabled = true;
                    const prev = savePresetBtn.textContent;
                    savePresetBtn.textContent = 'Saving...';
                    let name = String(selectedPresetName || '').trim();
                    // If we're creating new (no selected preset), prompt user to set the plan name.
                    if (!selectedPresetId) {
                        const picked = await showTradePlanNameModal({
                            title: 'Name your Trade Plan',
                            subtitle: 'Enter a name to save this plan.',
                            initialValue: name || 'Default',
                        });
                        if (!picked) {
                            savePresetBtn.textContent = prev;
                            return;
                        }
                        name = picked;
                        selectedPresetName = name;
                    }
                    const plan = currentPlanPayload();
                    let resp;
                    if (selectedPresetId) {
                        // Keep existing name when updating (no name input in UI).
                        resp = await tradePlanApi({ action: 'update', id: selectedPresetId, name, plan });
                    } else {
                        resp = await tradePlanApi({ action: 'create', name, plan, set_default: false });
                        selectedPresetId = String(resp?.preset?.id || '');
                        selectedPresetName = String(resp?.preset?.name || name);
                        selectedPresetValue = selectedPresetId || LIVE_CUSTOM_VALUE;
                    }
                    await refreshPresetsAndUpdateDropdown();
                    savePresetBtn.textContent = 'Saved';
                    setTimeout(() => { savePresetBtn.textContent = prev; }, 800);
                } catch (e) {
                    console.warn('Save preset failed:', e);
                    savePresetBtn.textContent = 'Save failed';
                    setTimeout(() => { savePresetBtn.textContent = 'Save'; }, 1200);
                } finally {
                    savePresetBtn.disabled = false;
                }
            });

            saveAsPresetBtn.addEventListener('click', async () => {
                try {
                    saveAsPresetBtn.disabled = true;
                    const prev = saveAsPresetBtn.textContent;
                    saveAsPresetBtn.textContent = 'Saving...';
                    // Save As always asks for a name (easy to create many presets quickly).
                    const picked = await showTradePlanNameModal({
                        title: 'Save Trade Plan As',
                        subtitle: 'Choose a name for the new saved plan.',
                        initialValue: '',
                    });
                    if (!picked) {
                        saveAsPresetBtn.textContent = prev;
                        return;
                    }
                    const name = picked;
                    const plan = currentPlanPayload();
                    const resp = await tradePlanApi({ action: 'create', name, plan, set_default: false });
                    const newId = resp?.preset?.id;
                    if (newId != null) {
                        try { sessionStorage.setItem('ctp_selected_preset_id', String(newId)); } catch (_) {}
                    }
                    // Full rerender so Saved Plans list reflects new preset everywhere.
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Save As preset failed:', e);
                    saveAsPresetBtn.textContent = 'Save failed';
                    setTimeout(() => { saveAsPresetBtn.textContent = 'Save As'; }, 1200);
                } finally {
                    saveAsPresetBtn.disabled = false;
                }
            });

            defaultPresetBtn.addEventListener('click', async () => {
                if (!selectedPresetId) return;
                try {
                    defaultPresetBtn.disabled = true;
                    const prev = defaultPresetBtn.textContent;
                    defaultPresetBtn.textContent = 'Setting...';
                    await tradePlanApi({ action: 'set_default', id: selectedPresetId });
                    // Full rerender so ‚òÖ default marker updates everywhere.
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Set default preset failed:', e);
                    defaultPresetBtn.textContent = 'Failed';
                    setTimeout(() => { defaultPresetBtn.textContent = 'Set as Default'; }, 1200);
                } finally {
                    defaultPresetBtn.disabled = !selectedPresetId;
                }
            });

            deletePresetBtn.addEventListener('click', async () => {
                if (!selectedPresetId) return;
                try {
                    const idToDelete = String(selectedPresetId);
                    deletePresetBtn.disabled = true;
                    await tradePlanApi({ action: 'delete', id: selectedPresetId });
                    // Full rerender to reflect the latest server state everywhere.
                    // (Ensures Saved Plans dropdown + default markers stay consistent.)
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Delete preset failed:', e);
                } finally {
                    deletePresetBtn.disabled = !selectedPresetId;
                    defaultPresetBtn.disabled = !selectedPresetId;
                }
            });

            const tradePlanChildren = [
                tpContainer,
                slGroup,
                slPriceGroup,
                slLevelsGroup,
                timeHorizonGroup,
                presetActionsBar,
                createSyntheticHiddenField('sl_price', '0.00'),
                createSyntheticHiddenField('sl_levels', ''),
            ];
            formGroup._afterSyntheticGroups.push(createSyntheticTradePlanGroup(tradePlanChildren));
            // Ensure option_price is present in submitted JSON even if not defined in variables.
            if (!hasOptionPriceVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('option_price', '0.00'));
            if (!hasOptionContractVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('option_contract', ''));

        } else {
            if (inputType === 'textarea') {
                input = document.createElement('textarea');
                input.className = 'form-textarea';
                input.rows = variable.name === 'risk_management' ? 5 : 3;
                if (variable.name === 'risk_management') {
                    input.placeholder = 'Enter Risk Management (e.g. position size, 0DTE rules, due diligence)';
                }
            } else if (inputType === 'file') {
                input = document.createElement('input');
                input.type = 'file';
                input.className = 'form-input';
                input.accept = 'image/*,video/*';
                input.setAttribute('data-ignore-dynamic', '1'); // Excluded from signalData JSON
            } else if (inputType === 'checkbox') {
                // Handle boolean/checkbox (special-case is_shares later for switch UI)
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-checkbox';
                input.checked = variable.default || false;
            } else {
                input = document.createElement('input');
                input.className = 'form-input';
                input.type = inputType;
                
                // For float inputs, add step attribute to allow decimals
                if (variable.type === 'float') {
                    input.step = '0.01';
                }
                
                // Add placeholders
                const placeholders = {
                    'ticker': 'Enter ticker (e.g., AAPL, TSLA)',
                    'strike': 'Enter strike price (e.g., 150.50)',
                    'expiration': 'Enter expiration date (e.g., 2025-11-20)',
                    'price': 'Enter price (e.g., 1.25)',
                    'entry_price': 'Enter entry price (e.g., 1.25)',
                    'exit_price': 'Enter exit price (e.g., 1.50)',
                    'pnl_percent': 'Enter P&L % (e.g., 20.5)'
                };
                input.placeholder = placeholders[variable.name] || '';
            }
        }
        
        input.id = `id_${variable.name}`;
        input.name = variable.name;

        // Allow auto-filling option_price even if it starts at the default "0.0"
        if (variable.name === 'option_price') {
            const v = String(input.value || '').trim();
            if (v === '' || v === '0.0') {
                input.dataset.autoFilled = '1';
            }
        }

        // Expiration: default to today and disallow past dates
        if (variable.name === 'expiration' && input && input.type === 'date') {
            const today = getTodayISODate();
            input.min = today;
            if (!input.value) input.value = today;
        }
        
        // Add HTML5 required attribute if field is required
        if (isRequired) {
            input.required = true;
            // Store that it was originally required for restoration
            input.setAttribute('data-originally-required', 'true');
        }
        
        // Add hint as placeholder if provided (overrides default placeholders)
        if (variable.hint && input.type !== 'checkbox') {
            input.placeholder = variable.hint;
        }
        
        // Add data attribute for conditional visibility based on is_shares
        if (variable.name === 'strike' || variable.name === 'expiration' || variable.name === 'option_type') {
            formGroup.setAttribute('data-requires-options', 'true');
        }

        // Strike/Expiration are auto-selected (best-option) and should not be user-editable.
        if (variable.name === 'strike' || variable.name === 'expiration') {
            formGroup.style.display = 'none';
            // Avoid HTML5 required blocking submission; we still enforce via server-side + data JSON.
            if (input) input.required = false;
            if (input) input.dataset.autoFilled = '1';
        }
        
        // Special: render is_shares as a modern toggle switch pill (like screenshot)
        if ((variable.type === 'boolean' || inputType === 'checkbox') && variable.name === 'is_shares') {
            const pill = document.createElement('div');
            pill.className = 'toggle-pill';

            const switchWrap = document.createElement('label');
            switchWrap.className = 'toggle-switch';

            // ensure id/name match existing logic
            input.id = `id_${variable.name}`;
            input.name = variable.name;

            const slider = document.createElement('span');
            slider.className = 'toggle-slider';

            switchWrap.appendChild(input);
            switchWrap.appendChild(slider);

            const text = document.createElement('div');
            text.className = 'toggle-label';
            text.textContent = (variable.label || 'Is_Shares') + ' (Disable Options fields)';

            pill.appendChild(switchWrap);
            pill.appendChild(text);

            isSharesPill = pill;
            isSharesFormGroup = formGroup;

            // If ticker_type exists, embed this toggle inline next to it; otherwise fall back to normal placement.
            if (tickerTypeToggleSlot) {
                attachIsSharesToTickerType();
            } else {
                // Don't use the normal label for this one
                formGroup.appendChild(pill);
            }
        } else if (variable.type === 'boolean' || inputType === 'checkbox') {
            // Regular checkbox booleans
            formGroup.classList.add('checkbox-group');
            formGroup.appendChild(input);
            formGroup.appendChild(label);
        } else {
            formGroup.appendChild(label);
            // For ticker search inputs we created an extra wrapper; append it instead of the raw input.
            if (input && input._tickerSearchWrap) {
                // If this is ticker_type (or ticker with string/text type), render a row that can host the is_shares toggle inline.
                if (isTickerType) {
                    const row = document.createElement('div');
                    row.className = 'ticker-type-row';
                    row.appendChild(input._tickerSearchWrap);
                    const slot = document.createElement('div');
                    slot.className = 'ticker-type-toggle-slot';
                    row.appendChild(slot);
                    formGroup.appendChild(row);
                    tickerTypeToggleSlot = slot;
                    attachIsSharesToTickerType();
                } else {
                    formGroup.appendChild(input._tickerSearchWrap);
                }
            } else {
                formGroup.appendChild(input);
            }
        }
        
        // Place in appropriate container based on whether it's optional-only and visible
        // is_shares should always stay in main container, never in optional container
        const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');
        if (isUsed && isOptionalOnly && optionalFieldsVariablesContainer && !isSpecialControl) {
            optionalFieldsVariablesContainer.appendChild(formGroup);
        } else {
            dynamicFieldsContainer.appendChild(formGroup);
        }

        // Insert any synthetic option fields (strike/expiration/option_type) right after ticker_type.
        if (isTickerType && Array.isArray(formGroup._afterSyntheticGroups) && formGroup._afterSyntheticGroups.length > 0) {
            formGroup._afterSyntheticGroups.forEach((g) => {
                dynamicFieldsContainer.appendChild(g);
            });
        }
        
        // Add event listeners for real-time preview
        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);

        // Track manual edits to avoid overwriting auto-filled values.
        input.addEventListener('input', () => markUserTouched(input));

        // When the underlying stock price changes, refresh stock-price TP targets (10/20/30% defaults)
        // without overwriting user-edited TP targets.
        if (variable.name === 'current_price') {
            input.addEventListener('input', () => {
                updateDefaultTpStockTargets();
                updatePreview();
            });
            input.addEventListener('change', () => {
                updateDefaultTpStockTargets();
                updatePreview();
            });
        }

        // When option/entry/current price changes, recalculate all TP level Price values from Level %
        // (current_price when is_shares on = stock base; option_price when is_shares off = option base)
        if (variable.name === 'option_price' || variable.name === 'entry_price' || variable.name === 'price' || variable.name === 'current_price') {
            input.addEventListener('input', () => {
                updateTpSlPrices();
                updatePreview();
            });
            input.addEventListener('change', () => {
                updateTpSlPrices();
                updatePreview();
            });
        }

        // Auto-fetch current price when selecting a ticker_type field (or ticker with string/text type).
        if (isTickerType) {
            input.addEventListener('change', async () => {
                const sym = String(input.value || '').trim().toUpperCase();
                if (!sym) return;
                const quote = await fetchQuote(sym);
                if (!quote) return;

                // Cache for live preview usage (company_name/stock_price modifiers).
                tickerMetaCache[sym] = {
                    price: quote.price,
                    company_name: quote.company_name || '',
                };

                // Fill best available "price" field (current_price > entry_price > price)
                const currentPriceEl = findFieldByName('current_price');
                const entryPriceEl = findFieldByName('entry_price');
                const priceEl = findFieldByName('price');
                const companyNameEl = findFieldByName('company_name');
                const isSharesCheckbox = document.getElementById('id_is_shares');
                const isShares = isSharesCheckbox && isSharesCheckbox.checked;

                setValueIfAllowed(currentPriceEl, formatFloat3(quote.price));
                setValueIfAllowed(entryPriceEl, formatFloat3(quote.price));
                setValueIfAllowed(priceEl, formatFloat3(quote.price));
                setValueIfAllowed(companyNameEl, quote.company_name);

                // Even if there is no explicit price/company_name input in the template,
                // we still want the live preview to re-render using tickerMetaCache.
                updateDefaultTpStockTargets();
                updateTpSlPrices(); // When is_shares on, TP Price column updates from stock price
                updatePreview();

                // If option side/trade type are selected, auto-pick the best option now.
                if (!isShares) {
                    await maybeAutoPickBestOption();
                }
            });
        }

        // When BUY/SELL (option_type) changes: update all Trade Plan target price values and preview
        if (variable.name === 'option_type') {
            input.dataset.optionTypeChangeWired = '1';
            const onOptionTypeChange = async () => {
                const isSharesCheckbox = document.getElementById('id_is_shares');
                if (isSharesCheckbox && isSharesCheckbox.checked) {
                    applyTpLevelDirectionForShares(true);
                    updateTpSlPrices();
                    updatePreview();
                } else {
                    updateDefaultTpStockTargets();
                    await maybeAutoPickBestOption();
                    updateTpSlPrices();
                    updatePreview();
                }
            };
            input.addEventListener('change', onOptionTypeChange);
            input.addEventListener('input', () => {
                const isSharesCheckbox = document.getElementById('id_is_shares');
                if (isSharesCheckbox && isSharesCheckbox.checked) onOptionTypeChange();
            });
        }
    });

    // Ensure option_type (Buy/Sell) has change/input handler; (re-)attach when is_shares changes in case DOM was updated.
    function ensureOptionTypeChangeHandler() {
        const optEl = findFieldByName('option_type');
        if (!optEl || optEl.dataset.optionTypeChangeWired === '1') return;
        optEl.dataset.optionTypeChangeWired = '1';
        const onOptionTypeChange = async () => {
            const isSharesCheckbox = document.getElementById('id_is_shares');
            if (isSharesCheckbox && isSharesCheckbox.checked) {
                applyTpLevelDirectionForShares(true);
                updateTpSlPrices();
                updatePreview();
            } else {
                updateDefaultTpStockTargets();
                if (typeof maybeAutoPickBestOption === 'function') await maybeAutoPickBestOption();
                updateTpSlPrices();
                updatePreview();
            }
        };
        optEl.addEventListener('change', onOptionTypeChange);
        optEl.addEventListener('input', () => {
            const isSharesCheckbox = document.getElementById('id_is_shares');
            if (isSharesCheckbox && isSharesCheckbox.checked) onOptionTypeChange();
        });
    }

    // Set up is_shares checkbox handler
    const isSharesCheckbox = document.getElementById('id_is_shares');
    if (isSharesCheckbox) {
        isSharesCheckbox.addEventListener('change', function() {
            toggleOptionFields(this.checked);
            updateVariableVisibility(); // Update variable visibility when is_shares changes
            if (typeof setTimeHorizonDefault === 'function') setTimeHorizonDefault(); // Options: expiration; Stock: 1wk/6mo
            // Re-attach option_type change handler (in case field was recreated or listener was lost)
            ensureOptionTypeChangeHandler();
            if (this.checked) {
                // When is_shares on: set TP level direction from Buy/Sell, then update Price from stock base
                applyTpLevelDirectionForShares();
                // Recompute default Stock price ($) targets from stock base when in Stock price mode
                updateDefaultTpStockTargets();
            }
            // If switching back to options mode, reset option-related inputs to defaults.
            if (!this.checked) {
                const sym = getCurrentTickerSymbol();
                const cached = sym ? tickerMetaCache[sym] : null;
                const optTypeEl = findFieldByName('option_type');
                const optionPriceEl = findFieldByName('option_price');

                const forceSet = (el, value) => {
                    if (!el) return;
                    el.value = String(value ?? '');
                    el.dataset.autoFilled = '1';
                    el.dataset.suppressUserTouched = '1';
                    // Fire events so preview + option quote logic update.
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                    if (el.dataset.suppressUserTouched === '1') delete el.dataset.suppressUserTouched;
                };

                // Default option_type=CALL (user can change to PUT which will recompute best-option)
                forceSet(optTypeEl, 'CALL');

                // Default TP/SL percent values
                forceSet(findFieldByName('tp1_per'), '10');
                forceSet(findFieldByName('tp2_per'), '20');
                forceSet(findFieldByName('tp3_per'), '30');
                // Default takeoff amounts (percent of capital removed at each TP)
                forceSet(findFieldByName('tp1_takeoff_per'), '50');
                forceSet(findFieldByName('tp2_takeoff_per'), '50');
                forceSet(findFieldByName('tp3_takeoff_per'), '100');
                forceSet(findFieldByName('sl_per'), '10');

                // Default option_price to 0.00; it will be overwritten by /api/best-option/ once inputs are valid.
                forceSet(optionPriceEl, '0.00');
                // Recompute Take Profit Price column from option price (is_shares off = option-based)
                updateTpSlPrices();
            }
            updatePreview();
            if (!this.checked) {
                // Recompute best option for current ticker/trade_type/side
                maybeAutoPickBestOption();
            }
        });
        // Initialize on page load
        toggleOptionFields(isSharesCheckbox.checked);
        ensureOptionTypeChangeHandler();
        if (isSharesCheckbox.checked) {
            applyTpLevelDirectionForShares();
        }
    }

    // Create optional fields checkboxes
    createOptionalFieldsCheckboxes(signalTypeId);
    
    // Set checkbox defaults based on signal type
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    if (showTitleCheckbox && signalType.show_title_default !== undefined) {
        showTitleCheckbox.checked = signalType.show_title_default;
        
    }
    
    if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
        showDescriptionCheckbox.checked = signalType.show_description_default;
        
    }
    
    // Update variable visibility after fields are created
    updateVariableVisibility();
    // Time Horizon: show only for Swing/Leap (under Stop Loss in Trade Plan)
    updateTimeHorizonVisibility();

    // If signal type has a file variable (e.g. Chart Analysis), form must use multipart
    const hasFileVariable = (signalType.variables || []).some(v => v && v.type === 'file');
    const signalForm = document.getElementById('signalForm');
    if (signalForm) {
        if (hasFileVariable) {
            signalForm.enctype = 'multipart/form-data';
        } else {
            signalForm.enctype = 'application/x-www-form-urlencoded';
        }
    }

    // Auto-resize any textareas in the Send Signal panel (no scrollbars)
    wireAutoResizeTextareas(document.getElementById('dynamicFields'));
    wireAutoResizeTextareas(document.getElementById('optionalFieldsVariablesContainer'));

    // Upgrade any <select> controls inside dynamic fields to match ticker dropdown styling
    document.querySelectorAll('#dynamicFields select, #optionalFieldsVariablesContainer select').forEach((sel) => {
        if (sel.dataset.tpTargetTypeSelect === '1') return;
        upgradeSelectToTickerDropdown(sel);
    });
    
    // Update preview after fields are created
    updatePreview();
}

// Update option_type field label and option display text: "Option Type" + CALL/PUT when is_shares off, "Buy or Sell" + Buy/Sell when on
function updateOptionTypeLabelAndOptions(isShares) {
    const containers = [document.getElementById('dynamicFields'), document.getElementById('optionalFieldsVariablesContainer')];
    containers.forEach((root) => {
        if (!root) return;
        const optionTypeGroup = root.querySelector('[data-variable-name="option_type"]');
        if (!optionTypeGroup) return;
        const labelEl = optionTypeGroup.querySelector('label');
        const selectEl = optionTypeGroup.querySelector('select');
        if (labelEl) {
            labelEl.textContent = isShares ? 'Buy or Sell' : 'Option Type';
        }
        if (selectEl) {
            const optLabels = isShares ? { 'CALL': 'BUY', 'PUT': 'SELL' } : { 'CALL': 'CALL', 'PUT': 'PUT' };
            Array.from(selectEl.options).forEach((opt) => {
                const v = (opt.value || '').toUpperCase();
                opt.textContent = optLabels[v] || opt.value || opt.textContent;
            });
            // Refresh custom dropdown if option_type was upgraded (so it shows Buy/Sell instead of CALL/PUT)
            if (typeof selectEl._refreshDropdownOptions === 'function') {
                selectEl._refreshDropdownOptions();
            }
        }
    });
}

// Toggle visibility of option-related fields based on is_shares checkbox
function toggleOptionFields(isShares) {
    // When is_shares on: hide only strike and expiration; show option_type as "Buy or Sell" (Buy/Sell). Trade Plan stays visible.
    // When is_shares off: show strike, expiration, option_type as "Option Type" (CALL/PUT).
    const strikeGroups = document.querySelectorAll('[data-variable-name="strike"]');
    const expirationGroups = document.querySelectorAll('[data-variable-name="expiration"]');
    const optionTypeGroups = document.querySelectorAll('[data-variable-name="option_type"]');

    strikeGroups.forEach((field) => {
        if (field.closest('.trade-plan-group')) return;
        field.style.display = isShares ? 'none' : 'block';
        const input = field.querySelector('input, select');
        if (input && isShares) {
            input.removeAttribute('required');
            input.value = '';
        } else if (input && !isShares && input.hasAttribute('data-originally-required')) {
            input.setAttribute('required', true);
        }
    });
    expirationGroups.forEach((field) => {
        if (field.closest('.trade-plan-group')) return;
        field.style.display = isShares ? 'none' : 'block';
        const input = field.querySelector('input, select');
        if (input && isShares) {
            input.removeAttribute('required');
            input.value = '';
        } else if (input && !isShares && input.hasAttribute('data-originally-required')) {
            input.setAttribute('required', true);
        }
    });
    optionTypeGroups.forEach((field) => {
        if (field.closest('.trade-plan-group')) return;
        field.style.display = 'block';
    });
    updateOptionTypeLabelAndOptions(isShares);

    // Other [data-requires-options] that are not strike/expiration/option_type (e.g. inside Trade Plan): hide only when is_shares and outside Trade Plan
    const optionFields = document.querySelectorAll('[data-requires-options="true"]');
    optionFields.forEach((field) => {
        const name = field.getAttribute('data-variable-name');
        if (name === 'strike' || name === 'expiration' || name === 'option_type') return; // already handled
        const insideTradePlan = field.closest('.trade-plan-group');
        if (isShares && !insideTradePlan) {
            field.style.display = 'none';
            const input = field.querySelector('input, select');
            if (input) {
                input.removeAttribute('required');
                input.value = '';
            }
        } else if (!isShares) {
            field.style.display = 'block';
            const input = field.querySelector('input, select');
            if (input && input.hasAttribute('data-originally-required')) {
                input.setAttribute('required', true);
            }
        }
    });

    // Keep Trade Plan visible when options are disabled (shares mode)
    document.querySelectorAll('.trade-plan-group').forEach((g) => {
        g.style.display = 'block';
    });
}

// Update variable visibility based on which variables are currently used
function updateVariableVisibility() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');

    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    // If we have a ticker_type control, show option fields by default (unless is_shares is enabled).
    const hasTickerTypeControl = !!document.querySelector('#dynamicFields .ticker-type-row, #optionalFieldsVariablesContainer .ticker-type-row');
    const optionFieldNames = new Set([
        'strike', 'expiration', 'option_type',
        'tp1_per', 'tp2_per', 'tp3_per', 'tp4_per', 'tp5_per', 'tp6_per',
        'tp1_takeoff_per', 'tp2_takeoff_per', 'tp3_takeoff_per', 'tp4_takeoff_per', 'tp5_takeoff_per', 'tp6_takeoff_per',
        'tp1_mode', 'tp2_mode', 'tp3_mode', 'tp4_mode', 'tp5_mode', 'tp6_mode',
        'tp1_stock_price', 'tp2_stock_price', 'tp3_stock_price', 'tp4_stock_price', 'tp5_stock_price', 'tp6_stock_price',
        'sl_per',
    ]);
    const forceShowOptionFields = hasTickerTypeControl && !isShares;
    
    // Update visibility of all variable inputs
    const variableInputs = document.querySelectorAll('#dynamicFields [data-variable-name], #optionalFieldsVariablesContainer [data-variable-name]');
    variableInputs.forEach(formGroup => {
        const variableName = formGroup.getAttribute('data-variable-name');
        // is_shares is a special control variable that should always be visible
        const isSpecialControl = variableName === 'is_shares';
        // When is_shares is on: show option_type as "Buy or Sell", and show Trade Plan inputs (tp1_per, sl_per, etc.) but not strike/expiration
        const showOptionTypeAsBuyOrSell = isShares && variableName === 'option_type';
        const showTradePlanWhenShares = isShares && optionFieldNames.has(variableName) && variableName !== 'strike' && variableName !== 'expiration';
        const isUsed = usedVariables.has(variableName) || isSpecialControl || (forceShowOptionFields && optionFieldNames.has(variableName)) || showOptionTypeAsBuyOrSell || showTradePlanWhenShares;
        const isOptionalOnly = optionalOnlyVariables.has(variableName);
        const currentParent = formGroup.parentElement;
        const isInOptionalContainer = currentParent === optionalFieldsVariablesContainer;
        
        if (isUsed) {
            // Keep synthetic hidden fields hidden (but still included in data).
            if (formGroup.classList.contains('synthetic-hidden')) {
                formGroup.style.display = 'none';
            } else {
                // Preserve checkbox-group alignment (inline style wins over CSS)
                formGroup.style.display = formGroup.classList.contains('checkbox-group') ? 'flex' : 'block';
            }
            
            // is_shares should always stay in main container, never move to optional container
            if (isSpecialControl && isInOptionalContainer) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            } else if (isOptionalOnly && !isInOptionalContainer && !isSpecialControl) {
                // Move to optional fields container (but not is_shares)
                formGroup.remove();
                optionalFieldsVariablesContainer.appendChild(formGroup);
            } else if (!isOptionalOnly && isInOptionalContainer && !isSpecialControl) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            }
        } else {
            formGroup.style.display = 'none';
            // Clear the value when hiding (except for required fields and is_shares)
            if (!isSpecialControl) {
                const input = formGroup.querySelector('input, textarea, select');
                if (input && !input.hasAttribute('required')) {
                    if (input.type === 'checkbox') {
                        input.checked = false;
                    } else {
                        input.value = '';
                    }
                }
            }
        }
    });
    
    // Show/hide optional fields variables container based on visible variable inputs
    // Chart Analysis: show image/video upload (TA Media) only when Chart Analysis switch is on
    const showChartAnalysis = optionalFieldsVariablesContainer && window._chartAnalysisFieldKey !== undefined && window._chartAnalysisFieldKey !== null && !!optionalFieldsVisibility[window._chartAnalysisFieldKey];
    const hasRealChartAnalysis = optionalFieldsVariablesContainer ? !!optionalFieldsVariablesContainer.querySelector('[data-variable-name="chart_analysis"]:not([data-synthetic-ta-media])') : false;
    if (optionalFieldsVariablesContainer && window._chartAnalysisFieldKey !== undefined && window._chartAnalysisFieldKey !== null) {
        const chartAnalysisGroup = optionalFieldsVariablesContainer.querySelector('[data-variable-name="chart_analysis"]:not([data-synthetic-ta-media])');
        if (chartAnalysisGroup) {
            chartAnalysisGroup.style.display = showChartAnalysis ? 'block' : 'none';
        }
        // When Chart Analysis is on and signal type has no chart_analysis variable, show synthetic TA Media field (like Post TA)
        let syntheticTaMedia = document.getElementById('syntheticChartAnalysisGroup');
        if (showChartAnalysis && !hasRealChartAnalysis) {
            if (!syntheticTaMedia) {
                syntheticTaMedia = document.createElement('div');
                syntheticTaMedia.id = 'syntheticChartAnalysisGroup';
                syntheticTaMedia.setAttribute('data-variable-name', 'chart_analysis');
                syntheticTaMedia.setAttribute('data-synthetic-ta-media', '1');
                syntheticTaMedia.className = 'form-group';
                const label = document.createElement('label');
                label.textContent = 'TA Media (Image or Video)';
                const input = document.createElement('input');
                input.type = 'file';
                input.name = 'chart_analysis';
                input.id = 'syntheticChartAnalysisInput';
                input.className = 'form-input';
                input.accept = 'image/*,video/*';
                input.setAttribute('data-ignore-dynamic', '1');
                const dropEl = buildTaDropDom();
                wireTaDropForInput(input, dropEl, updatePreview);
                const small = document.createElement('small');
                small.style.cssText = 'display:block; margin-top:8px; color:#9ca3af;';
                small.textContent = 'Supported: images and video clips. Keep files small enough for Discord webhook limits.';
                syntheticTaMedia.appendChild(label);
                syntheticTaMedia.appendChild(input);
                syntheticTaMedia.appendChild(dropEl);
                syntheticTaMedia.appendChild(small);
                optionalFieldsVariablesContainer.appendChild(syntheticTaMedia);
            }
            syntheticTaMedia.style.display = 'block';
        } else if (syntheticTaMedia) {
            syntheticTaMedia.style.display = 'none';
        }
    }

    // When Chart Analysis switch is on and signal type has chart_analysis variable, style it as TA Media drag & drop (like Post TA)
    if (showChartAnalysis && hasRealChartAnalysis) {
        const realGroup = optionalFieldsVariablesContainer.querySelector('[data-variable-name="chart_analysis"]:not([data-synthetic-ta-media])');
        const existingInput = realGroup && realGroup.querySelector('input[name="chart_analysis"]');
        if (existingInput && !existingInput.dataset.taDropWired) {
            existingInput.dataset.taDropWired = '1';
            const dropEl = buildTaDropDom();
            existingInput.parentNode.insertBefore(dropEl, existingInput.nextSibling);
            wireTaDropForInput(existingInput, dropEl, updatePreview);
        }
    }

    // Form must use multipart when Chart Analysis (TA Media) is shown
    const signalForm = document.getElementById('signalForm') || document.querySelector('form[action*="dashboard"]');
    if (signalForm && showChartAnalysis) {
        signalForm.enctype = 'multipart/form-data';
    }

    if (optionalFieldsVariablesContainer) {
        // Count visible variable inputs (form groups with data-variable-name that are not hidden)
        const visibleVariables = Array.from(optionalFieldsVariablesContainer.children).filter(child => {
            // Check if it's a form group with data-variable-name that's visible
            const hasVariableName = child.getAttribute && child.getAttribute('data-variable-name');
            const isVisible = child.style && child.style.display !== 'none';
            return hasVariableName && isVisible;
        });

        // Only show the container if there are visible variable inputs
        if (visibleVariables.length > 0) {
            optionalFieldsVariablesContainer.style.display = 'block';
        } else {
            optionalFieldsVariablesContainer.style.display = 'none';
        }
    }

    // When is_shares is on, show Buy or Sell instead of Option Type (keep in sync after any visibility update)
    const isSharesCheckboxForLabel = document.getElementById('id_is_shares');
    if (isSharesCheckboxForLabel) {
        updateOptionTypeLabelAndOptions(isSharesCheckboxForLabel.checked);
    }
}

// Create checkboxes for optional fields
function createOptionalFieldsCheckboxes(signalTypeId) {
    const optionalFieldsSection = document.getElementById('optionalFieldsSection');
    const optionalFieldsContainer = document.getElementById('optionalFieldsCheckboxesContainer');
    
    if (!optionalFieldsSection || !optionalFieldsContainer) {
        return;
    }
    
    // Clear existing checkboxes
    optionalFieldsContainer.innerHTML = '';
    
    // Get signal type data
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        optionalFieldsSection.style.display = 'none';
        return;
    }
    
    // Parse fields_template
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = fields || [];
    
    // Find optional fields
    const optionalFields = [];
    fields.forEach((field, index) => {
        if (isOptionalFieldForSignalType(field, signalType)) {
            // Extract a readable name from the field
            let fieldName = field.name || field.value || `Field ${index + 1}`;
            // Remove markdown, emojis, and variable placeholders, then clean up
            fieldName = fieldName.replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').replace(/\{\{.*?\}\}/g, '').trim();
            if (!fieldName) {
                fieldName = field.value ? field.value.replace(/\{\{.*?\}\}/g, '').replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').trim() : `Field ${index + 1}`;
            }
            if (!fieldName || fieldName === '\u200b') {
                fieldName = `Optional Field ${index + 1}`;
            }
            optionalFields.push({
                index: index,
                name: fieldName,
                field: field
            });
        }
    });

    // Always add Chart Analysis switch in Optional Fields panel (UI only, no Signal Type DB change)
    const hasChartAnalysisInOptional = optionalFields.some((f) => (f.name || '').toLowerCase().includes('chart analysis'));
    if (!hasChartAnalysisInOptional) {
        const chartAnalysisIdx = fields.findIndex((f) =>
            (String(f.name || '').includes('Chart Analysis') || String(f.value || '').includes('chart_analysis'))
        );
        if (chartAnalysisIdx >= 0) {
            optionalFields.unshift({
                index: chartAnalysisIdx,
                name: 'Chart Analysis',
                field: fields[chartAnalysisIdx]
            });
        } else {
            optionalFields.unshift({
                index: fields.length,
                name: 'Chart Analysis',
                field: { name: 'üìä Chart Analysis', value: '{{chart_analysis}}' }
            });
        }
    }

    // Show/hide section based on whether there are optional fields
    if (optionalFields.length === 0) {
        optionalFieldsSection.style.display = 'none';
        return;
    }

    optionalFieldsSection.style.display = 'block';
    window._chartAnalysisFieldKey = null;

    // Create checkboxes for each optional field
    optionalFields.forEach(({index, name, field}) => {
        const fieldKey = `field_${signalTypeId}_${index}`;
        const isChartAnalysis = (name || '').toLowerCase().includes('chart analysis') || (field.value || '').includes('chart_analysis');
        if (isChartAnalysis) {
            window._chartAnalysisFieldKey = fieldKey;
        }

        // Create row container
        const row = document.createElement('div');
        row.className = 'switch-item';

        // Create checkbox (kept as checkbox for logic, styled as switch)
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `optional_field_${fieldKey}`;
        checkbox.checked = optionalFieldsVisibility[fieldKey] || false;

        const switchWrap = document.createElement('label');
        switchWrap.className = 'mini-switch';

        const slider = document.createElement('span');
        slider.className = 'mini-slider';

        switchWrap.appendChild(checkbox);
        switchWrap.appendChild(slider);

        // Create text label
        const label = document.createElement('label');
        label.className = 'switch-text';
        label.htmlFor = checkbox.id;
        label.textContent = name;

        // Add change event listener
        checkbox.addEventListener('change', function() {
            optionalFieldsVisibility[fieldKey] = this.checked;
            updateVariableVisibility(); // Update variable visibility when optional fields change
            updatePreview();
        });

        row.appendChild(switchWrap);
        row.appendChild(label);
        optionalFieldsContainer.appendChild(row);
    });
}



// Handle title visibility toggle
function toggleTitleVisibility() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowTitle', showTitleCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Handle description visibility toggle
function toggleDescriptionVisibility() {
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowDescription', showDescriptionCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Load visibility preferences from localStorage or signal type defaults
function loadVisibilityPreferences() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    // Check if a signal type is already selected
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    let useSignalTypeDefaults = false;
    
    if (signalTypeSelect && signalTypeSelect.value) {
        const signalTypeId = signalTypeSelect.value;
        const signalTypeIdStr = String(signalTypeId);
        const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
        
        if (signalType && (signalType.show_title_default !== undefined || signalType.show_description_default !== undefined)) {
            useSignalTypeDefaults = true;
            
            if (showTitleCheckbox && signalType.show_title_default !== undefined) {
                showTitleCheckbox.checked = signalType.show_title_default;
                localStorage.setItem('discordShowTitle', signalType.show_title_default ? 'true' : 'false');
            }
            
            if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
                showDescriptionCheckbox.checked = signalType.show_description_default;
                localStorage.setItem('discordShowDescription', signalType.show_description_default ? 'true' : 'false');
            }
        }
    }
    
}

// Handle signal type change
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded - Initializing dashboard...');
    
    // Initialize visibility preferences
    loadVisibilityPreferences();
    
    // Add event listeners to checkboxes
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        showTitleCheckbox.addEventListener('change', toggleTitleVisibility);
    }
    
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        showDescriptionCheckbox.addEventListener('change', toggleDescriptionVisibility);
    }
    
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    const form = document.getElementById('signalForm');
    const isTradePlanOnlyPage = (document.querySelector('.dashboard-page')?.dataset?.mode === 'trade_plan_only');

    function setupTradePlanOnlyLayout() {
        const dynamicFieldsContainer = document.getElementById('dynamicFields');
        if (!dynamicFieldsContainer) return;
        const tradePlanGroup = dynamicFieldsContainer.querySelector('.trade-plan-group');
        if (!tradePlanGroup) return;

        // Append base-price hidden fields into the Trade Plan group so we can hide everything else.
        const body = tradePlanGroup.children && tradePlanGroup.children.length >= 2 ? tradePlanGroup.children[1] : tradePlanGroup;

        // No Discord message template editor in New Trade Plan.

        const forceSet = (el, value) => {
            if (!el) return;
            el.value = String(value ?? '');
            el.dataset.autoFilled = '1';
            el.dataset.suppressUserTouched = '1';
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            if (el.dataset.suppressUserTouched === '1') delete el.dataset.suppressUserTouched;
        };

        const ensureHidden = (name, value) => {
            let el = findFieldByName(name);
            if (!el) {
                const g = createSyntheticHiddenField(name, '');
                body.appendChild(g);
                el = g.querySelector('input');
            }
            forceSet(el, value);
        };

        // Defaults for the Trade Plan edit page: stock price = 200, option price = 5
        ensureHidden('current_price', '200');
        ensureHidden('stock_price', '200');
        ensureHidden('option_price', '5');
        ensureHidden('entry_price', '5');
        ensureHidden('price', '5');

        // Hide everything else in the left column; keep only the Trade Plan panel.
        Array.from(dynamicFieldsContainer.children).forEach((ch) => {
            if (ch === tradePlanGroup) return;
            ch.style.display = 'none';
        });

        // Remove noise for this page
        const dl = document.getElementById('usTickerList');
        if (dl) dl.style.display = 'none';

        // Ensure dependent computed fields update + preview shows only the Trade Plan block
        try { updateTpSlPrices(); } catch (_) {}
        try { updateDefaultTpStockTargets(); } catch (_) {}
        try { updatePreview(); } catch (_) {}
    }

    // Upgrade top-level selects to match ticker dropdown styling
    if (signalTypeSelect) upgradeSelectToTickerDropdown(signalTypeSelect, { placeholder: 'Select signal type' });
    const discordChannelSelect = document.getElementById('discord_channel');
    if (discordChannelSelect && !isTradePlanOnlyPage) upgradeSelectToTickerDropdown(discordChannelSelect, { placeholder: 'Select channel' });
    const tradeTypeSelect = document.getElementById('trade_type');
    if (tradeTypeSelect) upgradeSelectToTickerDropdown(tradeTypeSelect, { placeholder: 'Select trade type' });
    
    console.log('signalTypeSelect found:', !!signalTypeSelect);
    console.log('signalTypesData keys:', Object.keys(signalTypesData));
    
    if (signalTypeSelect) {
        // Default to Common Trade Alert; fallback to current value or first type
        const commonTradeAlertId = Object.keys(signalTypesData).find((id) => {
            const st = signalTypesData[id];
            return st && (st.name || '').trim() === 'Common Trade Alert';
        });
        const defaultValue = signalTypeSelect.value || commonTradeAlertId || signalTypeSelect.options[signalTypeSelect.selectedIndex]?.value || Object.keys(signalTypesData)[0];
        console.log('Default value determined:', defaultValue, 'Common Trade Alert ID:', commonTradeAlertId);
        console.log('Available signal types:', Object.keys(signalTypesData).map(id => ({ id, name: signalTypesData[id]?.name })));
        
        if (defaultValue) {
            signalTypeSelect.value = defaultValue;
            console.log('Creating dynamic fields for default value:', defaultValue);
            createDynamicFields(defaultValue);
            if (isTradePlanOnlyPage) setupTradePlanOnlyLayout();
        } else {
            console.warn('No default value found. signalTypeSelect.value:', signalTypeSelect.value, 'Options:', signalTypeSelect.options.length);
            // Fallback: try to create fields with first available signal type
            const firstId = Object.keys(signalTypesData)[0];
            if (firstId) {
                console.log('Fallback: using first available signal type:', firstId);
                signalTypeSelect.value = firstId;
                createDynamicFields(firstId);
                if (isTradePlanOnlyPage) setupTradePlanOnlyLayout();
            }
        }

        // Message template wiring happens inside setupTradePlanOnlyLayout()
        
        // Handle change
        signalTypeSelect.addEventListener('change', function() {
            console.log('Signal type changed to:', this.value);
            if (this.value) {
                createDynamicFields(this.value);
                if (isTradePlanOnlyPage) setupTradePlanOnlyLayout();
                // Update preview immediately - createDynamicFields already calls it, but ensure it happens
                updatePreview();
            }
        });

        // Real-time preview: refresh stock and option prices on an interval so preview stays current
        if (document.getElementById('dynamicFields')) {
            setTimeout(refreshPreviewPrices, 2000);
            setInterval(refreshPreviewPrices, PREVIEW_REFRESH_INTERVAL_MS);
        }
        
        // Handle form submission
        form.addEventListener('submit', async function(e) {
            if (isTradePlanOnlyPage) {
                // New Trade Plan page is for saving presets only (buttons in the Trade Plan panel).
                e.preventDefault();
                return false;
            }
            // If we already ran the auto-fill flow, proceed with normal submit.
            if (form.dataset.skipAutoFillOnce === '1') {
                delete form.dataset.skipAutoFillOnce;
            } else {
                // Safety: if option_price is still default (0.00) in options mode, wait for best-option autofill.
                const isSharesCheckbox0 = document.getElementById('id_is_shares');
                const isShares0 = isSharesCheckbox0 && isSharesCheckbox0.checked;
                if (!isShares0) {
                    const sym0 = getCurrentTickerSymbol();
                    const optPriceEl0 = findFieldByName('option_price');
                    const optPrice0 = optPriceEl0 ? String(optPriceEl0.value || '').trim() : '';
                    const needsOptionPrice =
                        !!sym0 &&
                        (!optPrice0 || optPrice0 === '0' || optPrice0 === '0.0' || optPrice0 === '0.00');

                    if (needsOptionPrice) {
                        e.preventDefault();
                        try {
                            await maybeAutoPickBestOption();
                            updateTpSlPrices();
                        } catch (_) {
                            // fall through: submit with whatever we have
                        }
                        form.dataset.skipAutoFillOnce = '1';
                        // Trigger submit again with updated values
                        if (typeof form.requestSubmit === 'function') {
                            form.requestSubmit();
                        } else {
                            form.submit();
                        }
                        return false;
                    }
                }
            }

            // Get current signal type and its variables
            const currentSignalTypeId = signalTypeSelect.value;
            const currentSignalType = signalTypesData[currentSignalTypeId];
            const currentVariables = currentSignalType ? (currentSignalType.variables || []) : [];
            
            // Validate required fields - include inputs from both containers
            const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
            const errors = [];
            
            // Check if is_shares is checked
            const isSharesCheckbox = document.getElementById('id_is_shares');
            const isShares = isSharesCheckbox && isSharesCheckbox.checked;
            
            dynamicInputs.forEach(input => {
                // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
                if (!input.name || input.dataset.ignoreDynamic === '1') {
                    return;
                }
                // Skip validation if field is hidden due to is_shares
                if (input.closest('[data-requires-options="true"]') && isShares) {
                    return;
                }
                
                // Find the variable definition for this input
                const variable = currentVariables.find(v => v.name === input.name);
                
                // Check if field is required
                if (variable && variable.required === true) {
                    let isEmpty = false;
                    
                    // Check if field is empty based on type
                    if (input.type === 'checkbox') {
                        isEmpty = !input.checked;
                    } else {
                        isEmpty = !input.value || input.value.trim() === '';
                    }
                    
                    if (isEmpty) {
                        errors.push(variable.label || variable.name);
                        // Add error styling to the field
                        input.style.borderColor = '#dc3545';
                        const formGroup = input.closest('.form-group');
                        if (formGroup) {
                            formGroup.style.marginBottom = '10px';
                        }
                    } else {
                        // Remove error styling if field is valid
                        input.style.borderColor = '';
                    }
                } else {
                    // Remove error styling for non-required fields
                    input.style.borderColor = '';
                }
            });
            
            // Show errors if any and prevent submission
            if (errors.length > 0) {
                e.preventDefault();
                alert('Please fill in the following required fields:\n' + errors.map(e => '  ‚Ä¢ ' + e).join('\n'));
                return false;
            }
            
            // Collect all dynamic field values into a JSON object
            const signalData = {};
            dynamicInputs.forEach(input => {
                // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
                if (!input.name || input.dataset.ignoreDynamic === '1') {
                    return;
                }
                // File inputs are sent as FILES; do not put in signalData JSON
                if (input.type === 'file') {
                    return;
                }
                // Handle checkbox
                if (input.type === 'checkbox') {
                    signalData[input.name] = input.checked ? 'true' : 'false';
                } else {
                    signalData[input.name] = input.value;
                }
            });

            // Include non-dynamic publish controls
            const tradeTypeEl = document.getElementById('trade_type');
            if (tradeTypeEl && tradeTypeEl.value) {
                signalData['trade_type'] = tradeTypeEl.value;
            }
            
            // Collect optional field selections
            const optionalFieldsIndices = [];
            // currentSignalType already declared above
            if (currentSignalType) {
                let fields = currentSignalType.fields_template;
                if (typeof fields === 'string') {
                    try {
                        fields = JSON.parse(fields);
                    } catch (e) {
                        fields = [];
                    }
                }
                fields = fields || [];
                
                fields.forEach((field, index) => {
                    if (isOptionalFieldForSignalType(field, currentSignalType)) {
                        const fieldKey = `field_${currentSignalTypeId}_${index}`;
                        if (optionalFieldsVisibility[fieldKey] === true) {
                            optionalFieldsIndices.push(index);
                        }
                    }
                });
            }
            
            // Store optional field indices in signalData
            if (optionalFieldsIndices.length > 0) {
                signalData['_optional_fields'] = optionalFieldsIndices;
            }
            
            // Store title and description visibility preferences
            const showTitleCheckbox = document.getElementById('showTitleCheckbox');
            const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
            if (showTitleCheckbox) {
                signalData['_show_title'] = showTitleCheckbox.checked;
            }
            if (showDescriptionCheckbox) {
                signalData['_show_description'] = showDescriptionCheckbox.checked;
            }

            // Include Raise Stop Loss selections from Trade Plan rows (not regular named inputs)
            const tpRowsForData = document.querySelectorAll('.tp-level-row[data-tp-row="1"]');
            tpRowsForData.forEach((r) => {
                const lvl = r.dataset.tpLevel || '';
                if (!lvl) return;
                const raiseSlSelect = r.querySelector('[data-tp-raise-sl-to]');
                const raiseSlCustomPer = r.querySelector('[data-tp-raise-sl-custom-per]');
                const raiseSlCustom = r.querySelector('[data-tp-raise-sl-custom]');
                const raiseSlCustomStock = r.querySelector('[data-tp-raise-sl-custom-stock]');
                if (raiseSlSelect) signalData[`tp${lvl}_raise_sl_to`] = String(raiseSlSelect.value || '').trim();
                if (raiseSlCustomPer) signalData[`tp${lvl}_raise_sl_custom_per`] = String(raiseSlCustomPer.value || '').trim();
                if (raiseSlCustom) signalData[`tp${lvl}_raise_sl_custom`] = String(raiseSlCustom.value || '').trim();
                if (raiseSlCustomStock) signalData[`tp${lvl}_raise_sl_custom_stock`] = String(raiseSlCustomStock.value || '').trim();
            });
            
            // Set the data field value
            const dataInput = form.querySelector('input[name="data"]');
            if (dataInput) {
                dataInput.value = JSON.stringify(signalData);
            } else {
                // If data field doesn't exist, add it to the form
                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = 'data';
                hiddenInput.value = JSON.stringify(signalData);
                form.appendChild(hiddenInput);
            }
            
            // Let form submit naturally if validation passes
        });
    }

    // Recompute best option when trade type changes (Scalp/Swing/Leap)
    const tradeTypeEl = document.getElementById('trade_type');
    if (tradeTypeEl) {
        tradeTypeEl.addEventListener('change', async () => {
            updateTimeHorizonVisibility(); // Show Time Horizon only for Swing/Leap
            await maybeAutoPickBestOption();
            updatePreview();
        });
    }
});
</script>
{% endblock %}

