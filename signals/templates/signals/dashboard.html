{% extends 'signals/base.html' %}
{% load static %}

{% block breadcrumbs %}
<a href="{% url 'dashboard' %}">Dashboard</a>
<span>/</span>
<span>Submit Signal</span>
{% endblock %}

{% block extra_css %}
<style>
    .dashboard-page {
        width: 100%;
        max-width: none;
        margin: 0;
    }

    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 30px;
    }

    .page-title-section h1 {
        color: #e0e0e0;
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 10px;
    }

    .page-title-section p {
        color: #888;
        font-size: 1.1em;
    }

    .page-actions {
        display: flex;
        gap: 12px;
    }

    .btn-cancel {
        background: #2d2d2d;
        color: #e0e0e0;
        padding: 12px 24px;
        border: 1px solid #444;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s;
        cursor: pointer;
    }

    .btn-cancel:hover {
        background: #353535;
        border-color: #555;
    }

    /* Disabled button state (make it obvious) */
    .btn-cancel:disabled,
    .btn-submit:disabled,
    .btn-publish:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        box-shadow: none !important;
        transform: none !important;
        filter: grayscale(0.35) saturate(0.65);
    }

    .btn-cancel:disabled {
        background: rgba(45, 45, 45, 0.65);
        color: rgba(224, 224, 224, 0.55);
        border-color: rgba(68, 68, 68, 0.55);
    }

    .btn-submit:disabled,
    .btn-publish:disabled {
        background: rgba(var(--accent-rgb), 0.25);
        color: rgba(26, 26, 26, 0.75);
    }

    .btn-cancel:disabled:hover,
    .btn-submit:disabled:hover,
    .btn-publish:disabled:hover {
        background: inherit;
        border-color: inherit;
        transform: none;
        box-shadow: none;
    }

    .btn-publish {
        background: var(--accent);
        color: #1a1a1a;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-publish:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.3);
    }

    .content-layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) clamp(420px, 34vw, 560px);
        gap: 30px;
        align-items: start;
    }

    .form-container {
        max-width: none;
        min-width: 0;
    }

    .form-section {
        background: rgba(15, 23, 42, 0.72);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        border: 1px solid rgba(42, 55, 95, 0.55);
    }

    .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }

    .section-divider {
        height: 1px;
        width: 100%;
        background: rgba(255, 255, 255, 0.08);
        margin: 14px 0 18px 0;
    }

    .section-icon {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }

    .section-icon.purple {
        background: #9333ea;
        color: white;
    }

    .section-icon.green {
        background: #10b981;
        color: white;
    }

    .section-icon.blue {
        background: #2563eb;
        color: white;
    }

    .section-icon img {
        width: 18px;
        height: 18px;
        display: block;
        filter: invert(100%);
    }

    .section-title {
        color: #e0e0e0;
        font-size: 1.3em;
        font-weight: 600;
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        color: #e0e0e0;
        font-weight: 600;
        font-size: 0.95em;
    }
    
    /* For checkbox inputs, adjust label display */
    .form-group:has(.form-checkbox) {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group:has(.form-checkbox) label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group:has(.form-checkbox) .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }
    
    /* Fallback for browsers that don't support :has() */
    .form-group.checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: nowrap;
    }
    
    .form-group.checkbox-group label {
        display: inline-flex;
        align-items: center;
        margin-bottom: 0;
        margin-top: 0;
        font-weight: normal;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .form-group.checkbox-group .form-checkbox {
        flex-shrink: 0;
        margin: 0;
    }

    .form-input, .form-textarea, .form-select {
        width: 100%;
        padding: 12px 15px;
        border: 1px solid rgba(42, 55, 95, 0.65);
        border-radius: 12px;
        font-size: 1em;
        transition: all 0.3s;
        font-family: inherit;
        background: rgba(10, 16, 35, 0.72);
        color: #e0e0e0;
    }

    /* Ticker search dropdown (ticker_select / ticker_type) */
    .ticker-search {
        position: relative;
        width: 100%;
    }

    /* Ticker + is_shares inline row */
    .ticker-type-row {
        display: flex;
        align-items: center;
        gap: 12px;
        width: 100%;
    }

    .ticker-type-row .ticker-search {
        flex: 1 1 auto;
        min-width: 0;
    }

    .ticker-type-row .toggle-pill {
        flex: 0 0 auto;
        width: auto;
        padding: 10px 12px;
        border-radius: 12px;
    }

    .ticker-type-row .toggle-label {
        font-size: 0.9em;
        max-width: 260px;
    }

    .ticker-search-dropdown {
        position: absolute;
        top: calc(100% + 8px);
        left: 0;
        right: 0;
        /* Keep results above other form controls */
        z-index: 2000;
        /* Opaque background so underlying controls (e.g. is_shares toggle) don't show through */
        background: #0a1023;
        border: 1px solid rgba(42, 55, 95, 0.85);
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
        max-height: 280px;
        overflow: auto;
        padding: 6px;
        display: none;
    }

    .ticker-search-dropdown.open {
        display: block;
    }

    .ticker-search-item {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        padding: 10px 10px;
        border-radius: 10px;
        cursor: pointer;
        border: 1px solid transparent;
        user-select: none;
    }

    .ticker-search-item:hover,
    .ticker-search-item.active {
        background: rgba(var(--accent-rgb), 0.10);
        border-color: rgba(var(--accent-rgb), 0.25);
    }

    .ticker-search-symbol {
        font-weight: 700;
        color: #e5e7eb;
        letter-spacing: 0.2px;
    }

    .ticker-search-name {
        color: #9ca3af;
        font-size: 0.92em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        text-align: right;
    }

    .ticker-search-empty {
        padding: 10px 10px;
        color: #9ca3af;
        font-size: 0.92em;
    }

    .form-input:hover, .form-textarea:hover, .form-select:hover {
        border-color: rgba(42, 55, 95, 0.9);
    }

    .form-input:focus, .form-textarea:focus, .form-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(var(--accent-rgb), 0.1);
    }

    /* Date input: dark calendar panel + tinted calendar icon */
    .form-input[type="date"] {
        color-scheme: dark;
        accent-color: var(--accent);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator {
        cursor: pointer;
        opacity: 0.95;
        padding: 6px;
        border-radius: 8px;
        background-color: rgba(var(--accent-rgb), 0.14);
        filter: invert(1);
        transition: background-color 180ms ease, transform 180ms ease, opacity 180ms ease;
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:hover {
        background-color: rgba(var(--accent-rgb), 0.22);
        opacity: 1;
        transform: translateY(-1px);
    }

    .form-input[type="date"]::-webkit-calendar-picker-indicator:active {
        transform: translateY(0);
    }

    .form-input::placeholder, .form-textarea::placeholder {
        color: #666;
    }

    /* Select dropdown styling */
    .form-select {
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 40px;
    }

    .form-select option {
        background: #050816;
        color: #e0e0e0;
    }

    .form-textarea {
        resize: none;
        overflow-y: hidden;
    }

    .form-checkbox {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }

    /* Mini switch (Embed options + Optional fields) */
    .switch-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .switch-text {
        color: #e8ecff;
        font-weight: 500;
        font-size: 0.95em;
        cursor: pointer;
        user-select: none;
    }

    .mini-switch {
        position: relative;
        width: 40px;
        height: 22px;
        flex: 0 0 auto;
        display: inline-block;
    }

    .mini-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .mini-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .mini-slider::before {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 16px rgba(0, 0, 0, 0.28);
        transition: 180ms ease;
    }

    .mini-switch input:checked + .mini-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .mini-switch input:checked + .mini-slider::before {
        transform: translate(18px, -50%);
        background: var(--accent);
    }

    .mini-switch input:focus + .mini-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    /* Inner cards inside a form-section (Embed Options / Optional Fields) */
    .sub-card {
        margin-top: 20px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.50);
        border: 1px solid rgba(42, 55, 95, 0.55);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Toggle switch (Is_Shares) */
    .toggle-pill {
        display: flex;
        align-items: center;
        gap: 14px;
        width: 100%;
        padding: 14px 16px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        background: rgba(10, 16, 35, 0.62);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .toggle-switch {
        position: relative;
        width: 46px;
        height: 26px;
        flex: 0 0 auto;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        inset: 0;
        cursor: pointer;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.14);
        border: 1px solid rgba(42, 55, 95, 0.75);
        transition: 180ms ease;
    }

    .toggle-slider::before {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        left: 3px;
        top: 50%;
        transform: translateY(-50%);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
        transition: 180ms ease;
    }

    .toggle-switch input:checked + .toggle-slider {
        background: rgba(var(--accent-rgb), 0.35);
        border-color: rgba(var(--accent-rgb), 0.75);
    }

    .toggle-switch input:checked + .toggle-slider::before {
        transform: translate(20px, -50%);
        background: var(--accent);
    }

    .toggle-switch input:focus + .toggle-slider {
        box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.12);
    }

    .toggle-label {
        color: #e8ecff;
        font-weight: 600;
        font-size: 0.95em;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .btn-submit {
        background: var(--accent);
        color: #1a1a1a;
        padding: 15px 40px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(var(--accent-rgb), 0.3);
    }

    .btn-submit:hover {
        background: color-mix(in srgb, var(--accent) 85%, #ffffff 15%);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(var(--accent-rgb), 0.4);
    }

    .btn-submit:active {
        transform: translateY(0);
    }

    /* Trade Plan TP remove button (inline with label) */
    /* Take Profit row layout */
    .tp-level-row {
        background: rgba(10, 16, 35, 0.55);
        border: 1px solid rgba(42, 55, 95, 0.55);
        border-radius: 12px;
        padding: 12px;
    }

    .tp-level-row-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
    }

    .tp-level-row-header label {
        margin: 0;
        font-weight: 700;
        color: #e5e7eb;
    }

    .tp-level-row-body {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 14px;
    }

    .tp-remove-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: transparent;
        border: none;
        padding: 0;
        color: #ef4444;
        font-weight: 600;
        font-size: 0.92em;
        cursor: pointer;
        user-select: none;
    }

    .tp-remove-btn:hover {
        color: #f87171;
        text-decoration: underline;
    }

    .tp-remove-btn svg {
        width: 14px;
        height: 14px;
        display: block;
        fill: currentColor;
    }

    .tp-level-row-body .form-group {
        margin-bottom: 0;
        min-width: 0;
    }

    .tp-level-row-body .form-group label {
        margin-bottom: 6px;
        font-weight: 600;
        font-size: 0.88em;
        color: #9ca3af;
    }

    .percent-input-wrap {
        position: relative;
    }

    .percent-suffix {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #9ca3af;
        font-weight: 700;
        pointer-events: none;
    }

    /* Input with icon */
    .input-with-icon {
        position: relative;
    }

    .input-icon {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
        font-size: 18px;
    }

    .form-input.has-icon {
        padding-right: 40px;
    }

    .recent-signals {
        margin-top: 40px;
        padding-top: 40px;
        border-top: 2px solid #f0f0f0;
    }

    .recent-signals h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 1.8em;
    }

    .signal-card {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 15px;
        border-left: 4px solid #667eea;
        transition: all 0.3s;
    }

    .signal-card:hover {
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .signal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .signal-ticker {
        font-size: 1.3em;
        font-weight: 700;
        color: #333;
    }

    .signal-badge {
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
    }

    .badge-entry {
        background: #d4edda;
        color: #155724;
    }

    .badge-stop_loss {
        background: #f8d7da;
        color: #721c24;
    }

    .badge-take_profit {
        background: #d1ecf1;
        color: #0c5460;
    }

    .signal-info {
        color: #666;
        font-size: 0.95em;
        margin-top: 10px;
        white-space: pre-wrap;
    }

    .signal-time {
        color: #999;
        font-size: 0.85em;
    }

    /* Discord Preview Styles */
    .discord-embed {
        display: flex;
        background: #2f3136;
        border-radius: 4px;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .discord-embed-color-bar {
        width: 4px;
        background: #5865f2;
        flex-shrink: 0;
    }

    .discord-embed-content {
        flex: 1;
        padding: 12px 16px 12px 12px;
        color: #dcddde;
        font-size: 14px;
        line-height: 1.375;
    }

    .discord-embed-title {
        color: #ffffff;
        font-weight: 600;
        font-size: 16px;
        margin-bottom: 8px;
        min-height: 20px;
    }

    .discord-embed-title:empty {
        display: none;
    }

    .discord-embed-description {
        color: #dcddde;
        margin-bottom: 8px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .discord-embed-description:empty {
        display: none;
    }

    .discord-embed-fields {
        margin-top: 8px;
    }

    .discord-embed-field {
        margin-bottom: 8px;
    }

    .discord-embed-field-inline {
        flex: 0 0 calc(33.333% - 11px);
        max-width: calc(33.333% - 11px);
    }

    .discord-embed-field-name {
        color: #ffffff;
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 2px;
        min-height: 16px;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

    .discord-embed-field-name:empty {
        display: none;
    }

    .discord-embed-field-value {
        color: #dcddde;
        font-size: 14px;
        white-space: pre-wrap;
        word-wrap: break-word;
        min-height: 16px;
    }

    .discord-embed-field-value:empty {
        display: none;
    }

    .discord-embed-footer {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        color: #72767d;
        font-size: 12px;
        min-height: 14px;
    }

    .discord-embed-footer:empty {
        display: none;
    }

    /* Discord Markdown Styles */
    .discord-embed-title strong,
    .discord-embed-description strong,
    .discord-embed-field-name strong,
    .discord-embed-field-value strong,
    .discord-embed-footer strong {
        font-weight: 600;
    }

    .discord-embed-title em,
    .discord-embed-description em,
    .discord-embed-field-name em,
    .discord-embed-field-value em,
    .discord-embed-footer em {
        font-style: italic;
    }

    .discord-embed-title u,
    .discord-embed-description u,
    .discord-embed-field-name u,
    .discord-embed-field-value u,
    .discord-embed-footer u {
        text-decoration: underline;
    }

    .discord-embed-title s,
    .discord-embed-description s,
    .discord-embed-field-name s,
    .discord-embed-field-value s,
    .discord-embed-footer s {
        text-decoration: line-through;
    }

    .discord-embed-title code,
    .discord-embed-description code,
    .discord-embed-field-name code,
    .discord-embed-field-value code,
    .discord-embed-footer code {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.9em;
    }

    .discord-embed-title pre,
    .discord-embed-description pre,
    .discord-embed-field-name pre,
    .discord-embed-field-value pre,
    .discord-embed-footer pre {
        background: rgba(0, 0, 0, 0.3);
        padding: 8px;
        border-radius: 4px;
        margin: 4px 0;
        overflow-x: auto;
    }

    .discord-embed-title pre code,
    .discord-embed-description pre code,
    .discord-embed-field-name pre code,
    .discord-embed-field-value pre code,
    .discord-embed-footer pre code {
        background: none;
        padding: 0;
    }

    /* Error messages */
    .form-group .error-message {
        color: #f87171;
        margin-top: 5px;
        font-size: 0.9em;
    }

    /* Responsive design */
    @media (max-width: 1200px) {
        .content-layout {
            grid-template-columns: 1fr;
        }

        .form-container {
            max-width: 100%;
        }

        div[style*="position: sticky"] {
            width: 100% !important;
            position: relative !important;
            top: 0 !important;
            margin-top: 30px !important;
        }
    }

    @media (max-width: 768px) {
        .page-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 20px;
        }

        .page-actions {
            width: 100%;
            justify-content: flex-end;
        }
    }

    /* Trade Plan: centered modal (theme-matched) */
    .ctp-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 24px;
    }

    .ctp-modal-overlay.open {
        display: flex;
    }

    .ctp-modal {
        width: min(520px, 100%);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(42, 55, 95, 0.7);
        border-radius: 14px;
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        padding: 18px;
        color: #e5e7eb;
    }

    .ctp-modal-title {
        font-size: 1.35em;
        font-weight: 700;
        margin-bottom: 6px;
        color: #e0e0e0;
    }

    .ctp-modal-subtitle {
        font-size: 0.9em;
        color: #9ca3af;
        margin-bottom: 14px;
        line-height: 1.4;
    }

    .ctp-modal-actions {
        margin-top: 14px;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }

    /* Modal button sizing (smaller height than page CTAs) */
    .ctp-modal-actions .btn-cancel,
    .ctp-modal-actions .btn-submit {
        padding: 10px 16px;
        font-size: 0.95em;
        line-height: 1;
        border-radius: 10px;
        box-shadow: none;
    }

    .ctp-modal-error {
        margin-top: 8px;
        color: #f87171;
        font-size: 0.9em;
        display: none;
    }

    .ctp-modal-error.show {
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-page">
    <!-- Page Header -->
    <div class="page-header">
        <div class="page-title-section">
            <h1>Submit New Signal</h1>
            <p>Create and broadcast a new trading signal to your Discord community.</p>
        </div>
        <div class="page-actions">
            <a class="btn-cancel" href="{% url 'dashboard' %}">Cancel</a>
            <button type="submit" form="signalForm" class="btn-publish">
                <span>üì§</span>
                <span>Publish Signal</span>
            </button>
        </div>
    </div>

    <div class="content-layout">
        <div class="form-container">
            <form method="post" id="signalForm">
                {% csrf_token %}
                
                <!-- Signal Configuration Section -->
                <div class="form-section">
                    <div class="section-header">
                        <div class="section-icon blue"><img src="{% static 'signals/icons/layers.svg' %}" alt="" /></div>
                        <div class="section-title">Signal Configuration</div>
                    </div>
                    <div class="section-divider"></div>
                    
                    <div class="form-group">
                        <label for="{{ form.signal_type.id_for_label }}">Signal Type *</label>
                        {{ form.signal_type }}
                        {% if form.signal_type.errors %}
                            <div style="color: #f87171; margin-top: 5px; font-size: 0.9em;">{{ form.signal_type.errors }}</div>
                        {% endif %}
                    </div>

                    <!-- Discord Channel Selection -->
                    {% if discord_channels %}
                    <div class="form-group">
                        <label for="discord_channel">Destination Channel</label>
                        <div class="input-with-icon">
                            {% if discord_channels and discord_channels|length > 0 %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" required>
                                    {% for channel in discord_channels %}
                                    <option value="{{ channel.id }}" {% if channel.is_default %}selected{% elif forloop.first %}selected{% endif %}>
                                        {{ channel.channel_name }}{% if channel.is_default %} (Default){% endif %}
                                    </option>
                                    {% endfor %}
                                </select>
                            {% else %}
                                <select name="discord_channel" id="discord_channel" class="form-input has-icon" disabled>
                                    <option selected>No Discord channels configured</option>
                                </select>
                                <small style="display:block; margin-top:8px; color:#9ca3af;">Add a Discord channel in Settings / User Management, then refresh.</small>
                            {% endif %}
                            <span class="input-icon">üí¨</span>
                        </div>
                    </div>
                    {% endif %}

                    <!-- Trade Type Selection -->
                    <div class="form-group">
                        <label for="trade_type">Trade Type</label>
                        <div class="input-with-icon">
                            <select name="trade_type" id="trade_type" class="form-input has-icon" required>
                                <option value="Scalp" selected>Scalp</option>
                                <option value="Swing">Swing</option>
                                <option value="Leap">Leap</option>
                            </select>
                            <span class="input-icon">üéØ</span>
                        </div>
                    </div>
                </div>

                <!-- Trade Details Section -->
                <div class="form-section" id="tradeDetailsSection">
                    <div class="section-header">
                        <div class="section-icon green"><img src="{% static 'signals/icons/trending_up.svg' %}" alt="" /></div>
                        <div class="section-title">Trade Details</div>
                    </div>
                    <div class="section-divider"></div>

                    <!-- Dynamic Form Fields Container -->
                    <div id="dynamicFields"></div>
                    <!-- Searchable dropdown source for US ticker symbols -->
                    <datalist id="usTickerList"></datalist>

                    <!-- Embed Display Options -->
                    <div class="sub-card">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üì± Embed Display Options</div>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div class="switch-item">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showTitleCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showTitleCheckbox">Show title</label>
                            </div>
                            <div class="switch-item" style="display: none;">
                                <label class="mini-switch">
                                    <input type="checkbox" id="showDescriptionCheckbox" checked>
                                    <span class="mini-slider"></span>
                                </label>
                                <label class="switch-text" for="showDescriptionCheckbox">Show description</label>
                            </div>
                        </div>
                    </div>

                    <!-- Optional Fields Checkboxes -->
                    <div id="optionalFieldsSection" class="sub-card" style="display: none;">
                        <div style="color: #e0e0e0; font-size: 1em; margin-bottom: 12px; font-weight: 600;">üìã Optional Fields</div>
                        <div style="color: #888; font-size: 0.9em; margin-bottom: 15px;">Select which optional fields to include in your Discord message:</div>
                        <div id="optionalFieldsCheckboxesContainer" style="display: flex; flex-direction: column; gap: 10px;"></div>
                        <!-- Container for variables that become visible when optional fields are selected -->
                        <div id="optionalFieldsVariablesContainer" style="margin-top: 20px; display: none;">
                            <div style="color: #e0e0e0; font-size: 0.95em; margin-bottom: 12px; font-weight: 600; padding-top: 15px; border-top: 1px solid #2d2d2d;">üìù Related Variables</div>
                        </div>
                    </div>
                </div>

                

                <!-- Hidden field for data -->
                <input type="hidden" name="data" id="id_data" value="{}" />
                {% if form.data.errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.data.errors }}
                    </div>
                {% endif %}
                {% if form.non_field_errors %}
                    <div style="color: #f87171; margin-top: 10px; margin-bottom: 10px; padding: 10px; background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.2); border-radius: 5px; font-size: 0.9em;">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}
            </form>
        </div>

        <!-- Live Preview Section -->
        <div style="position: sticky; top: 90px; width: 100%; z-index: 10;">
            <div class="form-section" style="margin-bottom: 0;">
                <div class="section-header" style="margin-bottom: 0;">
                    <div class="section-icon purple"><img src="{% static 'signals/icons/eye.svg' %}" alt="" /></div>
                    <div class="section-title">Live Preview</div>
                </div>
                <div class="section-divider"></div>
                <div id="discordPreview" style="max-width: 100%; margin: 0 auto;">
                    <div id="optionalFieldsControls" style="margin-bottom: 15px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 6px; display: none;">
                        <div style="color: #dcddde; font-size: 0.85em; margin-bottom: 8px; font-weight: 600;">Optional Fields:</div>
                        <div id="optionalFieldsCheckboxes" style="display: flex; flex-direction: column; gap: 8px;"></div>
                    </div>
                    <div class="discord-embed">
                        <div class="discord-embed-color-bar" id="previewColorBar"></div>
                        <div class="discord-embed-content">
                            <div class="discord-embed-title" id="previewTitle">Select a signal type to see preview</div>
                            <div class="discord-embed-description" id="previewDescription"></div>
                            <div class="discord-embed-fields" id="previewFields"></div>
                            <div class="discord-embed-footer" id="previewFooter"></div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px; display: flex; align-items: start; gap: 10px;">
                        <span style="color: #60a5fa; font-size: 18px;">‚ÑπÔ∏è</span>
                        <p style="color: #9ca3af; font-size: 0.85em; margin: 0; line-height: 1.5;">This is how your signal will appear in Discord. Update the form to see changes in real-time.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% if recent_signals %}
<div class="form-container" style="margin-top: 40px;">
    <div class="recent-signals">
        <h2>üìä Recent Signals</h2>
        {% for signal in recent_signals %}
        <div class="signal-card">
            <div class="signal-header">
                <span class="signal-ticker">{{ signal.data.ticker }}</span>
                <span class="signal-badge badge-{{ signal.signal_type.name|lower|slugify }}">
                    {{ signal.signal_type.name }}
                </span>
            </div>
            <div class="signal-info">
                <strong>Strike:</strong> {{ signal.data.strike }} | <strong>Expiration:</strong> {{ signal.data.expiration }}
            </div>
            {% if signal.data.extra_info %}
            <div class="signal-info">
                <strong>Extra:</strong> {{ signal.data.extra_info|truncatewords:20 }}
            </div>
            {% endif %}
            <div class="signal-time">{{ signal.created_at|date:"M d, Y H:i" }}</div>
        </div>
        {% endfor %}
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
{{ signal_types_data|json_script:"signal-types-data" }}
{{ trade_plan_presets|json_script:"trade-plan-presets-data" }}
<script>
// Store signal types data with full template information (Django json_script)
const signalTypesDataList = JSON.parse(document.getElementById('signal-types-data').textContent || '[]');
const signalTypesData = {};
signalTypesDataList.forEach((st) => {
    signalTypesData[String(st.id)] = st;
});

// Per-user saved Trade Plan presets (dropdown)
let tradePlanPresets = JSON.parse(document.getElementById('trade-plan-presets-data')?.textContent || '[]');
if (!Array.isArray(tradePlanPresets)) tradePlanPresets = [];

// If we just created a preset (Save As), we persist the id through reload
// so the dropdown can auto-select it after the page rerenders.
let pendingTradePlanPresetId = '';
try {
    pendingTradePlanPresetId = String(sessionStorage.getItem('ctp_selected_preset_id') || '');
} catch (_) {
    pendingTradePlanPresetId = '';
}

function consumePendingTradePlanPresetId() {
    const v = String(pendingTradePlanPresetId || '');
    pendingTradePlanPresetId = '';
    try { sessionStorage.removeItem('ctp_selected_preset_id'); } catch (_) {}
    return v;
}

// Debug: Log signalTypesData to console
console.log('signalTypesData loaded:', signalTypesData);
console.log('Number of signal types:', Object.keys(signalTypesData).length);

// --- CSRF helper for same-origin POSTs (Django) ---
function getCookie(name) {
    const cookies = document.cookie ? document.cookie.split(';') : [];
    for (let i = 0; i < cookies.length; i++) {
        const c = cookies[i].trim();
        if (c.startsWith(name + '=')) return decodeURIComponent(c.substring(name.length + 1));
    }
    return '';
}

function getCsrfToken() {
    return getCookie('csrftoken');
}

async function tradePlanApi(reqPayload) {
    const res = await fetch('/api/trade-plan/', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCsrfToken(),
        },
        body: JSON.stringify(reqPayload || {}),
    });
    const respPayload = await res.json().catch(() => ({}));
    if (!res.ok) {
        const msg = respPayload?.error || 'Failed to save Trade Plan';
        throw new Error(msg);
    }
    return respPayload;
}

function getDefaultTradePlanPreset() {
    const d = tradePlanPresets.find(p => p && p.is_default);
    return d || tradePlanPresets[0] || null;
}

function getInitialTradePlanPreset() {
    const pendingId = consumePendingTradePlanPresetId();
    if (pendingId) {
        const p = tradePlanPresets.find(x => x && String(x.id) === String(pendingId));
        if (p) return p;
    }
    return getDefaultTradePlanPreset();
}

// Track visibility of optional fields (default: hidden)
const optionalFieldsVisibility = {};

// Cached US ticker list for searchable dropdowns (datalist)
let usTickersLoaded = false;
let usTickersLoadingPromise = null;

function ensureUsTickersLoaded() {
    if (usTickersLoaded) return Promise.resolve(true);
    if (usTickersLoadingPromise) return usTickersLoadingPromise;

    const listEl = document.getElementById('usTickerList');
    if (!listEl) {
        usTickersLoaded = true;
        return Promise.resolve(false);
    }

    usTickersLoadingPromise = fetch('/api/us-tickers/', { credentials: 'same-origin' })
        .then((res) => res.ok ? res.json() : Promise.reject(new Error('Failed to load tickers')))
        .then((payload) => {
            const tickers = Array.isArray(payload?.tickers) ? payload.tickers : [];
            // Populate datalist with <option value="AAPL">Apple Inc.</option>
            listEl.innerHTML = '';
            tickers.forEach((t) => {
                const sym = String(t?.symbol || '').trim().toUpperCase();
                if (!sym) return;
                const opt = document.createElement('option');
                opt.value = sym;
                const name = String(t?.name || '').trim();
                if (name) opt.label = name;
                listEl.appendChild(opt);
            });
            usTickersLoaded = true;
            return true;
        })
        .catch((e) => {
            console.warn('Ticker list load failed:', e);
            usTickersLoaded = true; // Don't keep retrying aggressively
            return false;
        });

    return usTickersLoadingPromise;
}

// --- Ticker search (typeahead) ---
function debounce(fn, waitMs) {
    let t = null;
    return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), waitMs);
    };
}

function getTodayISODate() {
    // YYYY-MM-DD in local time
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}

function autoResizeTextarea(textarea) {
    if (!textarea) return;
    // Grow/shrink based on content; prevent inner scrollbars.
    textarea.style.height = 'auto';
    textarea.style.overflowY = 'hidden';
    textarea.style.height = `${textarea.scrollHeight}px`;
}

function wireAutoResizeTextareas(root = document) {
    const textareas = root.querySelectorAll ? root.querySelectorAll('textarea.form-textarea') : [];
    textareas.forEach((ta) => {
        // Avoid attaching multiple times
        if (ta.dataset.autosizeWired === '1') return;
        ta.dataset.autosizeWired = '1';
        ta.style.resize = 'none';
        ta.style.overflowY = 'hidden';
        ta.addEventListener('input', () => autoResizeTextarea(ta));
        // Initial sizing
        setTimeout(() => autoResizeTextarea(ta), 0);
    });
}

// Cache last fetched metadata per symbol so live preview can show company_name/stock_price
const tickerMetaCache = {};

async function fetchTickerSearch(query, { limit = 40, signal } = {}) {
    const q = String(query || '').trim();
    const url = `/api/us-tickers/?source=tradingview&q=${encodeURIComponent(q)}&limit=${encodeURIComponent(String(limit || 40))}`;
    const res = await fetch(url, { credentials: 'same-origin', signal });
    if (!res.ok) throw new Error('Failed to search tickers');
    const payload = await res.json();
    const tickers = Array.isArray(payload?.tickers) ? payload.tickers : [];
    return tickers
        .map(t => ({
            symbol: String(t?.symbol || '').trim().toUpperCase(),
            name: String(t?.name || '').trim()
        }))
        .filter(t => t.symbol);
}

function createTickerSearchControl(variable) {
    const wrap = document.createElement('div');
    wrap.className = 'ticker-search';

    const input = document.createElement('input');
    input.className = 'form-input';
    input.type = 'text';
    input.autocomplete = 'off';
    input.spellcheck = false;
    input.placeholder = variable.hint || 'Search ticker (e.g., AAPL, TSLA)';

    const dropdown = document.createElement('div');
    dropdown.className = 'ticker-search-dropdown';

    wrap.appendChild(input);
    wrap.appendChild(dropdown);

    let activeIndex = -1;
    let currentItems = [];
    let abortController = null;
    let suppressSearch = false;

    function closeDropdown() {
        dropdown.classList.remove('open');
        activeIndex = -1;
    }

    function openDropdown() {
        dropdown.classList.add('open');
    }

    function renderItems(items, { loading = false } = {}) {
        dropdown.innerHTML = '';
        currentItems = items;
        activeIndex = -1;

        if (loading) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = 'Searching...';
            dropdown.appendChild(empty);
            openDropdown();
            return;
        }

        if (!items || items.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = input.value.trim() ? 'No matches.' : 'Start typing to search tickers.';
            dropdown.appendChild(empty);
            openDropdown();
            return;
        }

        items.forEach((t, idx) => {
            const row = document.createElement('div');
            row.className = 'ticker-search-item';
            row.setAttribute('role', 'option');
            row.dataset.index = String(idx);

            const sym = document.createElement('div');
            sym.className = 'ticker-search-symbol';
            sym.textContent = t.symbol;

            const name = document.createElement('div');
            name.className = 'ticker-search-name';
            name.textContent = t.name || '';

            row.appendChild(sym);
            row.appendChild(name);

            const selectItem = (e) => {
                // Prevent blur-before-select on some browsers.
                if (e && typeof e.preventDefault === 'function') e.preventDefault();
                suppressSearch = true;
                input.value = t.symbol;
                closeDropdown();
                // Trigger preview + hidden JSON update paths without re-opening the dropdown search.
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                // Drop focus to make it feel like a "selection".
                try { input.blur(); } catch (_) {}
                // Re-enable searching after this tick.
                setTimeout(() => { suppressSearch = false; }, 0);
            };

            row.addEventListener('pointerdown', selectItem);
            row.addEventListener('mousedown', selectItem);
            row.addEventListener('click', selectItem);

            dropdown.appendChild(row);
        });

        openDropdown();
    }

    const doSearch = debounce(async () => {
        const q = input.value.trim();
        if (abortController) abortController.abort();
        abortController = new AbortController();
        renderItems([], { loading: true });
        try {
            const items = await fetchTickerSearch(q, { limit: 40, signal: abortController.signal });
            renderItems(items);
        } catch (e) {
            if (String(e?.name) === 'AbortError') return;
            console.warn('Ticker search failed:', e);
            renderItems([]);
        }
    }, 140);

    input.addEventListener('focus', () => {
        // Show suggestions box (empty state) immediately.
        renderItems(currentItems || []);
    });

    input.addEventListener('blur', () => {
        // Allow click selection first.
        setTimeout(() => closeDropdown(), 120);
    });

    input.addEventListener('input', () => {
        if (suppressSearch) return;
        doSearch();
    });

    input.addEventListener('keydown', (e) => {
        if (!dropdown.classList.contains('open')) return;
        const items = Array.from(dropdown.querySelectorAll('.ticker-search-item'));
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIndex = Math.min(activeIndex + 1, items.length - 1);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIndex = Math.max(activeIndex - 1, 0);
        } else if (e.key === 'Enter') {
            if (activeIndex >= 0 && currentItems[activeIndex]) {
                e.preventDefault();
                suppressSearch = true;
                input.value = currentItems[activeIndex].symbol;
                closeDropdown();
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                try { input.blur(); } catch (_) {}
                setTimeout(() => { suppressSearch = false; }, 0);
            }
            return;
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDropdown();
            return;
        } else {
            return;
        }

        items.forEach((el, idx) => el.classList.toggle('active', idx === activeIndex));
        const activeEl = items[activeIndex];
        if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
    });

    return { wrap, input };
}

function createSelectDropdownControlFromSelect(selectEl, { placeholder = '' } = {}) {
    const wrap = document.createElement('div');
    wrap.className = 'ticker-search';

    const input = document.createElement('input');
    input.className = 'form-input';
    input.type = 'text';
    input.autocomplete = 'off';
    input.spellcheck = false;
    input.placeholder = placeholder || 'Select...';
    input.dataset.ignoreDynamic = '1'; // Important: don't include in signalData JSON

    const dropdown = document.createElement('div');
    dropdown.className = 'ticker-search-dropdown';

    wrap.appendChild(input);
    wrap.appendChild(dropdown);

    const options = Array.from(selectEl.options || []).map(o => ({
        value: String(o.value),
        label: String(o.textContent || '').trim(),
        disabled: !!o.disabled,
    }));

    let activeIndex = -1;
    let currentItems = [];

    function closeDropdown() {
        dropdown.classList.remove('open');
        activeIndex = -1;
    }

    function openDropdown() {
        dropdown.classList.add('open');
    }

    function renderItems(items) {
        dropdown.innerHTML = '';
        currentItems = items;
        activeIndex = -1;

        if (!items.length) {
            const empty = document.createElement('div');
            empty.className = 'ticker-search-empty';
            empty.textContent = 'No results';
            dropdown.appendChild(empty);
            return;
        }

        items.forEach((it, idx) => {
            const row = document.createElement('div');
            row.className = 'ticker-search-item';
            row.dataset.index = String(idx);

            const left = document.createElement('div');
            left.className = 'ticker-search-symbol';
            left.textContent = it.label || it.value;

            row.appendChild(left);

            if (it.disabled) {
                row.style.opacity = '0.6';
                row.style.pointerEvents = 'none';
            } else {
                row.addEventListener('mousedown', (e) => {
                    // Use mousedown to beat blur
                    e.preventDefault();
                    selectEl.value = it.value;
                    input.value = it.label || it.value;
                    selectEl.dispatchEvent(new Event('input', { bubbles: true }));
                    selectEl.dispatchEvent(new Event('change', { bubbles: true }));
                    closeDropdown();
                    // Drop focus so next click/focus re-opens as expected
                    try { input.blur(); } catch (_) {}
                });
            }

            dropdown.appendChild(row);
        });
    }

    function syncFromSelect() {
        const selOpt = selectEl.options[selectEl.selectedIndex];
        const label = selOpt ? String(selOpt.textContent || '').trim() : '';
        input.value = label || String(selectEl.value || '');
    }

    function filteredOptions(query) {
        const q = String(query || '').trim().toLowerCase();
        if (!q) return options.filter(o => o.value !== '');
        return options.filter(o => (o.label || o.value).toLowerCase().includes(q));
    }

    input.addEventListener('focus', () => {
        if (selectEl.disabled) return;
        // Show all options on open (unlike ticker search). Filter only after typing.
        renderItems(options.filter(o => o.value !== ''));
        openDropdown();
    });

    input.addEventListener('input', () => {
        if (selectEl.disabled) return;
        renderItems(filteredOptions(input.value));
        openDropdown();
    });

    input.addEventListener('keydown', (e) => {
        if (!dropdown.classList.contains('open')) {
            if (e.key === 'ArrowDown' || e.key === 'Enter') {
                e.preventDefault();
                // Show all options on open; user can type to filter afterwards.
                renderItems(options.filter(o => o.value !== ''));
                openDropdown();
            }
            return;
        }

        const items = Array.from(dropdown.querySelectorAll('.ticker-search-item'));
        if (!items.length) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            activeIndex = Math.min(activeIndex + 1, items.length - 1);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            activeIndex = Math.max(activeIndex - 1, 0);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            const it = currentItems[activeIndex];
            if (it && !it.disabled) {
                selectEl.value = it.value;
                input.value = it.label || it.value;
                selectEl.dispatchEvent(new Event('input', { bubbles: true }));
                selectEl.dispatchEvent(new Event('change', { bubbles: true }));
                closeDropdown();
                try { input.blur(); } catch (_) {}
            }
            return;
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeDropdown();
            return;
        } else {
            return;
        }

        items.forEach((el, idx) => el.classList.toggle('active', idx === activeIndex));
        const activeEl = items[activeIndex];
        if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
    });

    input.addEventListener('blur', () => {
        // Small delay so click can register
        setTimeout(() => closeDropdown(), 120);
    });

    // Mirror select state (in case code updates it)
    selectEl.addEventListener('change', syncFromSelect);

    // Init
    syncFromSelect();

    // Disabled?
    if (selectEl.disabled) {
        input.disabled = true;
    }

    return { wrap, input };
}

function upgradeSelectToTickerDropdown(selectEl, { placeholder = '' } = {}) {
    if (!selectEl || selectEl.dataset.upgradedDropdown === '1') return null;
    selectEl.dataset.upgradedDropdown = '1';

    const control = createSelectDropdownControlFromSelect(selectEl, { placeholder });
    // Hide original select but keep it for form submission.
    selectEl.style.display = 'none';
    selectEl.insertAdjacentElement('afterend', control.wrap);
    return control;
}

// Auto-fill helpers (avoid overwriting user edits)
function markUserTouched(el) {
    if (!el) return;
    el.dataset.userTouched = '1';
    if (el.dataset.autoFilled === '1') el.dataset.autoFilled = '0';
}

function canAutoFill(el) {
    if (!el) return false;
    return el.dataset.userTouched !== '1';
}

function setValueIfAllowed(el, value) {
    if (!el) return false;
    const v = (value === null || value === undefined) ? '' : String(value);
    const isEmpty = !String(el.value || '').trim();
    const wasAuto = el.dataset.autoFilled === '1';
    if (!canAutoFill(el)) return false;
    if (!isEmpty && !wasAuto) return false;

    el.value = v;
    el.dataset.autoFilled = '1';
    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
    return true;
}

function formatFloat3(value) {
    if (value === null || value === undefined) return '';
    const n = Number(value);
    if (!Number.isFinite(n)) return String(value);
    return n.toFixed(3);
}

function parsePercent(value) {
    const s = String(value ?? '').trim();
    if (!s) return NaN;
    const cleaned = s.endsWith('%') ? s.slice(0, -1) : s;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : NaN;
}

const MAX_TP_LEVELS = 6;

function updateTpSlPrices() {
    // Base is the option entry price if available.
    const optionPriceEl = findFieldByName('option_price');
    const entryPriceEl = findFieldByName('entry_price');
    const priceEl = findFieldByName('price');
    const baseRaw = (optionPriceEl && optionPriceEl.value) || (entryPriceEl && entryPriceEl.value) || (priceEl && priceEl.value) || '';
    const base = Number(String(baseRaw).trim());
    if (!Number.isFinite(base) || base <= 0) return;

    const slPer = parsePercent(findFieldByName('sl_per')?.value);

    const slPriceEl = findFieldByName('sl_price');

    for (let i = 1; i <= MAX_TP_LEVELS; i++) {
        const modeEl = findFieldByName(`tp${i}_mode`);
        const mode = String(modeEl ? modeEl.value : '').trim().toLowerCase();
        // If TP is defined as an underlying stock price target, don't compute option tp_price.
        if (mode === 'stock' || mode === 'stock_price' || mode === 'underlying' || mode === 'share_price') {
            continue;
        }
        const perEl = findFieldByName(`tp${i}_per`);
        const priceElN = findFieldByName(`tp${i}_price`);
        if (!perEl || !priceElN) continue;
        const tpPer = parsePercent(perEl.value);
        if (Number.isFinite(tpPer)) {
            setValueIfAllowed(priceElN, formatFloat3(base * (1 + tpPer / 100)));
        }
    }
    if (Number.isFinite(slPer)) setValueIfAllowed(slPriceEl, formatFloat3(base * (1 - slPer / 100)));
}

// When Target Type = Stock price ($), default TP stock targets to +10%/+20%/+30%
// of the current underlying stock price (without overwriting user edits).
function updateDefaultTpStockTargets() {
    const modeEl = findFieldByName('tp1_mode');
    const mode = String(modeEl ? modeEl.value : '').trim().toLowerCase();
    const isStock = mode === 'stock' || mode === 'stock_price' || mode === 'underlying' || mode === 'share_price';
    if (!isStock) return;

    const sym = getCurrentTickerSymbol();
    const cached = sym ? tickerMetaCache[sym] : null;
    const currentPriceEl = findFieldByName('current_price');
    const baseRaw = (currentPriceEl && currentPriceEl.value) || (cached && cached.price != null ? cached.price : '');
    const base = Number(String(baseRaw).trim());
    // Allow base=0 so defaults still show as $0.00 when price isn't available yet.
    if (!Number.isFinite(base) || base < 0) return;

    // If option type is PUT, defaults should be -10%/-20%/-30%
    const optTypeEl = findFieldByName('option_type');
    const optTypeRaw = String(optTypeEl ? optTypeEl.value : '').trim().toLowerCase();
    const isPut = optTypeRaw.includes('put');

    const defaults = [10, 20, 30];
    for (let i = 1; i <= defaults.length; i++) {
        const el = findFieldByName(`tp${i}_stock_price`);
        if (!el) continue;
        const dir = isPut ? -1 : 1;
        const target = (base * (1 + dir * defaults[i - 1] / 100));
        setValueIfAllowed(el, target.toFixed(2));
    }
}

function findFieldByName(name) {
    return document.querySelector(`#dynamicFields [name="${CSS.escape(name)}"], #optionalFieldsVariablesContainer [name="${CSS.escape(name)}"]`);
}

function getCurrentTickerSymbol() {
    const el = findFieldByName('ticker') || findFieldByName('symbol');
    const v = el ? String(el.value || '').trim().toUpperCase() : '';
    return v;
}

async function fetchQuote(symbol) {
    const sym = String(symbol || '').trim().toUpperCase();
    if (!sym) return null;
    const res = await fetch(`/api/quote/?symbol=${encodeURIComponent(sym)}`, { credentials: 'same-origin' });
    if (!res.ok) return null;
    const payload = await res.json();
    return payload && payload.price != null ? payload : null;
}

async function fetchOptionQuote(symbol, { strike, expiration, side } = {}) {
    const sym = String(symbol || '').trim().toUpperCase();
    const exp = String(expiration || '').trim();
    const s = String(side || '').trim().toLowerCase();
    const k = strike;
    if (!sym || !exp || !k || !['call','put'].includes(s)) return null;
    const url = `/api/option-quote/?symbol=${encodeURIComponent(sym)}&expiration=${encodeURIComponent(exp)}&strike=${encodeURIComponent(String(k))}&side=${encodeURIComponent(s)}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) {
        // Best-effort debug info (shows up in browser console)
        try {
            const errPayload = await res.json();
            console.warn('Option quote failed:', res.status, errPayload);
        } catch (_) {
            console.warn('Option quote failed:', res.status);
        }
        return null;
    }
    const payload = await res.json();
    return payload && payload.price != null ? payload : null;
}

function getSelectedTradeType() {
    const el = document.getElementById('trade_type');
    return String(el ? el.value : '').trim().toLowerCase() || 'swing';
}

async function fetchBestOption(symbol, { tradeType, side } = {}) {
    const sym = String(symbol || '').trim().toUpperCase();
    const tt = String(tradeType || '').trim().toLowerCase() || 'swing';
    const s = String(side || '').trim().toLowerCase() || 'call';
    if (!sym || !['call','put'].includes(s)) return null;
    const url = `/api/best-option/?symbol=${encodeURIComponent(sym)}&trade_type=${encodeURIComponent(tt)}&side=${encodeURIComponent(s)}`;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) {
        try {
            const errPayload = await res.json();
            console.warn('Best option failed:', res.status, errPayload);
        } catch (_) {
            console.warn('Best option failed:', res.status);
        }
        return null;
    }
    return await res.json();
}

async function maybeAutoPickBestOption() {
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    if (isShares) return;

    const sym = getCurrentTickerSymbol();
    if (!sym) return;

    const optTypeEl = findFieldByName('option_type');
    const raw = optTypeEl ? String(optTypeEl.value || '').trim().toLowerCase() : '';
    const side = raw.includes('put') ? 'put' : (raw.includes('call') ? 'call' : 'call');
    const tradeType = getSelectedTradeType();

    const best = await fetchBestOption(sym, { tradeType, side });
    if (!best || best.error) return;

    const strikeEl = findFieldByName('strike');
    const expEl = findFieldByName('expiration');
    const optionPriceEl = findFieldByName('option_price');
    const entryPriceEl = findFieldByName('entry_price');
    const priceEl = findFieldByName('price');
    const contractEl = findFieldByName('option_contract');

    setValueIfAllowed(strikeEl, best.strike);
    setValueIfAllowed(expEl, best.expiration);
    setValueIfAllowed(optionPriceEl, formatFloat3(best.option_price));
    setValueIfAllowed(entryPriceEl, formatFloat3(best.option_price));
    setValueIfAllowed(priceEl, formatFloat3(best.option_price));
    setValueIfAllowed(contractEl, best.contract);

    updateTpSlPrices();
    updatePreview();
}

// Map variable types to input field types
function getInputType(variableType) {
    const typeMap = {
        'string': 'text',
        'number': 'number',
        'float': 'number',
        'date': 'date',
        'text': 'textarea',
        'boolean': 'checkbox',
        'ticker_type': 'text'
    };
    return typeMap[variableType] || 'text';
}

// Treat optional flags robustly (boolean true vs string "true")
function isTruthyOptionalFlag(value) {
    return value === true || value === 'true' || value === 1 || value === '1';
}

function isOptionalField(field) {
    return field && isTruthyOptionalFlag(field.optional);
}

function getNonRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        // v is typically an object: {name, required, ...}
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        // Treat missing required as false (non-required)
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required !== true) set.add(String(name));
    });
    return set;
}

function getRequiredVariableSet(signalType) {
    const set = new Set();
    const vars = (signalType && Array.isArray(signalType.variables)) ? signalType.variables : [];
    vars.forEach((v) => {
        const name = (v && typeof v === 'object') ? v.name : null;
        if (!name) return;
        const required = (v && typeof v === 'object') ? v.required : false;
        if (required === true) set.add(String(name));
    });
    return set;
}

function getFieldReferencedVariables(field) {
    const vars = new Set();
    extractVariablesFromTemplate(field?.name || '').forEach(v => vars.add(v));
    extractVariablesFromTemplate(field?.value || '').forEach(v => vars.add(v));
    return vars;
}

function fieldReferencesAnyRequiredVariable(field, signalType) {
    const required = getRequiredVariableSet(signalType);
    if (required.size === 0) return false;
    const vars = getFieldReferencedVariables(field);
    for (const v of vars) {
        if (required.has(v)) return true;
    }
    return false;
}

function isInferredOptionalField(field, signalType) {
    if (!field || !signalType) return false;
    const nonRequired = getNonRequiredVariableSet(signalType);
    if (nonRequired.size === 0) return false;

    const vars = getFieldReferencedVariables(field);

    // Only infer optional if the field actually depends on variables,
    // and ALL referenced variables are non-required (so required info isn't hideable).
    if (vars.size === 0) return false;
    for (const v of vars) {
        if (!nonRequired.has(v)) return false;
    }
    return true;
}

function isOptionalFieldForSignalType(field, signalType) {
    // Guardrail: required-variable fields should never be hideable
    if (fieldReferencesAnyRequiredVariable(field, signalType)) return false;

    // Honor explicit optional OR inferred optional (non-required variables only)
    return isOptionalField(field) || isInferredOptionalField(field, signalType);
}

// Get label from variable or fall back to default
function getLabel(variable) {
    // If variable has a label property, use it
    if (variable.label) {
        return variable.label;
    }
    // Otherwise, capitalize the name
    const name = variable.name || variable;
    return name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
}

// Parse Discord markdown to HTML
function parseDiscordMarkdown(text) {
    if (!text) return '';
    
    // Escape HTML first to prevent XSS
    let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    
    // Code blocks (```code```) - must be processed before inline code
    html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
    
    // Inline code (`code`) - protect code from other markdown
    const codeBlocks = [];
    html = html.replace(/`([^`\n]+)`/g, (match, code) => {
        const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
        codeBlocks.push(`<code>${code}</code>`);
        return placeholder;
    });
    
    // Bold and italic combinations (***text***)
    html = html.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
    
    // Bold (**text**)
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // Bold (__text__) - Discord uses __ for bold
    html = html.replace(/__(?![_*])([^_]+)__(?![_*])/g, '<strong>$1</strong>');
    
    // Italic (*text*)
    html = html.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em>$1</em>');
    
    // Italic (_text_) - but not if it's part of bold
    html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');
    
    // Strikethrough (~~text~~)
    html = html.replace(/~~([^~]+)~~/g, '<s>$1</s>');
    
    // Restore code blocks
    codeBlocks.forEach((code, index) => {
        html = html.replace(`__CODE_BLOCK_${index}__`, code);
    });
    
    // Preserve newlines as <br>
    html = html.replace(/\n/g, '<br>');
    
    return html;
}

// Render template by replacing {% templatetag openvariable %}variable{% templatetag closevariable %} placeholders (supports {% templatetag openvariable %}var::stock_price{% templatetag closevariable %})
function renderTemplate(template, data) {
    if (!template) return '';
    return template.replace(/\{\{(\w+)(?:::(\w+))?\}\}/g, (match, varName, modifier) => {
        if (modifier === 'stock_price') {
            // For preview: use whichever price field exists in the form data (already auto-filled).
            const p = data.current_price ?? data.entry_price ?? data.price;
            if (p !== undefined && p !== null && String(p).trim() !== '') return formatFloat3(p);
            const sym = (data && data[varName]) ? String(data[varName]).trim().toUpperCase() : '';
            const cached = sym ? tickerMetaCache[sym] : null;
            return (cached && cached.price != null) ? formatFloat3(cached.price) : '0.000';
        }
        if (modifier === 'company_name') {
            // Preview: use a provided company_name if present, else use cached metadata.
            const name = data.company_name;
            if (name !== undefined && name !== null && String(name).trim() !== '') return String(name);
            const sym = (data && data[varName]) ? String(data[varName]).trim().toUpperCase() : '';
            const cached = sym ? tickerMetaCache[sym] : null;
            return (cached && cached.company_name) ? String(cached.company_name) : 'Company Name';
        }
        if (modifier === 'option_price') {
            // Shares mode: options are disabled, so remove option_price from preview entirely.
            const isSharesCheckbox = document.getElementById('id_is_shares');
            const isShares = isSharesCheckbox && isSharesCheckbox.checked;
            if (isShares) return '';

            // Prefer explicit fields if present; default to 0.0
            const v = data.option_price ?? data.entry_price ?? data.price;
            return (v !== undefined && v !== null && String(v).trim() !== '') ? formatFloat3(v) : '0.000';
        }
        if (modifier && ['tp1_per','tp2_per','tp3_per','tp4_per','tp5_per','tp6_per','sl_per','tp1_takeoff_per','tp2_takeoff_per','tp3_takeoff_per','tp4_takeoff_per','tp5_takeoff_per','tp6_takeoff_per'].includes(modifier)) {
            const v = data[modifier];
            if (v === undefined || v === null || String(v).trim() === '') return '0%';
            const s = String(v).trim();
            return s.endsWith('%') ? s : `${s}%`;
        }
        if (modifier && ['tp1_price','tp2_price','tp3_price','tp4_price','tp5_price','tp6_price','sl_price'].includes(modifier)) {
            const v = data[modifier];
            return (v !== undefined && v !== null && String(v).trim() !== '') ? formatFloat3(v) : '0.000';
        }
        if (modifier && ['tp1_stock_price','tp2_stock_price','tp3_stock_price','tp4_stock_price','tp5_stock_price','tp6_stock_price'].includes(modifier)) {
            const v = data[modifier];
            if (v === undefined || v === null || String(v).trim() === '') return '';
            const n = Number(String(v).trim());
            return Number.isFinite(n) ? n.toFixed(2) : String(v);
        }
        if (modifier && (modifier in data)) {
            // Allow {% templatetag openvariable %}ticker::strike{% templatetag closevariable %} style access (treat modifier as the real variable name).
            const v = data[modifier];
            return (v !== undefined && v !== null) ? String(v) : '';
        }
        return data[varName] !== undefined ? String(data[varName]) : match;
    });
}

// Extract all variable names from a template string
function extractVariablesFromTemplate(template) {
    if (!template) return [];
    const variables = [];
    const regex = /\{\{(\w+)(?:::(\w+))?\}\}/g;
    let match;
    while ((match = regex.exec(template)) !== null) {
        // Track base variable name and (for certain modifiers) also track the modifier as a "real" variable.
        const base = match[1];
        const modifier = match[2];
        if (base && !variables.includes(base)) variables.push(base);

        // If template uses {% templatetag openvariable %}ticker::strike{% templatetag closevariable %},
        // treat "strike" as a used variable so the strike input is shown.
        if (modifier && ['is_shares', 'strike', 'expiration', 'option_type',
            'tp1_per', 'tp2_per', 'tp3_per', 'tp4_per', 'tp5_per', 'tp6_per',
            'tp1_mode', 'tp2_mode', 'tp3_mode', 'tp4_mode', 'tp5_mode', 'tp6_mode',
            'tp1_stock_price', 'tp2_stock_price', 'tp3_stock_price', 'tp4_stock_price', 'tp5_stock_price', 'tp6_stock_price',
            'tp1_takeoff_per', 'tp2_takeoff_per', 'tp3_takeoff_per', 'tp4_takeoff_per', 'tp5_takeoff_per', 'tp6_takeoff_per',
            'sl_per',
            'tp1_price', 'tp2_price', 'tp3_price', 'tp4_price', 'tp5_price', 'tp6_price', 'sl_price'
        ].includes(modifier)) {
            if (!variables.includes(modifier)) variables.push(modifier);
        }
    }
    return variables;
}

// Get all variables that are currently used in visible templates and fields
function getUsedVariables(signalTypeId) {
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) return { all: new Set(), optionalOnly: new Set() };
    
    const usedVariables = new Set();
    const optionalOnlyVariables = new Set();
    
    // Track variables used in non-optional contexts
    const nonOptionalVariables = new Set();
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Check title template (if visible)
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    if (showTitle && signalType.title_template) {
        extractVariablesFromTemplate(signalType.title_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check description template (if visible)
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    if (showDescription && signalType.description_template) {
        extractVariablesFromTemplate(signalType.description_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check footer template
    if (signalType.footer_template) {
        extractVariablesFromTemplate(signalType.footer_template).forEach(v => {
            usedVariables.add(v);
            nonOptionalVariables.add(v);
        });
    }
    
    // Check fields template (considering optional fields and is_shares)
    if (signalType.fields_template) {
        let fields = signalType.fields_template;
        if (typeof fields === 'string') {
            try {
                fields = JSON.parse(fields);
            } catch (e) {
                fields = [];
            }
        }
        fields = fields || [];
        
        fields.forEach((field, index) => {
            const isOptional = isOptionalFieldForSignalType(field, signalType);
            const fieldKey = `field_${signalTypeId}_${index}`;
            const isOptionalVisible = isOptional && optionalFieldsVisibility[fieldKey];
            
            // Skip optional fields that are hidden
            if (isOptional && !isOptionalVisible) {
                return; // Skip this optional field
            }
            
            // Skip fields that contain strike, expiration when is_shares is checked
            if (isShares) {
                const fieldNameLower = (field.name || '').toLowerCase();
                if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')) {
                    return; // Skip this field
                }
            }
            
            // Extract variables from field name and value
            const fieldVars = new Set();
            if (field.name) {
                extractVariablesFromTemplate(field.name).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            if (field.value) {
                extractVariablesFromTemplate(field.value).forEach(v => {
                    usedVariables.add(v);
                    fieldVars.add(v);
                });
            }
            
            // If this is an optional field, mark its variables as optional-only (if not already in non-optional)
            if (isOptional && isOptionalVisible) {
                fieldVars.forEach(v => {
                    if (!nonOptionalVariables.has(v)) {
                        optionalOnlyVariables.add(v);
                    }
                });
            } else {
                // Non-optional field, mark variables as non-optional
                fieldVars.forEach(v => nonOptionalVariables.add(v));
            }
        });
    }
    
    // Remove variables from optionalOnly if they're also in nonOptional
    nonOptionalVariables.forEach(v => optionalOnlyVariables.delete(v));
    
    return { all: usedVariables, optionalOnly: optionalOnlyVariables };
}

// Update Discord embed preview
function updatePreview() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.warn('Signal type not found for preview:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        return;
    }
    
    // Collect current form values
    const formData = {};
    
    // Check if is_shares is checked
    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    
    // Option-related fields that should be excluded when is_shares is checked
    const optionFields = ['strike', 'expiration', 'option_type'];
    
    // Collect inputs from both main dynamicFields container and optional fields variables container
    const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
    dynamicInputs.forEach(input => {
        // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
        if (!input.name || input.dataset.ignoreDynamic === '1') {
            return;
        }
        // Skip option-related fields if is_shares is checked
        if (isShares && optionFields.includes(input.name)) {
            return;
        }
        
        // Skip hidden fields (those with data-requires-options when is_shares is true)
        if (input.closest('[data-requires-options="true"]') && isShares) {
            return;
        }
        
        if (input.type === 'checkbox') {
            formData[input.name] = input.checked ? 'true' : 'false';
        } else {
            formData[input.name] = input.value || '';
        }
    });

    // Include non-dynamic publish controls
    const tradeTypeEl = document.getElementById('trade_type');
    if (tradeTypeEl && tradeTypeEl.value) {
        formData['trade_type'] = tradeTypeEl.value;
    }
    
    // Update color bar
    const color = signalType.color || '#000000';
    document.getElementById('previewColorBar').style.backgroundColor = color;
    
    // Update title - check if title should be shown
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showTitle = showTitleCheckbox ? showTitleCheckbox.checked : true;
    const title = renderTemplate(signalType.title_template, formData);
    const titleEl = document.getElementById('previewTitle');
    if (title && showTitle) {
        titleEl.innerHTML = parseDiscordMarkdown(title);
        titleEl.style.display = 'block';
    } else {
        titleEl.style.display = 'none';
    }
    
    // Update description - check if description should be shown
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    const showDescription = showDescriptionCheckbox ? showDescriptionCheckbox.checked : true;
    const description = renderTemplate(signalType.description_template, formData);
    const descEl = document.getElementById('previewDescription');
    if (description && showDescription) {
        descEl.innerHTML = parseDiscordMarkdown(description);
        descEl.style.display = 'block';
    } else {
        descEl.style.display = 'none';
    }
    
    // Update fields
    const fieldsContainer = document.getElementById('previewFields');
    fieldsContainer.innerHTML = '';
    
    // Parse fields_template from JSON string if needed
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = fields || [];
    
    // First, collect all fields that should be rendered (with all filtering applied)
    const fieldsToRender = [];
    fields.forEach((field, index) => {
        // Render field name and value first
        const fieldName = renderTemplate(field.name || '', formData);
        const fieldValue = renderTemplate(field.value || '', formData);
        
        // Skip optional fields that are hidden
        if (isOptionalFieldForSignalType(field, signalType)) {
            const fieldKey = `field_${signalTypeId}_${index}`;
            if (!optionalFieldsVisibility[fieldKey]) {
                return; // Skip this optional field
            }
        }
        
        // Skip fields that contain strike, expiration, or option_type when is_shares is checked
        if (isShares) {
            const fieldNameLower = (field.name || '').toLowerCase();
            const fieldValueLower = (field.value || '').toLowerCase();
            const renderedNameLower = (fieldName || '').toLowerCase();
            const renderedValueLower = (fieldValue || '').toLowerCase();
            
            // Check both raw template and rendered values
            // if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration') || fieldNameLower.includes('option') ||
            //     fieldValueLower.includes('{{strike}}') || fieldValueLower.includes('{{expiration}}') || fieldValueLower.includes('{{option_type}}') ||
            //     renderedNameLower.includes('strike') || renderedNameLower.includes('expiration') || renderedNameLower.includes('option') ||
            //     renderedValueLower.includes('strike') || renderedValueLower.includes('expiration') || renderedValueLower.includes('option')) {
            //     return; // Skip this field
            // }
            if (fieldNameLower.includes('strike') || fieldNameLower.includes('expiration')){
                return;
            }
            // Also remove any field related to option_price in shares mode.
            if (fieldNameLower.includes('option_price') || fieldValueLower.includes('option_price') ||
                fieldNameLower.includes('option price') || fieldValueLower.includes('option price')) {
                return;
            }
        }
        
        // Store field data for rendering
        fieldsToRender.push({
            field: field,
            index: index,
            fieldName: fieldName,
            fieldValue: fieldValue
        });
    });
    
    // Remove consecutive blank spacers (keep only one)
    const filteredFields = [];
    let prevWasBlank = false;
    fieldsToRender.forEach((item) => {
        const isBlankSpacer = (!item.fieldName || !item.fieldName.trim()) && 
                             (item.fieldValue === '\u200b' || (item.fieldValue && item.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer && prevWasBlank) {
            return; // Skip consecutive blank spacers
        }
        prevWasBlank = isBlankSpacer;
        filteredFields.push(item);
    });
    
    // Remove trailing blank spacers
    while (filteredFields.length > 0) {
        const lastField = filteredFields[filteredFields.length - 1];
        const isBlankSpacer = (!lastField.fieldName || !lastField.fieldName.trim()) && 
                             (lastField.fieldValue === '\u200b' || (lastField.fieldValue && lastField.fieldValue.trim() === '\u200b'));
        if (isBlankSpacer) {
            filteredFields.pop();
        } else {
            break;
        }
    }
    
    // Use filtered fields for rendering
    const fieldsToRenderFinal = filteredFields;

    // Inject Trade Plan preview block (Trade Plan / Targets / Stop Loss) below option-related fields
    // so users don't need to manually add these lines into every signal type template.
    if (!isShares) {
        const alreadyHasPlan = fieldsToRenderFinal.some(it => {
            const n = String(it.fieldName || '').toLowerCase();
            const v = String(it.fieldValue || '').toLowerCase();
            return n.includes('trade plan') || n.includes('game plan') || n.includes('targets') || n.includes('stop loss') ||
                   v.includes('trade plan') || v.includes('game plan') || v.includes('targets') || v.includes('stop loss');
        });

        if (!alreadyHasPlan) {
            const tps = [];
            for (let i = 1; i <= MAX_TP_LEVELS; i++) {
                const modeRaw = String(formData[`tp${i}_mode`] ?? '').trim().toLowerCase();
                const mode = (modeRaw === 'stock' || modeRaw === 'stock_price' || modeRaw === 'underlying' || modeRaw === 'share_price')
                    ? 'stock'
                    : 'percent';
                const takeoff = String(formData[`tp${i}_takeoff_per`] ?? '').trim();
                const takeoffStr = takeoff ? (takeoff.endsWith('%') ? takeoff : `${takeoff}%`) : '';

                if (mode === 'stock') {
                    const spRaw = String(formData[`tp${i}_stock_price`] ?? '').trim();
                    if (!spRaw) continue;
                    const n = Number(spRaw);
                    const spStr = Number.isFinite(n) ? n.toFixed(2) : spRaw;
                    tps.push(`$${spStr}${takeoffStr ? ` - ${takeoffStr}` : ''}`);
                    continue;
                }

                const per = String(formData[`tp${i}_per`] ?? '').trim();
                if (!per) continue;
                const price = String(formData[`tp${i}_price`] ?? '0.000').trim() || '0.000';
                const perStr = per.endsWith('%') ? per : `${per}%`;
                tps.push(`${price}(${perStr})${takeoffStr ? ` - ${takeoffStr}` : ''}`);
            }
            const slPerRaw = String(formData['sl_per'] ?? '').trim();
            const slPriceRaw = String(formData['sl_price'] ?? '0.000').trim() || '0.000';
            const slPerStr = slPerRaw ? (slPerRaw.endsWith('%') ? slPerRaw : `${slPerRaw}%`) : '';

            // Show Trade Plan even before option price is computed (defaults: 0.000)
            if (tps.length || slPerRaw || slPriceRaw) {
                // Find insertion index: after last option-related field (Expiration/Strike/Option/Price)
                let insertAt = -1;
                fieldsToRenderFinal.forEach((it, idx) => {
                    const n = String(it.fieldName || '').toLowerCase();
                    const v = String(it.fieldValue || '').toLowerCase();
                    if (
                        n.includes('expiration') || n.includes('strike') || n.includes('option') || n.includes('price') ||
                        v.includes('expiration') || v.includes('strike') || v.includes('option') || v.includes('price')
                    ) {
                        insertAt = idx;
                    }
                });
                insertAt = insertAt >= 0 ? insertAt + 1 : 0;

                const injected = [];
                // blank spacer between option data and Trade Plan
                injected.push({ field: { inline: false }, index: -1000, fieldName: '', fieldValue: '\u200b' });
                injected.push({ field: { inline: false }, index: -1001, fieldName: 'üìù **Trade Plan**', fieldValue: '' });
                if (tps.length) {
                    injected.push({
                        field: { inline: false },
                        index: -1002,
                        fieldName: `üéØ Targets: ${tps.join(', ')}`,
                        fieldValue: '',
                    });
                }
                if (slPriceRaw) {
                    injected.push({
                        field: { inline: false },
                        index: -1003,
                        fieldName: `üõë Stop Loss: ${slPriceRaw}${slPerStr ? `(${slPerStr})` : ''}`,
                        fieldValue: '',
                    });
                }

                fieldsToRenderFinal.splice(insertAt, 0, ...injected);
            }
        }
    }
    
    let currentInlineGroup = null;
    
    // Function to adjust inline field widths based on count in group
    function adjustInlineGroupWidths(inlineGroup) {
        if (!inlineGroup) return;
        const fieldCount = inlineGroup.children.length;
        if (fieldCount === 0) return;
        
        // Calculate width based on number of fields
        let width;
        if (fieldCount === 1) {
            width = 'calc(33.333% - 11px)'; // Single field in a row of 3
        } else if (fieldCount === 2) {
            width = 'calc(50% - 8px)'; // Two fields: each takes 50% minus half the gap
        } else {
            width = 'calc(33.333% - 11px)'; // Three fields: each takes 33.333%
        }
        
        // Apply width to all fields in the group
        Array.from(inlineGroup.children).forEach(field => {
            field.style.flex = `0 0 ${width}`;
            field.style.maxWidth = width;
        });
    }
    
    // Now render the filtered fields
    fieldsToRenderFinal.forEach(({field, index, fieldName, fieldValue}, renderIndex) => {
        
        const fieldEl = document.createElement('div');
        fieldEl.className = 'discord-embed-field';
        
        // Check if this is an inline field
        if (field.inline) {
            // If previous field was not inline, start a new inline group
            if (!currentInlineGroup || (renderIndex > 0 && !fieldsToRenderFinal[renderIndex - 1].field.inline)) {
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            // Check if current group already has 3 fields, start a new row
            if (currentInlineGroup && currentInlineGroup.children.length >= 3) {
                // Adjust widths for the previous group before starting new one
                adjustInlineGroupWidths(currentInlineGroup);
                currentInlineGroup = document.createElement('div');
                currentInlineGroup.style.display = 'flex';
                currentInlineGroup.style.flexWrap = 'wrap';
                currentInlineGroup.style.gap = '16px';
                fieldsContainer.appendChild(currentInlineGroup);
            }
            fieldEl.classList.add('discord-embed-field-inline');
        } else {
            // Non-inline field, adjust widths for any existing inline group and close it
            adjustInlineGroupWidths(currentInlineGroup);
            currentInlineGroup = null;
        }
        
        const nameEl = document.createElement('div');
        nameEl.className = 'discord-embed-field-name';
        nameEl.innerHTML = fieldName ? parseDiscordMarkdown(fieldName) : '\u200b';
        
        const valueEl = document.createElement('div');
        valueEl.className = 'discord-embed-field-value';
        valueEl.innerHTML = fieldValue ? parseDiscordMarkdown(fieldValue) : '\u200b';
        
        fieldEl.appendChild(nameEl);
        if (fieldValue !== '') {
            fieldEl.appendChild(valueEl);
        }
            
        
        if (field.inline && currentInlineGroup) {
            currentInlineGroup.appendChild(fieldEl);
        } else {
            fieldsContainer.appendChild(fieldEl);
        }
    });
    
    // Adjust widths for any remaining inline group at the end
    adjustInlineGroupWidths(currentInlineGroup);
    
    // Update footer
    const footer = renderTemplate(signalType.footer_template, formData);
    const footerEl = document.getElementById('previewFooter');
    if (footer) {
        footerEl.innerHTML = parseDiscordMarkdown(footer);
        footerEl.style.display = 'block';
    } else {
        footerEl.style.display = 'none';
    }
}

// Create dynamic form fields based on signal type
function createDynamicFields(signalTypeId) {
    console.log('createDynamicFields called with signalTypeId:', signalTypeId);
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    if (!dynamicFieldsContainer) {
        console.error('dynamicFields container not found!');
        return;
    }
    dynamicFieldsContainer.innerHTML = '';
    
    // Convert to string to match the keys in signalTypesData (which are strings from template)
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        console.error('Signal type not found:', signalTypeId, 'Available keys:', Object.keys(signalTypesData));
        updatePreview();
        return;
    }
    
    console.log('Found signal type:', signalType);
    
    // Parse variables from JSON string if needed
    let variables = signalType.variables;
    if (typeof variables === 'string') {
        try {
            variables = JSON.parse(variables);
        } catch (e) {
            console.error('Error parsing variables:', e, 'Raw value:', variables);
            variables = [];
        }
    }
    variables = variables || [];
    
    console.log('Parsed variables:', variables, 'Count:', variables.length);
    
    if (variables.length === 0) {
        console.warn('No variables found for signal type:', signalTypeId);
        dynamicFieldsContainer.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No variables defined for this signal type.</p>';
        updatePreview();
        return;
    }
    
    // Get used variables to determine visibility
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    let tickerTypeToggleSlot = null;
    let isSharesPill = null;
    let isSharesFormGroup = null;
    const hasIsSharesVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'is_shares');
    const hasStrikeVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'strike');
    const hasExpirationVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'expiration');
    const hasOptionTypeVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_type');
    const hasOptionPriceVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_price');
    const hasOptionContractVariable = Array.isArray(variables) && variables.some(v => v && v.name === 'option_contract');

    function createSyntheticIsSharesPill() {
        // Create the same pill UI used for real is_shares variables, but without needing it in the template variables list.
        const pill = document.createElement('div');
        pill.className = 'toggle-pill';

        const switchWrap = document.createElement('label');
        switchWrap.className = 'toggle-switch';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'form-checkbox';
        input.id = 'id_is_shares';
        input.name = 'is_shares';
        input.checked = false;

        const slider = document.createElement('span');
        slider.className = 'toggle-slider';

        switchWrap.appendChild(input);
        switchWrap.appendChild(slider);

        const text = document.createElement('div');
        text.className = 'toggle-label';
        text.textContent = 'Is_Shares (Disable Options fields)';

        pill.appendChild(switchWrap);
        pill.appendChild(text);

        return { pill, input };
    }

    function createSyntheticOptionField(name) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = ({
            strike: 'Strike',
            expiration: 'Expiration',
            option_type: 'Option Type',
        })[name] || name;
        label.setAttribute('for', `id_${name}`);

        let input;
        if (name === 'strike') {
            input = document.createElement('input');
            input.type = 'number';
            input.step = '0.01';
            input.className = 'form-input';
            input.placeholder = 'Enter strike price (e.g., 150.50)';
        } else if (name === 'expiration') {
            input = document.createElement('input');
            input.type = 'date';
            input.className = 'form-input';
            const today = getTodayISODate();
            input.min = today;
            if (!input.value) input.value = today;
        } else if (name === 'option_type') {
            input = document.createElement('select');
            input.className = 'form-select';
            ['CALL', 'PUT'].forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt;
                o.textContent = opt;
                input.appendChild(o);
            });
        } else {
            input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-input';
        }

        input.id = `id_${name}`;
        input.name = name;

        formGroup.appendChild(label);
        formGroup.appendChild(input);

        // match event behavior of other dynamic inputs
        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));

        // When synthetic option_type changes, pick best option (strike/expiration are auto-selected).
        if (name === 'option_type') {
            input.addEventListener('change', () => maybeAutoPickBestOption());
        }

        return formGroup;
    }

    function createSyntheticHiddenField(name, defaultValue = '') {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');
        // Mark as auto-filled so setValueIfAllowed can overwrite it later.
        input.dataset.autoFilled = '1';

        const wrapper = document.createElement('div');
        wrapper.className = 'form-group';
        wrapper.classList.add('synthetic-hidden');
        wrapper.style.display = 'none';
        wrapper.setAttribute('data-variable-name', name);
        wrapper.appendChild(input);

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        return wrapper;
    }

    function createSyntheticPercentField(name, defaultValue, labelText, { showPercentSuffix = false } = {}) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = labelText || name;
        label.setAttribute('for', `id_${name}`);

        const input = document.createElement('input');
        input.type = 'number';
        input.step = '0.1';
        input.min = '0';
        input.className = 'form-input';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');

        formGroup.appendChild(label);
        if (showPercentSuffix) {
            const wrap = document.createElement('div');
            wrap.className = 'percent-input-wrap';
            wrap.appendChild(input);
            const suffix = document.createElement('span');
            suffix.className = 'percent-suffix';
            suffix.textContent = '%';
            wrap.appendChild(suffix);
            input.style.paddingRight = '34px';
            formGroup.appendChild(wrap);
        } else {
            formGroup.appendChild(input);
        }

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));
        input.addEventListener('input', () => updateTpSlPrices());
        input.addEventListener('change', () => updateTpSlPrices());

        return formGroup;
    }

    function createSyntheticPriceField(name, defaultValue, labelText, { showDollarPrefix = true } = {}) {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', name);
        formGroup.setAttribute('data-requires-options', 'true');

        const label = document.createElement('label');
        label.textContent = labelText || name;
        label.setAttribute('for', `id_${name}`);

        const input = document.createElement('input');
        input.type = 'number';
        input.step = '0.01';
        input.min = '0';
        input.className = 'form-input';
        input.id = `id_${name}`;
        input.name = name;
        input.value = String(defaultValue ?? '');

        formGroup.appendChild(label);
        if (showDollarPrefix) {
            const wrap = document.createElement('div');
            wrap.className = 'percent-input-wrap';
            const prefix = document.createElement('span');
            prefix.className = 'percent-suffix';
            prefix.textContent = '$';
            prefix.style.left = '10px';
            prefix.style.right = 'auto';
            prefix.style.padding = '0';
            // Reuse the existing wrap/suffix styles; position prefix on the left
            wrap.style.position = 'relative';
            wrap.appendChild(input);
            wrap.appendChild(prefix);
            input.style.paddingLeft = '26px';
            formGroup.appendChild(wrap);
        } else {
            formGroup.appendChild(input);
        }

        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);
        input.addEventListener('input', () => markUserTouched(input));
        return formGroup;
    }

    function createTakeProfitRow(level, defaultPer, defaultTakeoffPer, { defaultMode = 'percent', defaultStockPrice = '' } = {}) {
        const rowWrap = document.createElement('div');
        rowWrap.className = 'tp-level-row';
        rowWrap.dataset.tpRow = '1';
        rowWrap.dataset.tpLevel = String(level);

        const header = document.createElement('div');
        header.className = 'tp-level-row-header';
        rowWrap.appendChild(header);

        // Hidden per-row mode field (kept for form submission + preview/discord logic)
        const modeHidden = document.createElement('input');
        modeHidden.type = 'hidden';
        modeHidden.id = `id_tp${level}_mode`;
        modeHidden.name = `tp${level}_mode`;
        modeHidden.value = String(defaultMode || 'percent');
        // allow programmatic overwrite
        modeHidden.dataset.autoFilled = '1';
        modeHidden.addEventListener('input', updatePreview);
        modeHidden.addEventListener('change', updatePreview);
        rowWrap.appendChild(modeHidden);

        // Add a remove button (we'll only show it on the last row)
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tp-remove-btn';
        btn.style.display = 'none';

        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        icon.setAttribute('viewBox', '0 0 24 24');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M9 3h6l1 2h5v2H3V5h5l1-2zm1 7h2v9h-2v-9zm4 0h2v9h-2v-9zM7 10h2v9H7v-9z');
        icon.appendChild(path);

        const text = document.createElement('span');
        text.textContent = 'Remove';
        btn.appendChild(icon);
        btn.appendChild(text);

        // Body: two columns (Target + Take Off %)
        const body = document.createElement('div');
        body.className = 'tp-level-row-body';

        // Left column: target value (driven by global mode)
        const targetCol = document.createElement('div');
        targetCol.style.display = 'flex';
        targetCol.style.flexDirection = 'column';
        targetCol.style.gap = '10px';

        // TP % input (label goes in header)
        const tpGroup = createSyntheticPercentField(`tp${level}_per`, defaultPer, `TP %`, { showPercentSuffix: true });
        const tpLabel = tpGroup.querySelector('label');
        if (tpLabel) {
            // Put "Take Profit N" in header, remove inner label to avoid duplication
            tpLabel.textContent = `Take Profit ${level}`;
            header.appendChild(tpLabel);
        } else {
            const fallbackLabel = document.createElement('label');
            fallbackLabel.textContent = `Take Profit ${level}`;
            header.appendChild(fallbackLabel);
        }
        header.appendChild(btn);

        // If we moved the label, ensure it isn't still inside the group
        const innerLabel = tpGroup.querySelector('label');
        if (innerLabel) innerLabel.remove();

        // Add a small label above the level percent input (inside the row body)
        const levelLabel = document.createElement('label');
        levelLabel.textContent = 'Level %';
        levelLabel.setAttribute('for', `id_tp${level}_per`);
        const tpWrapEl = tpGroup.querySelector('.percent-input-wrap');
        if (tpWrapEl) {
            tpGroup.insertBefore(levelLabel, tpWrapEl);
        } else {
            const tpInput = tpGroup.querySelector('input, select, textarea');
            if (tpInput && tpInput.parentElement === tpGroup) {
                tpGroup.insertBefore(levelLabel, tpInput);
            } else if (tpInput && tpInput.parentElement) {
                tpGroup.insertBefore(levelLabel, tpInput.parentElement);
            } else {
                tpGroup.appendChild(levelLabel);
            }
        }

        // Stock price target input (underlying)
        const stockGroup = createSyntheticPriceField(
            `tp${level}_stock_price`,
            defaultStockPrice,
            'Stock Price Target',
            { showDollarPrefix: true }
        );

        // Toggle which target input is visible
        function syncTargetMode() {
            const m = String(modeHidden.value || '').trim().toLowerCase();
            const isStock = m === 'stock' || m === 'stock_price' || m === 'underlying' || m === 'share_price';
            tpGroup.style.display = isStock ? 'none' : '';
            stockGroup.style.display = isStock ? '' : 'none';
            updateTpSlPrices();
            updatePreview();
        }
        syncTargetMode();

        // Expose helpers for the global Target Type selector
        rowWrap._tpModeHidden = modeHidden;
        rowWrap._tpSyncTargetMode = syncTargetMode;

        targetCol.appendChild(tpGroup);
        targetCol.appendChild(stockGroup);

        // Right column: takeoff % (capital removed when TP hits)
        const takeoffDefaults = { 1: 50, 2: 25, 3: 25 };
        const takeoffGroup = createSyntheticPercentField(
            `tp${level}_takeoff_per`,
            (defaultTakeoffPer ?? takeoffDefaults[level] ?? 0),
            'Take Off',
            { showPercentSuffix: true }
        );
        takeoffGroup.dataset.tpTakeoffGroup = '1';

        body.appendChild(targetCol);
        body.appendChild(takeoffGroup);
        rowWrap.appendChild(body);
        return rowWrap;
    }

    function createSyntheticTradePlanGroup(children) {
        const wrap = document.createElement('div');
        wrap.className = 'sub-card trade-plan-group';
        wrap.dataset.tradePlanGroup = '1';

        const title = document.createElement('div');
        title.style.color = '#e0e0e0';
        title.style.fontSize = '1em';
        title.style.marginBottom = '12px';
        title.style.fontWeight = '600';
        title.textContent = 'üìù Trade Plan';

        wrap.appendChild(title);
        const body = document.createElement('div');
        body.style.display = 'flex';
        body.style.flexDirection = 'column';
        body.style.gap = '12px';

        (children || []).forEach((c) => {
            if (c) body.appendChild(c);
        });
        wrap.appendChild(body);
        return wrap;
    }

    function attachIsSharesToTickerType() {
        if (!tickerTypeToggleSlot || !isSharesPill) return;
        tickerTypeToggleSlot.innerHTML = '';
        tickerTypeToggleSlot.appendChild(isSharesPill);
        // Remove the original container if we rendered it separately first.
        if (isSharesFormGroup && isSharesFormGroup.parentNode) {
            isSharesFormGroup.parentNode.removeChild(isSharesFormGroup);
        }
    }

    variables.forEach(variable => {
        // Check if this variable is used
        // is_shares is a special control variable that should always be visible
        const isSpecialControl = variable.name === 'is_shares' || variable.type === 'ticker_type';
        const isUsed = usedVariables.has(variable.name) || isSpecialControl;
        const isOptionalOnly = optionalOnlyVariables.has(variable.name);
        
        // Create form group with data attribute for visibility control
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';
        formGroup.setAttribute('data-variable-name', variable.name);
        // Initially hide if not used (but always show is_shares)
        if (!isUsed) {
            formGroup.style.display = 'none';
        }
        
        const label = document.createElement('label');
        const isRequired = variable.required === true;
        label.textContent = getLabel(variable) + (isRequired ? ' *' : '');
        label.setAttribute('for', `id_${variable.name}`);
        
        let input;
        
        const inputType = getInputType(variable.type);
        
        // Handle select type (dropdown)
        if (variable.type === 'select' && variable.options) {
            input = document.createElement('select');
            input.className = 'form-select';
            
            // Add options directly (no default placeholder)
            variable.options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                if (variable.default && option === variable.default) {
                    optionElement.selected = true;
                }
                input.appendChild(optionElement);
            });
        } else if (variable.type === 'ticker_select') {
            // If custom options exist, render a select; otherwise use the global US ticker datalist.
            const hasOptions = Array.isArray(variable.options) && variable.options.length > 0;
            if (hasOptions) {
                input = document.createElement('select');
                input.className = 'form-select';
                variable.options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    if (variable.default && option === variable.default) {
                        optionElement.selected = true;
                    }
                    input.appendChild(optionElement);
                });
            } else {
                const control = createTickerSearchControl(variable);
                input = control.input;
                input._tickerSearchWrap = control.wrap;
            }
        } else if (variable.type === 'ticker_type') {
            // Searchable input backed by server-side search (avoid loading full ticker universe)
            const control = createTickerSearchControl(variable);
            input = control.input;
            input._tickerSearchWrap = control.wrap;

            // If the template didn't define an is_shares variable, add the toggle inline by default.
            if (!hasIsSharesVariable && !isSharesPill) {
                const created = createSyntheticIsSharesPill();
                isSharesPill = created.pill;
                // Keep behavior consistent with normal inputs
                created.input.addEventListener('input', updatePreview);
                created.input.addEventListener('change', updatePreview);
            }

            // If template didn't define option fields, add them by default (they'll be hidden when is_shares is true).
            formGroup._afterSyntheticGroups = [];
            // Strike/Expiration are auto-selected; keep them as hidden fields only.
            if (!hasStrikeVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('strike', ''));
            if (!hasExpirationVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('expiration', ''));
            if (!hasOptionTypeVariable) formGroup._afterSyntheticGroups.push(createSyntheticOptionField('option_type'));
            // Add TP/SL inputs grouped under "Trade Plan" behind Option Type.
            // Prices are auto-calculated from option_price and stored in hidden fields for template use.
            const tpContainer = document.createElement('div');
            tpContainer.dataset.requiresOptions = 'true';

        // --- Preset selector row (dropdown) ---
        const presetBar = document.createElement('div');
        presetBar.style.display = 'flex';
        presetBar.style.flexWrap = 'wrap';
        presetBar.style.alignItems = 'center';
        presetBar.style.gap = '10px';
        presetBar.style.marginBottom = '14px';

        const presetLabel = document.createElement('div');
        presetLabel.style.color = '#9ca3af';
        presetLabel.style.fontSize = '0.9em';
        presetLabel.style.fontWeight = '600';
        presetLabel.textContent = 'Saved Plans';

        const presetSelect = document.createElement('select');
        presetSelect.className = 'form-select';
        presetSelect.style.width = 'auto';
        presetSelect.style.minWidth = '220px';

        const savePresetBtn = document.createElement('button');
        savePresetBtn.type = 'button';
        savePresetBtn.textContent = 'Save';
        savePresetBtn.className = 'btn-cancel';
        savePresetBtn.style.padding = '8px 10px';
        savePresetBtn.style.fontSize = '0.85em';
        savePresetBtn.style.width = 'auto';
        savePresetBtn.style.borderRadius = '10px';

        const saveAsPresetBtn = document.createElement('button');
        saveAsPresetBtn.type = 'button';
        saveAsPresetBtn.textContent = 'Save As';
        saveAsPresetBtn.className = 'btn-submit';
        saveAsPresetBtn.style.padding = '8px 10px';
        saveAsPresetBtn.style.fontSize = '0.85em';
        saveAsPresetBtn.style.width = 'auto';
        saveAsPresetBtn.style.borderRadius = '10px';

        const deletePresetBtn = document.createElement('button');
        deletePresetBtn.type = 'button';
        deletePresetBtn.textContent = 'Delete';
        deletePresetBtn.className = 'btn-cancel';
        deletePresetBtn.style.padding = '8px 10px';
        deletePresetBtn.style.fontSize = '0.85em';
        deletePresetBtn.style.width = 'auto';
        deletePresetBtn.style.borderRadius = '10px';
        deletePresetBtn.style.opacity = '0.85';

        const defaultPresetBtn = document.createElement('button');
        defaultPresetBtn.type = 'button';
        defaultPresetBtn.textContent = 'Set as Default';
        defaultPresetBtn.className = 'btn-cancel';
        defaultPresetBtn.style.padding = '8px 10px';
        defaultPresetBtn.style.fontSize = '0.85em';
        defaultPresetBtn.style.width = 'auto';
        defaultPresetBtn.style.borderRadius = '10px';
        defaultPresetBtn.style.opacity = '0.85';

        presetBar.appendChild(presetLabel);
        presetBar.appendChild(presetSelect);

            const tpHeader = document.createElement('div');
            tpHeader.style.display = 'flex';
            tpHeader.style.alignItems = 'center';
            tpHeader.style.justifyContent = 'space-between';
            tpHeader.style.gap = '12px';

            const tpTitle = document.createElement('div');
            tpTitle.style.color = '#9ca3af';
            tpTitle.style.fontSize = '0.95em';
            tpTitle.style.fontWeight = '600';
            tpTitle.textContent = 'Take Profit Levels';

            // One Target Type selector for ALL TP levels
            let globalTpMode = 'percent';

            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.textContent = 'Add Take Profit';
            addBtn.className = 'btn-submit';
            addBtn.style.padding = '8px 10px';
            addBtn.style.fontSize = '0.85em';
            addBtn.style.width = 'auto';
            addBtn.style.borderRadius = '10px';

            tpHeader.appendChild(tpTitle);
            const rightBtns = document.createElement('div');
            rightBtns.style.display = 'flex';
            rightBtns.style.gap = '8px';

            const globalModeWrap = document.createElement('div');
            globalModeWrap.style.display = 'flex';
            globalModeWrap.style.alignItems = 'center';
            globalModeWrap.style.gap = '8px';

            const globalModeLabel = document.createElement('span');
            globalModeLabel.textContent = 'Target Type';
            globalModeLabel.style.color = '#9ca3af';
            globalModeLabel.style.fontSize = '0.85em';
            globalModeLabel.style.fontWeight = '600';
            globalModeLabel.style.whiteSpace = 'nowrap';

            const globalModeSelect = document.createElement('select');
            globalModeSelect.className = 'form-select';
            globalModeSelect.style.width = 'auto';
            globalModeSelect.style.minWidth = '170px';
            globalModeSelect.style.padding = '8px 10px';
            globalModeSelect.style.fontSize = '0.9em';
            [
                { value: 'percent', text: '% based (Option)' },
                { value: 'stock', text: 'Stock price ($)' },
            ].forEach((opt) => {
                const o = document.createElement('option');
                o.value = opt.value;
                o.textContent = opt.text;
                globalModeSelect.appendChild(o);
            });

            globalModeWrap.appendChild(globalModeLabel);
            globalModeWrap.appendChild(globalModeSelect);
            rightBtns.appendChild(globalModeWrap);
            rightBtns.appendChild(addBtn);
            tpHeader.appendChild(rightBtns);
        tpContainer.appendChild(presetBar);
        tpContainer.appendChild(tpHeader);

            const tpRows = document.createElement('div');
            tpRows.style.display = 'flex';
            tpRows.style.flexDirection = 'column';
            tpRows.style.gap = '10px';
            tpRows.style.marginTop = '10px';
            tpContainer.appendChild(tpRows);

            const tpHiddenHolder = document.createElement('div');
            tpHiddenHolder.style.display = 'none';
            tpContainer.appendChild(tpHiddenHolder);

            const ensureTpPriceHidden = (lvl) => {
                const existing = findFieldByName(`tp${lvl}_price`);
                if (existing) return;
                const hiddenGroup = createSyntheticHiddenField(`tp${lvl}_price`, '0.000');
                tpHiddenHolder.appendChild(hiddenGroup);
            };

            const removeTpPriceHidden = (lvl) => {
                const priceGroup = document.querySelector(
                    `#dynamicFields [data-variable-name="tp${lvl}_price"], #optionalFieldsVariablesContainer [data-variable-name="tp${lvl}_price"]`
                );
                if (priceGroup && priceGroup.parentElement) priceGroup.parentElement.removeChild(priceGroup);
            };

            const readTpState = () => {
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                return rows.map((r) => {
                    const lvl = Number(r.dataset.tpLevel || '');
                    const mode = findFieldByName(`tp${lvl}_mode`)?.value ?? 'percent';
                    const per = findFieldByName(`tp${lvl}_per`)?.value ?? '';
                    const stockPrice = findFieldByName(`tp${lvl}_stock_price`)?.value ?? '';
                    const takeoff = findFieldByName(`tp${lvl}_takeoff_per`)?.value ?? '';
                    return { mode: String(mode), per: String(per), stock_price: String(stockPrice), takeoff: String(takeoff) };
                });
            };

            const renderTpRows = (state) => {
                tpRows.innerHTML = '';
                const s = Array.isArray(state) ? state : [];
                s.forEach((it, idx) => {
                    const lvl = idx + 1;
                    ensureTpPriceHidden(lvl);
                    const perNum = Number(String(it?.per ?? '').trim());
                    const takeoffNum = Number(String(it?.takeoff ?? '').trim());
                    const perVal = Number.isFinite(perNum) ? perNum : (lvl * 10);
                    const takeoffVal = Number.isFinite(takeoffNum) ? takeoffNum : (lvl === 1 ? 50 : (lvl === 2 ? 25 : (lvl === 3 ? 25 : 0)));
                    const stockPriceRaw = String(it?.stock_price ?? it?.stockPrice ?? '').trim();
                    const rowEl = createTakeProfitRow(lvl, perVal, takeoffVal, { defaultMode: globalTpMode, defaultStockPrice: stockPriceRaw });
                    // Wire remove: allowed for TP2+; removing reindexes rows so tp1/tp2/... stay stable.
                    const btn = rowEl.querySelector('.tp-level-row-header .tp-remove-btn');
                    if (btn) {
                        btn.addEventListener('click', () => {
                            if (lvl <= 1) return;
                            const current = readTpState();
                            if (current.length <= 1) return;
                            current.splice(lvl - 1, 1);
                            removeTpPriceHidden(current.length + 1); // remove old highest tp_price
                            renderTpRows(current);
                        });
                    }
                    tpRows.appendChild(rowEl);
                });
                refreshTpRemoveButtons();
                updateTpSlPrices();
                updatePreview();
            };

            function applyGlobalTpModeToRows() {
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                rows.forEach((r) => {
                    const input = r._tpModeHidden;
                    if (!input) return;
                    input.value = globalTpMode;
                    if (typeof r._tpSyncTargetMode === 'function') r._tpSyncTargetMode();
                });
            }

            const refreshTpRemoveButtons = () => {
                const rows = Array.from(tpRows.querySelectorAll('[data-tp-row="1"]'));
                rows.forEach((r) => {
                    const b = r.querySelector('.tp-level-row-header .tp-remove-btn');
                    if (!b) return;
                    // Show remove on all rows except TP1
                    const lvl = Number(r.dataset.tpLevel || '');
                    b.style.display = (lvl > 1) ? 'inline-flex' : 'none';
                });
                addBtn.disabled = rows.length >= MAX_TP_LEVELS;
                addBtn.style.opacity = addBtn.disabled ? '0.6' : '1';
            };

            addBtn.addEventListener('click', () => {
                const state = readTpState();
                const next = state.length + 1;
                if (next > MAX_TP_LEVELS) return;
                state.push({ per: String(next * 10), takeoff: '0' });
                renderTpRows(state);
                applyGlobalTpModeToRows();
                updateDefaultTpStockTargets();
            });

            // Prefill from selected preset if present; otherwise defaults.
            const defaultTp = [{ per: '10', takeoff: '50' }, { per: '20', takeoff: '25' }, { per: '30', takeoff: '25' }];
            const defaultSl = 10;
            const initialPreset = getInitialTradePlanPreset();
            const initialPlan = (initialPreset && typeof initialPreset === 'object') ? (initialPreset.plan || {}) : {};
            const initialTp = Array.isArray(initialPlan?.tp_levels) && initialPlan.tp_levels.length ? initialPlan.tp_levels : defaultTp;
            const initialSlNum = Number(String(initialPlan?.sl_per ?? '').trim());
            const initialSl = Number.isFinite(initialSlNum) && initialSlNum > 0 ? initialSlNum : defaultSl;

            // Initial global mode: if any saved level uses stock mode, default to stock
            try {
                const hasStock = Array.isArray(initialTp) && initialTp.some((it) => {
                    const m = String(it?.mode ?? '').trim().toLowerCase();
                    return m === 'stock' || m === 'stock_price' || m === 'underlying' || m === 'share_price';
                });
                globalTpMode = hasStock ? 'stock' : 'percent';
            } catch (_) {
                globalTpMode = 'percent';
            }
            globalModeSelect.value = globalTpMode;

            // Initial TP rows (from saved plan or defaults)
            renderTpRows(initialTp);
            applyGlobalTpModeToRows();
            updateDefaultTpStockTargets();

            const slGroup = createSyntheticPercentField('sl_per', initialSl, 'Stop Loss', { showPercentSuffix: true });

            globalModeSelect.addEventListener('change', () => {
                const v = String(globalModeSelect.value || '').trim().toLowerCase();
                globalTpMode = (v === 'stock') ? 'stock' : 'percent';
                applyGlobalTpModeToRows();
                updateTpSlPrices();
                updateDefaultTpStockTargets();
                updatePreview();
            });

            // Action buttons row (goes at the end of the Trade Plan panel)
            const presetActionsBar = document.createElement('div');
            presetActionsBar.style.display = 'flex';
            presetActionsBar.style.justifyContent = 'flex-end';
            presetActionsBar.style.gap = '10px';
            presetActionsBar.style.marginTop = '6px';
            presetActionsBar.appendChild(savePresetBtn);
            presetActionsBar.appendChild(saveAsPresetBtn);
            presetActionsBar.appendChild(defaultPresetBtn);
            presetActionsBar.appendChild(deletePresetBtn);

            const LIVE_CUSTOM_VALUE = '__live_custom__';
            let selectedPresetId = initialPreset ? String(initialPreset.id) : ''; // DB id (only when a saved plan is selected)
            let selectedPresetName = initialPreset ? String(initialPreset.name || 'Default') : '';
            // What the dropdown currently shows as selected
            let selectedPresetValue = selectedPresetId || (tradePlanPresets.length ? '' : LIVE_CUSTOM_VALUE);

            function setLiveCustomMode({ reset = true } = {}) {
                selectedPresetId = '';
                selectedPresetName = '';
                selectedPresetValue = LIVE_CUSTOM_VALUE;
                // In Live Custom there is no saved preset selected, so disable actions that require an id.
                // (Save As remains available.)
                savePresetBtn.disabled = true;
                deletePresetBtn.disabled = true;
                defaultPresetBtn.disabled = true;

                if (reset) {
                    renderTpRows(defaultTp);
                    const slEl = findFieldByName('sl_per');
                    if (slEl) {
                        slEl.value = String(defaultSl);
                        slEl.dataset.autoFilled = '1';
                        delete slEl.dataset.userTouched;
                        slEl.dispatchEvent(new Event('input', { bubbles: true }));
                        slEl.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                    updateTpSlPrices();
                    updatePreview();
                }
            }

            function rebuildPresetSelect() {
                presetSelect.innerHTML = '';
                const none = document.createElement('option');
                none.value = '';
                none.textContent = '‚Äî Select a saved plan ‚Äî';
                presetSelect.appendChild(none);

                tradePlanPresets.forEach((p) => {
                    if (!p || p.id == null) return;
                    const opt = document.createElement('option');
                    opt.value = String(p.id);
                    opt.textContent = `${p.is_default ? '‚òÖ ' : ''}${String(p.name || 'Untitled')}`;
                    presetSelect.appendChild(opt);
                });

                // Put Live Custom at the end of the list
                const live = document.createElement('option');
                live.value = LIVE_CUSTOM_VALUE;
                live.textContent = 'Live Custom';
                presetSelect.appendChild(live);
                presetSelect.value = selectedPresetValue || '';
                deletePresetBtn.disabled = !selectedPresetId;
                defaultPresetBtn.disabled = !selectedPresetId;
            }

            function applyPresetById(id) {
                const pid = String(id || '');
                selectedPresetId = pid;
                selectedPresetValue = pid;
                const p = tradePlanPresets.find(x => x && String(x.id) === pid) || null;
                deletePresetBtn.disabled = !p;
                defaultPresetBtn.disabled = !p;
                if (!p) return;
                selectedPresetName = String(p.name || '');
                const plan = (p.plan && typeof p.plan === 'object') ? p.plan : {};
                const tp = Array.isArray(plan.tp_levels) && plan.tp_levels.length ? plan.tp_levels : defaultTp;
                const slNum = Number(String(plan.sl_per ?? '').trim());
                const slVal = Number.isFinite(slNum) && slNum > 0 ? slNum : defaultSl;
                renderTpRows(tp);
                const slEl = findFieldByName('sl_per');
                if (slEl) {
                    slEl.value = String(slVal);
                    slEl.dataset.autoFilled = '1';
                    delete slEl.dataset.userTouched;
                    slEl.dispatchEvent(new Event('input', { bubbles: true }));
                    slEl.dispatchEvent(new Event('change', { bubbles: true }));
                }
                updateTpSlPrices();
                updatePreview();
            }

            rebuildPresetSelect();
            // If there are no saved presets, default to Live Custom.
            if (!tradePlanPresets.length && !selectedPresetId) {
                setLiveCustomMode({ reset: false });
            }
            presetSelect.value = selectedPresetValue || '';

            presetSelect.addEventListener('change', () => {
                const v = String(presetSelect.value || '');
                if (!v) {
                    selectedPresetId = '';
                    selectedPresetName = '';
                    selectedPresetValue = '';
                    // No preset selected: allow Save (will create a new preset), disable id-only actions.
                    savePresetBtn.disabled = false;
                    deletePresetBtn.disabled = true;
                    defaultPresetBtn.disabled = true;
                    return;
                }
                if (v === LIVE_CUSTOM_VALUE) {
                    setLiveCustomMode({ reset: true });
                    return;
                }
                applyPresetById(v);
                // Saved preset selected: enable Save.
                savePresetBtn.disabled = false;
            });

            function currentPlanPayload() {
                return {
                    version: 1,
                    tp_levels: readTpState(),
                    sl_per: String(findFieldByName('sl_per')?.value ?? '').trim(),
                };
            }

            async function refreshPresetsFromServer() {
                // Avoid stale cached responses after create/delete/default changes
                const url = `/api/trade-plan/?_ts=${Date.now()}`;
                const res = await fetch(url, { credentials: 'same-origin', cache: 'no-store' });
                const data = await res.json().catch(() => ({}));
                if (res.ok && Array.isArray(data?.plans)) {
                    tradePlanPresets = data.plans;
                }
            }

            async function refreshPresetsAndUpdateDropdown() {
                await refreshPresetsFromServer();

                // If the selected preset was deleted, clear selection.
                if (selectedPresetValue === LIVE_CUSTOM_VALUE) {
                    // Stay in Live Custom mode.
                    selectedPresetId = '';
                    selectedPresetName = '';
                    savePresetBtn.disabled = true;
                } else {
                    const hasSelected = selectedPresetId && tradePlanPresets.some(p => p && String(p.id) === String(selectedPresetId));
                    if (!hasSelected) {
                        selectedPresetId = '';
                        selectedPresetName = '';
                        selectedPresetValue = tradePlanPresets.length ? '' : LIVE_CUSTOM_VALUE;
                        savePresetBtn.disabled = (selectedPresetValue === LIVE_CUSTOM_VALUE);
                    } else {
                        const p = tradePlanPresets.find(x => x && String(x.id) === String(selectedPresetId));
                        if (p) selectedPresetName = String(p.name || '');
                        selectedPresetValue = String(selectedPresetId);
                        savePresetBtn.disabled = false;
                    }
                }

                rebuildPresetSelect();
                presetSelect.value = selectedPresetValue || '';
                deletePresetBtn.disabled = !selectedPresetId;
                defaultPresetBtn.disabled = !selectedPresetId;
            }

            function ensureTradePlanNameModal() {
                let overlay = document.getElementById('ctpNameModalOverlay');
                if (overlay) return overlay;

                overlay = document.createElement('div');
                overlay.id = 'ctpNameModalOverlay';
                overlay.className = 'ctp-modal-overlay';
                overlay.innerHTML = `
                    <div class="ctp-modal" role="dialog" aria-modal="true" aria-labelledby="ctpNameModalTitle">
                        <div class="ctp-modal-title" id="ctpNameModalTitle">Name your Trade Plan</div>
                        <div class="ctp-modal-subtitle" id="ctpNameModalSubtitle">Enter a name to save this plan.</div>
                        <div class="form-group" style="margin: 0;">
                            <label for="ctpNameModalInput" style="margin-bottom: 8px;">Plan name</label>
                            <input id="ctpNameModalInput" class="form-input" type="text" placeholder="e.g., Swing Default" />
                            <div class="ctp-modal-error" id="ctpNameModalError">Name is required.</div>
                        </div>
                        <div class="ctp-modal-actions">
                            <button type="button" class="btn-cancel" id="ctpNameModalCancel">Cancel</button>
                            <button type="button" class="btn-submit" id="ctpNameModalSave">Save</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlay);
                return overlay;
            }

            function showTradePlanNameModal({ title = 'Name your Trade Plan', subtitle = 'Enter a name to save this plan.', initialValue = '' } = {}) {
                return new Promise((resolve) => {
                    const overlay = ensureTradePlanNameModal();
                    const titleEl = overlay.querySelector('#ctpNameModalTitle');
                    const subEl = overlay.querySelector('#ctpNameModalSubtitle');
                    const input = overlay.querySelector('#ctpNameModalInput');
                    const err = overlay.querySelector('#ctpNameModalError');
                    const btnCancel = overlay.querySelector('#ctpNameModalCancel');
                    const btnSave = overlay.querySelector('#ctpNameModalSave');

                    const close = (val) => {
                        overlay.classList.remove('open');
                        overlay.style.display = '';
                        cleanup();
                        resolve(val);
                    };

                    const showError = (msg) => {
                        if (!err) return;
                        err.textContent = msg || 'Name is required.';
                        err.classList.add('show');
                    };

                    const clearError = () => {
                        if (!err) return;
                        err.classList.remove('show');
                    };

                    const onOverlayClick = (e) => {
                        // click outside closes (cancel)
                        if (e.target === overlay) close('');
                    };

                    const onCancel = () => close('');

                    const onSave = () => {
                        const name = String(input?.value ?? '').trim();
                        if (!name) {
                            showError('Please enter a plan name.');
                            try { input?.focus(); } catch (_) {}
                            return;
                        }
                        close(name);
                    };

                    const onKeyDown = (e) => {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            close('');
                        } else if (e.key === 'Enter') {
                            // Enter submits when focus is in the input
                            if (document.activeElement === input) {
                                e.preventDefault();
                                onSave();
                            }
                        }
                    };

                    const cleanup = () => {
                        overlay.removeEventListener('click', onOverlayClick);
                        btnCancel?.removeEventListener('click', onCancel);
                        btnSave?.removeEventListener('click', onSave);
                        document.removeEventListener('keydown', onKeyDown);
                    };

                    if (titleEl) titleEl.textContent = title;
                    if (subEl) subEl.textContent = subtitle;
                    if (input) input.value = String(initialValue ?? '');
                    clearError();

                    overlay.classList.add('open');
                    overlay.addEventListener('click', onOverlayClick);
                    btnCancel?.addEventListener('click', onCancel);
                    btnSave?.addEventListener('click', onSave);
                    document.addEventListener('keydown', onKeyDown);

                    // Focus
                    setTimeout(() => {
                        try { input?.focus(); input?.select?.(); } catch (_) {}
                    }, 0);
                });
            }

            savePresetBtn.addEventListener('click', async () => {
                try {
                    savePresetBtn.disabled = true;
                    const prev = savePresetBtn.textContent;
                    savePresetBtn.textContent = 'Saving...';
                    let name = String(selectedPresetName || '').trim();
                    // If we're creating new (no selected preset), prompt user to set the plan name.
                    if (!selectedPresetId) {
                        const picked = await showTradePlanNameModal({
                            title: 'Name your Trade Plan',
                            subtitle: 'Enter a name to save this plan.',
                            initialValue: name || 'Default',
                        });
                        if (!picked) {
                            savePresetBtn.textContent = prev;
                            return;
                        }
                        name = picked;
                        selectedPresetName = name;
                    }
                    const plan = currentPlanPayload();
                    let resp;
                    if (selectedPresetId) {
                        // Keep existing name when updating (no name input in UI).
                        resp = await tradePlanApi({ action: 'update', id: selectedPresetId, name, plan });
                    } else {
                        resp = await tradePlanApi({ action: 'create', name, plan, set_default: false });
                        selectedPresetId = String(resp?.preset?.id || '');
                        selectedPresetName = String(resp?.preset?.name || name);
                        selectedPresetValue = selectedPresetId || LIVE_CUSTOM_VALUE;
                    }
                    await refreshPresetsAndUpdateDropdown();
                    savePresetBtn.textContent = 'Saved';
                    setTimeout(() => { savePresetBtn.textContent = prev; }, 800);
                } catch (e) {
                    console.warn('Save preset failed:', e);
                    savePresetBtn.textContent = 'Save failed';
                    setTimeout(() => { savePresetBtn.textContent = 'Save'; }, 1200);
                } finally {
                    savePresetBtn.disabled = false;
                }
            });

            saveAsPresetBtn.addEventListener('click', async () => {
                try {
                    saveAsPresetBtn.disabled = true;
                    const prev = saveAsPresetBtn.textContent;
                    saveAsPresetBtn.textContent = 'Saving...';
                    // Save As always asks for a name (easy to create many presets quickly).
                    const picked = await showTradePlanNameModal({
                        title: 'Save Trade Plan As',
                        subtitle: 'Choose a name for the new saved plan.',
                        initialValue: '',
                    });
                    if (!picked) {
                        saveAsPresetBtn.textContent = prev;
                        return;
                    }
                    const name = picked;
                    const plan = currentPlanPayload();
                    const resp = await tradePlanApi({ action: 'create', name, plan, set_default: false });
                    const newId = resp?.preset?.id;
                    if (newId != null) {
                        try { sessionStorage.setItem('ctp_selected_preset_id', String(newId)); } catch (_) {}
                    }
                    // Full rerender so Saved Plans list reflects new preset everywhere.
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Save As preset failed:', e);
                    saveAsPresetBtn.textContent = 'Save failed';
                    setTimeout(() => { saveAsPresetBtn.textContent = 'Save As'; }, 1200);
                } finally {
                    saveAsPresetBtn.disabled = false;
                }
            });

            defaultPresetBtn.addEventListener('click', async () => {
                if (!selectedPresetId) return;
                try {
                    defaultPresetBtn.disabled = true;
                    const prev = defaultPresetBtn.textContent;
                    defaultPresetBtn.textContent = 'Setting...';
                    await tradePlanApi({ action: 'set_default', id: selectedPresetId });
                    // Full rerender so ‚òÖ default marker updates everywhere.
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Set default preset failed:', e);
                    defaultPresetBtn.textContent = 'Failed';
                    setTimeout(() => { defaultPresetBtn.textContent = 'Set as Default'; }, 1200);
                } finally {
                    defaultPresetBtn.disabled = !selectedPresetId;
                }
            });

            deletePresetBtn.addEventListener('click', async () => {
                if (!selectedPresetId) return;
                try {
                    const idToDelete = String(selectedPresetId);
                    deletePresetBtn.disabled = true;
                    await tradePlanApi({ action: 'delete', id: selectedPresetId });
                    // Full rerender to reflect the latest server state everywhere.
                    // (Ensures Saved Plans dropdown + default markers stay consistent.)
                    window.location.reload();
                    return;
                } catch (e) {
                    console.warn('Delete preset failed:', e);
                } finally {
                    deletePresetBtn.disabled = !selectedPresetId;
                    defaultPresetBtn.disabled = !selectedPresetId;
                }
            });

            const tradePlanChildren = [
                tpContainer,
                slGroup,
                presetActionsBar,
                createSyntheticHiddenField('sl_price', '0.000'),
            ];
            formGroup._afterSyntheticGroups.push(createSyntheticTradePlanGroup(tradePlanChildren));
            // Ensure option_price is present in submitted JSON even if not defined in variables.
            if (!hasOptionPriceVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('option_price', '0.000'));
            if (!hasOptionContractVariable) formGroup._afterSyntheticGroups.push(createSyntheticHiddenField('option_contract', ''));

        } else {
            if (inputType === 'textarea') {
                input = document.createElement('textarea');
                input.className = 'form-textarea';
                input.rows = 3;
                // input.placeholder = 'Additional information (optional)';
            } else if (inputType === 'checkbox') {
                // Handle boolean/checkbox (special-case is_shares later for switch UI)
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-checkbox';
                input.checked = variable.default || false;
            } else {
                input = document.createElement('input');
                input.className = 'form-input';
                input.type = inputType;
                
                // For float inputs, add step attribute to allow decimals
                if (variable.type === 'float') {
                    input.step = '0.01';
                }
                
                // Add placeholders
                const placeholders = {
                    'ticker': 'Enter ticker (e.g., AAPL, TSLA)',
                    'strike': 'Enter strike price (e.g., 150.50)',
                    'expiration': 'Enter expiration date (e.g., 2025-11-20)',
                    'price': 'Enter price (e.g., 1.25)',
                    'entry_price': 'Enter entry price (e.g., 1.25)',
                    'exit_price': 'Enter exit price (e.g., 1.50)',
                    'pnl_percent': 'Enter P&L % (e.g., 20.5)'
                };
                input.placeholder = placeholders[variable.name] || '';
            }
        }
        
        input.id = `id_${variable.name}`;
        input.name = variable.name;

        // Allow auto-filling option_price even if it starts at the default "0.0"
        if (variable.name === 'option_price') {
            const v = String(input.value || '').trim();
            if (v === '' || v === '0.0') {
                input.dataset.autoFilled = '1';
            }
        }

        // Expiration: default to today and disallow past dates
        if (variable.name === 'expiration' && input && input.type === 'date') {
            const today = getTodayISODate();
            input.min = today;
            if (!input.value) input.value = today;
        }
        
        // Add HTML5 required attribute if field is required
        if (isRequired) {
            input.required = true;
            // Store that it was originally required for restoration
            input.setAttribute('data-originally-required', 'true');
        }
        
        // Add hint as placeholder if provided (overrides default placeholders)
        if (variable.hint && input.type !== 'checkbox') {
            input.placeholder = variable.hint;
        }
        
        // Add data attribute for conditional visibility based on is_shares
        if (variable.name === 'strike' || variable.name === 'expiration' || variable.name === 'option_type') {
            formGroup.setAttribute('data-requires-options', 'true');
        }

        // Strike/Expiration are auto-selected (best-option) and should not be user-editable.
        if (variable.name === 'strike' || variable.name === 'expiration') {
            formGroup.style.display = 'none';
            // Avoid HTML5 required blocking submission; we still enforce via server-side + data JSON.
            if (input) input.required = false;
            if (input) input.dataset.autoFilled = '1';
        }
        
        // Special: render is_shares as a modern toggle switch pill (like screenshot)
        if ((variable.type === 'boolean' || inputType === 'checkbox') && variable.name === 'is_shares') {
            const pill = document.createElement('div');
            pill.className = 'toggle-pill';

            const switchWrap = document.createElement('label');
            switchWrap.className = 'toggle-switch';

            // ensure id/name match existing logic
            input.id = `id_${variable.name}`;
            input.name = variable.name;

            const slider = document.createElement('span');
            slider.className = 'toggle-slider';

            switchWrap.appendChild(input);
            switchWrap.appendChild(slider);

            const text = document.createElement('div');
            text.className = 'toggle-label';
            text.textContent = (variable.label || 'Is_Shares') + ' (Disable Options fields)';

            pill.appendChild(switchWrap);
            pill.appendChild(text);

            isSharesPill = pill;
            isSharesFormGroup = formGroup;

            // If ticker_type exists, embed this toggle inline next to it; otherwise fall back to normal placement.
            if (tickerTypeToggleSlot) {
                attachIsSharesToTickerType();
            } else {
                // Don't use the normal label for this one
                formGroup.appendChild(pill);
            }
        } else if (variable.type === 'boolean' || inputType === 'checkbox') {
            // Regular checkbox booleans
            formGroup.classList.add('checkbox-group');
            formGroup.appendChild(input);
            formGroup.appendChild(label);
        } else {
            formGroup.appendChild(label);
            // For ticker search inputs we created an extra wrapper; append it instead of the raw input.
            if (input && input._tickerSearchWrap) {
                // If this is ticker_type, render a row that can host the is_shares toggle inline.
                if (variable.type === 'ticker_type') {
                    const row = document.createElement('div');
                    row.className = 'ticker-type-row';
                    row.appendChild(input._tickerSearchWrap);
                    const slot = document.createElement('div');
                    slot.className = 'ticker-type-toggle-slot';
                    row.appendChild(slot);
                    formGroup.appendChild(row);
                    tickerTypeToggleSlot = slot;
                    attachIsSharesToTickerType();
                } else {
                    formGroup.appendChild(input._tickerSearchWrap);
                }
            } else {
                formGroup.appendChild(input);
            }
        }
        
        // Place in appropriate container based on whether it's optional-only and visible
        // is_shares should always stay in main container, never in optional container
        const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');
        if (isUsed && isOptionalOnly && optionalFieldsVariablesContainer && !isSpecialControl) {
            optionalFieldsVariablesContainer.appendChild(formGroup);
        } else {
            dynamicFieldsContainer.appendChild(formGroup);
        }

        // Insert any synthetic option fields (strike/expiration/option_type) right after ticker_type.
        if (variable.type === 'ticker_type' && Array.isArray(formGroup._afterSyntheticGroups) && formGroup._afterSyntheticGroups.length > 0) {
            formGroup._afterSyntheticGroups.forEach((g) => {
                dynamicFieldsContainer.appendChild(g);
            });
        }
        
        // Add event listeners for real-time preview
        input.addEventListener('input', updatePreview);
        input.addEventListener('change', updatePreview);

        // Track manual edits to avoid overwriting auto-filled values.
        input.addEventListener('input', () => markUserTouched(input));

        // Auto-fetch current price when selecting a ticker_type field.
        if (variable.type === 'ticker_type') {
            input.addEventListener('change', async () => {
                const sym = String(input.value || '').trim().toUpperCase();
                if (!sym) return;
                const quote = await fetchQuote(sym);
                if (!quote) return;

                // Cache for live preview usage (company_name/stock_price modifiers).
                tickerMetaCache[sym] = {
                    price: quote.price,
                    company_name: quote.company_name || '',
                };

                // Fill best available "price" field (current_price > entry_price > price)
                const currentPriceEl = findFieldByName('current_price');
                const entryPriceEl = findFieldByName('entry_price');
                const priceEl = findFieldByName('price');
                const companyNameEl = findFieldByName('company_name');
                const isSharesCheckbox = document.getElementById('id_is_shares');
                const isShares = isSharesCheckbox && isSharesCheckbox.checked;

                setValueIfAllowed(currentPriceEl, formatFloat3(quote.price));
                setValueIfAllowed(entryPriceEl, formatFloat3(quote.price));
                setValueIfAllowed(priceEl, formatFloat3(quote.price));
                setValueIfAllowed(companyNameEl, quote.company_name);

                // Even if there is no explicit price/company_name input in the template,
                // we still want the live preview to re-render using tickerMetaCache.
                updateDefaultTpStockTargets();
                updatePreview();

                // If option side/trade type are selected, auto-pick the best option now.
                if (!isShares) {
                    await maybeAutoPickBestOption();
                }
            });
        }

        // Auto-select best option when user selects PUT/CALL (option_type)
        if (variable.name === 'option_type') {
            input.addEventListener('change', async () => {
                updateDefaultTpStockTargets();
                await maybeAutoPickBestOption();
            });
        }
    });
    
    // Set up is_shares checkbox handler
    const isSharesCheckbox = document.getElementById('id_is_shares');
    if (isSharesCheckbox) {
        isSharesCheckbox.addEventListener('change', function() {
            toggleOptionFields(this.checked);
            updateVariableVisibility(); // Update variable visibility when is_shares changes
            // If switching back to options mode, reset option-related inputs to defaults.
            if (!this.checked) {
                const sym = getCurrentTickerSymbol();
                const cached = sym ? tickerMetaCache[sym] : null;
                const optTypeEl = findFieldByName('option_type');
                const optionPriceEl = findFieldByName('option_price');

                const forceSet = (el, value) => {
                    if (!el) return;
                    el.value = String(value ?? '');
                    el.dataset.autoFilled = '1';
                    // Fire events so preview + option quote logic update.
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                };

                // Default option_type=CALL (user can change to PUT which will recompute best-option)
                forceSet(optTypeEl, 'CALL');

                // Default TP/SL percent values
                forceSet(findFieldByName('tp1_per'), '10');
                forceSet(findFieldByName('tp2_per'), '20');
                forceSet(findFieldByName('tp3_per'), '30');
                // Default takeoff amounts (percent of capital removed at each TP)
                forceSet(findFieldByName('tp1_takeoff_per'), '50');
                forceSet(findFieldByName('tp2_takeoff_per'), '25');
                forceSet(findFieldByName('tp3_takeoff_per'), '25');
                forceSet(findFieldByName('sl_per'), '10');

                // Default option_price to 0.000; it will be overwritten by /api/best-option/ once inputs are valid.
                forceSet(optionPriceEl, '0.000');
            }
            updatePreview();
            if (!this.checked) {
                // Recompute best option for current ticker/trade_type/side
                maybeAutoPickBestOption();
            }
        });
        // Initialize on page load
        toggleOptionFields(isSharesCheckbox.checked);
    }
    
    // Create optional fields checkboxes
    createOptionalFieldsCheckboxes(signalTypeId);
    
    // Set checkbox defaults based on signal type
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    if (showTitleCheckbox && signalType.show_title_default !== undefined) {
        showTitleCheckbox.checked = signalType.show_title_default;
        
    }
    
    if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
        showDescriptionCheckbox.checked = signalType.show_description_default;
        
    }
    
    // Update variable visibility after fields are created
    updateVariableVisibility();

    // Auto-resize any textareas in the Send Signal panel (no scrollbars)
    wireAutoResizeTextareas(document.getElementById('dynamicFields'));
    wireAutoResizeTextareas(document.getElementById('optionalFieldsVariablesContainer'));

    // Upgrade any <select> controls inside dynamic fields to match ticker dropdown styling
    document.querySelectorAll('#dynamicFields select, #optionalFieldsVariablesContainer select').forEach((sel) => {
        upgradeSelectToTickerDropdown(sel);
    });
    
    // Update preview after fields are created
    updatePreview();
}

// Toggle visibility of option-related fields based on is_shares checkbox
function toggleOptionFields(isShares) {
    const optionFields = document.querySelectorAll('[data-requires-options="true"]');
    optionFields.forEach(field => {
        if (isShares) {
            field.style.display = 'none';
            const input = field.querySelector('input, select');
            if (input) {
                input.removeAttribute('required');
                input.value = '';
            }
        } else {
            field.style.display = 'block';
            const input = field.querySelector('input, select');
            if (input && input.hasAttribute('data-originally-required')) {
                input.setAttribute('required', true);
            }
        }
    });

    // Also toggle the Trade Plan group wrapper (otherwise it can show as an empty card)
    document.querySelectorAll('.trade-plan-group').forEach((g) => {
        g.style.display = isShares ? 'none' : 'block';
    });
}

// Update variable visibility based on which variables are currently used
function updateVariableVisibility() {
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    if (!signalTypeSelect || !signalTypeSelect.value) {
        return;
    }
    
    const signalTypeId = signalTypeSelect.value;
    const { all: usedVariables, optionalOnly: optionalOnlyVariables } = getUsedVariables(signalTypeId);
    
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    const optionalFieldsVariablesContainer = document.getElementById('optionalFieldsVariablesContainer');

    const isSharesCheckbox = document.getElementById('id_is_shares');
    const isShares = isSharesCheckbox && isSharesCheckbox.checked;
    // If we have a ticker_type control, show option fields by default (unless is_shares is enabled).
    const hasTickerTypeControl = !!document.querySelector('#dynamicFields .ticker-type-row, #optionalFieldsVariablesContainer .ticker-type-row');
    const optionFieldNames = new Set([
        'strike', 'expiration', 'option_type',
        'tp1_per', 'tp2_per', 'tp3_per', 'tp4_per', 'tp5_per', 'tp6_per',
        'tp1_takeoff_per', 'tp2_takeoff_per', 'tp3_takeoff_per', 'tp4_takeoff_per', 'tp5_takeoff_per', 'tp6_takeoff_per',
        'sl_per',
    ]);
    const forceShowOptionFields = hasTickerTypeControl && !isShares;
    
    // Update visibility of all variable inputs
    const variableInputs = document.querySelectorAll('#dynamicFields [data-variable-name], #optionalFieldsVariablesContainer [data-variable-name]');
    variableInputs.forEach(formGroup => {
        const variableName = formGroup.getAttribute('data-variable-name');
        // is_shares is a special control variable that should always be visible
        const isSpecialControl = variableName === 'is_shares';
        const isUsed = usedVariables.has(variableName) || isSpecialControl || (forceShowOptionFields && optionFieldNames.has(variableName));
        const isOptionalOnly = optionalOnlyVariables.has(variableName);
        const currentParent = formGroup.parentElement;
        const isInOptionalContainer = currentParent === optionalFieldsVariablesContainer;
        
        if (isUsed) {
            // Keep synthetic hidden fields hidden (but still included in data).
            if (formGroup.classList.contains('synthetic-hidden')) {
                formGroup.style.display = 'none';
            } else {
                // Preserve checkbox-group alignment (inline style wins over CSS)
                formGroup.style.display = formGroup.classList.contains('checkbox-group') ? 'flex' : 'block';
            }
            
            // is_shares should always stay in main container, never move to optional container
            if (isSpecialControl && isInOptionalContainer) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            } else if (isOptionalOnly && !isInOptionalContainer && !isSpecialControl) {
                // Move to optional fields container (but not is_shares)
                formGroup.remove();
                optionalFieldsVariablesContainer.appendChild(formGroup);
            } else if (!isOptionalOnly && isInOptionalContainer && !isSpecialControl) {
                // Move back to main container
                formGroup.remove();
                dynamicFieldsContainer.appendChild(formGroup);
            }
        } else {
            formGroup.style.display = 'none';
            // Clear the value when hiding (except for required fields and is_shares)
            if (!isSpecialControl) {
                const input = formGroup.querySelector('input, textarea, select');
                if (input && !input.hasAttribute('required')) {
                    if (input.type === 'checkbox') {
                        input.checked = false;
                    } else {
                        input.value = '';
                    }
                }
            }
        }
    });
    
    // Show/hide optional fields variables container based on visible variable inputs
    if (optionalFieldsVariablesContainer) {
        // Count visible variable inputs (form groups with data-variable-name that are not hidden)
        const visibleVariables = Array.from(optionalFieldsVariablesContainer.children).filter(child => {
            // Check if it's a form group with data-variable-name that's visible
            const hasVariableName = child.getAttribute && child.getAttribute('data-variable-name');
            const isVisible = child.style && child.style.display !== 'none';
            return hasVariableName && isVisible;
        });
        
        // Only show the container if there are visible variable inputs
        if (visibleVariables.length > 0) {
            optionalFieldsVariablesContainer.style.display = 'block';
        } else {
            optionalFieldsVariablesContainer.style.display = 'none';
        }
    }
}

// Create checkboxes for optional fields
function createOptionalFieldsCheckboxes(signalTypeId) {
    const optionalFieldsSection = document.getElementById('optionalFieldsSection');
    const optionalFieldsContainer = document.getElementById('optionalFieldsCheckboxesContainer');
    
    if (!optionalFieldsSection || !optionalFieldsContainer) {
        return;
    }
    
    // Clear existing checkboxes
    optionalFieldsContainer.innerHTML = '';
    
    // Get signal type data
    const signalTypeIdStr = String(signalTypeId);
    const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
    if (!signalType) {
        optionalFieldsSection.style.display = 'none';
        return;
    }
    
    // Parse fields_template
    let fields = signalType.fields_template;
    if (typeof fields === 'string') {
        try {
            fields = JSON.parse(fields);
        } catch (e) {
            console.error('Error parsing fields_template:', e);
            fields = [];
        }
    }
    fields = fields || [];
    
    // Find optional fields
    const optionalFields = [];
    fields.forEach((field, index) => {
        if (isOptionalFieldForSignalType(field, signalType)) {
            // Extract a readable name from the field
            let fieldName = field.name || field.value || `Field ${index + 1}`;
            // Remove markdown, emojis, and variable placeholders, then clean up
            fieldName = fieldName.replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').replace(/\{\{.*?\}\}/g, '').trim();
            if (!fieldName) {
                fieldName = field.value ? field.value.replace(/\{\{.*?\}\}/g, '').replace(/\*\*/g, '').replace(/[üìùüíµ‚ö†Ô∏èüéØüõëüí∞‚úçÔ∏èüî¥]/g, '').trim() : `Field ${index + 1}`;
            }
            if (!fieldName || fieldName === '\u200b') {
                fieldName = `Optional Field ${index + 1}`;
            }
            optionalFields.push({
                index: index,
                name: fieldName,
                field: field
            });
        }
    });
    
    // Show/hide section based on whether there are optional fields
    if (optionalFields.length === 0) {
        optionalFieldsSection.style.display = 'none';
        return;
    }
    
    optionalFieldsSection.style.display = 'block';
    
    // Create checkboxes for each optional field
    optionalFields.forEach(({index, name, field}) => {
        const fieldKey = `field_${signalTypeId}_${index}`;
        
        // Create row container
        const row = document.createElement('div');
        row.className = 'switch-item';

        // Create checkbox (kept as checkbox for logic, styled as switch)
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `optional_field_${fieldKey}`;
        checkbox.checked = optionalFieldsVisibility[fieldKey] || false;

        const switchWrap = document.createElement('label');
        switchWrap.className = 'mini-switch';

        const slider = document.createElement('span');
        slider.className = 'mini-slider';

        switchWrap.appendChild(checkbox);
        switchWrap.appendChild(slider);

        // Create text label
        const label = document.createElement('label');
        label.className = 'switch-text';
        label.htmlFor = checkbox.id;
        label.textContent = name;
        
        // Add change event listener
        checkbox.addEventListener('change', function() {
            optionalFieldsVisibility[fieldKey] = this.checked;
            updateVariableVisibility(); // Update variable visibility when optional fields change
            updatePreview();
        });
        
        row.appendChild(switchWrap);
        row.appendChild(label);
        optionalFieldsContainer.appendChild(row);
    });
}



// Handle title visibility toggle
function toggleTitleVisibility() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowTitle', showTitleCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Handle description visibility toggle
function toggleDescriptionVisibility() {
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        // Save preference to localStorage
        localStorage.setItem('discordShowDescription', showDescriptionCheckbox.checked ? 'true' : 'false');
        // Update variable visibility
        updateVariableVisibility();
        // Update preview
        updatePreview();
    }
}

// Load visibility preferences from localStorage or signal type defaults
function loadVisibilityPreferences() {
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    
    // Check if a signal type is already selected
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    let useSignalTypeDefaults = false;
    
    if (signalTypeSelect && signalTypeSelect.value) {
        const signalTypeId = signalTypeSelect.value;
        const signalTypeIdStr = String(signalTypeId);
        const signalType = signalTypesData[signalTypeIdStr] || signalTypesData[signalTypeId];
        
        if (signalType && (signalType.show_title_default !== undefined || signalType.show_description_default !== undefined)) {
            useSignalTypeDefaults = true;
            
            if (showTitleCheckbox && signalType.show_title_default !== undefined) {
                showTitleCheckbox.checked = signalType.show_title_default;
                localStorage.setItem('discordShowTitle', signalType.show_title_default ? 'true' : 'false');
            }
            
            if (showDescriptionCheckbox && signalType.show_description_default !== undefined) {
                showDescriptionCheckbox.checked = signalType.show_description_default;
                localStorage.setItem('discordShowDescription', signalType.show_description_default ? 'true' : 'false');
            }
        }
    }
    
}

// Handle signal type change
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded - Initializing dashboard...');
    
    // Initialize visibility preferences
    loadVisibilityPreferences();
    
    // Add event listeners to checkboxes
    const showTitleCheckbox = document.getElementById('showTitleCheckbox');
    if (showTitleCheckbox) {
        showTitleCheckbox.addEventListener('change', toggleTitleVisibility);
    }
    
    const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
    if (showDescriptionCheckbox) {
        showDescriptionCheckbox.addEventListener('change', toggleDescriptionVisibility);
    }
    
    const signalTypeSelect = document.querySelector('select[name="signal_type"]');
    const form = document.getElementById('signalForm');

    // Upgrade top-level selects to match ticker dropdown styling
    if (signalTypeSelect) upgradeSelectToTickerDropdown(signalTypeSelect, { placeholder: 'Select signal type' });
    const discordChannelSelect = document.getElementById('discord_channel');
    if (discordChannelSelect) upgradeSelectToTickerDropdown(discordChannelSelect, { placeholder: 'Select channel' });
    const tradeTypeSelect = document.getElementById('trade_type');
    if (tradeTypeSelect) upgradeSelectToTickerDropdown(tradeTypeSelect, { placeholder: 'Select trade type' });
    
    console.log('signalTypeSelect found:', !!signalTypeSelect);
    console.log('signalTypesData keys:', Object.keys(signalTypesData));
    
    if (signalTypeSelect) {
        // Initial load - always create fields for the first/default value
        const defaultValue = signalTypeSelect.value || signalTypeSelect.options[signalTypeSelect.selectedIndex]?.value || Object.keys(signalTypesData)[0];
        console.log('Default value determined:', defaultValue);
        
        if (defaultValue) {
            signalTypeSelect.value = defaultValue;
            console.log('Creating dynamic fields for default value:', defaultValue);
            createDynamicFields(defaultValue);
        } else {
            console.warn('No default value found. signalTypeSelect.value:', signalTypeSelect.value, 'Options:', signalTypeSelect.options.length);
        }
        
        // Handle change
        signalTypeSelect.addEventListener('change', function() {
            console.log('Signal type changed to:', this.value);
            if (this.value) {
                createDynamicFields(this.value);
                // Update preview immediately - createDynamicFields already calls it, but ensure it happens
                updatePreview();
            }
        });
        
        // Handle form submission
        form.addEventListener('submit', async function(e) {
            // If we already ran the auto-fill flow, proceed with normal submit.
            if (form.dataset.skipAutoFillOnce === '1') {
                delete form.dataset.skipAutoFillOnce;
            } else {
                // Safety: if option_price is still default (0.000) in options mode, wait for best-option autofill.
                const isSharesCheckbox0 = document.getElementById('id_is_shares');
                const isShares0 = isSharesCheckbox0 && isSharesCheckbox0.checked;
                if (!isShares0) {
                    const sym0 = getCurrentTickerSymbol();
                    const optPriceEl0 = findFieldByName('option_price');
                    const optPrice0 = optPriceEl0 ? String(optPriceEl0.value || '').trim() : '';
                    const needsOptionPrice =
                        !!sym0 &&
                        (!optPrice0 || optPrice0 === '0' || optPrice0 === '0.0' || optPrice0 === '0.00' || optPrice0 === '0.000');

                    if (needsOptionPrice) {
                        e.preventDefault();
                        try {
                            await maybeAutoPickBestOption();
                            updateTpSlPrices();
                        } catch (_) {
                            // fall through: submit with whatever we have
                        }
                        form.dataset.skipAutoFillOnce = '1';
                        // Trigger submit again with updated values
                        if (typeof form.requestSubmit === 'function') {
                            form.requestSubmit();
                        } else {
                            form.submit();
                        }
                        return false;
                    }
                }
            }

            // Get current signal type and its variables
            const currentSignalTypeId = signalTypeSelect.value;
            const currentSignalType = signalTypesData[currentSignalTypeId];
            const currentVariables = currentSignalType ? (currentSignalType.variables || []) : [];
            
            // Validate required fields - include inputs from both containers
            const dynamicInputs = document.querySelectorAll('#dynamicFields input, #dynamicFields textarea, #dynamicFields select, #optionalFieldsVariablesContainer input, #optionalFieldsVariablesContainer textarea, #optionalFieldsVariablesContainer select');
            const errors = [];
            
            // Check if is_shares is checked
            const isSharesCheckbox = document.getElementById('id_is_shares');
            const isShares = isSharesCheckbox && isSharesCheckbox.checked;
            
            dynamicInputs.forEach(input => {
                // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
                if (!input.name || input.dataset.ignoreDynamic === '1') {
                    return;
                }
                // Skip validation if field is hidden due to is_shares
                if (input.closest('[data-requires-options="true"]') && isShares) {
                    return;
                }
                
                // Find the variable definition for this input
                const variable = currentVariables.find(v => v.name === input.name);
                
                // Check if field is required
                if (variable && variable.required === true) {
                    let isEmpty = false;
                    
                    // Check if field is empty based on type
                    if (input.type === 'checkbox') {
                        isEmpty = !input.checked;
                    } else {
                        isEmpty = !input.value || input.value.trim() === '';
                    }
                    
                    if (isEmpty) {
                        errors.push(variable.label || variable.name);
                        // Add error styling to the field
                        input.style.borderColor = '#dc3545';
                        const formGroup = input.closest('.form-group');
                        if (formGroup) {
                            formGroup.style.marginBottom = '10px';
                        }
                    } else {
                        // Remove error styling if field is valid
                        input.style.borderColor = '';
                    }
                } else {
                    // Remove error styling for non-required fields
                    input.style.borderColor = '';
                }
            });
            
            // Show errors if any and prevent submission
            if (errors.length > 0) {
                e.preventDefault();
                alert('Please fill in the following required fields:\n' + errors.map(e => '  ‚Ä¢ ' + e).join('\n'));
                return false;
            }
            
            // Collect all dynamic field values into a JSON object
            const signalData = {};
            dynamicInputs.forEach(input => {
                // Skip cosmetic controls (e.g. custom dropdown inputs) or unnamed elements
                if (!input.name || input.dataset.ignoreDynamic === '1') {
                    return;
                }
                // Handle checkbox
                if (input.type === 'checkbox') {
                    signalData[input.name] = input.checked ? 'true' : 'false';
                } else {
                    signalData[input.name] = input.value;
                }
            });

            // Include non-dynamic publish controls
            const tradeTypeEl = document.getElementById('trade_type');
            if (tradeTypeEl && tradeTypeEl.value) {
                signalData['trade_type'] = tradeTypeEl.value;
            }
            
            // Collect optional field selections
            const optionalFieldsIndices = [];
            // currentSignalType already declared above
            if (currentSignalType) {
                let fields = currentSignalType.fields_template;
                if (typeof fields === 'string') {
                    try {
                        fields = JSON.parse(fields);
                    } catch (e) {
                        fields = [];
                    }
                }
                fields = fields || [];
                
                fields.forEach((field, index) => {
                    if (isOptionalFieldForSignalType(field, currentSignalType)) {
                        const fieldKey = `field_${currentSignalTypeId}_${index}`;
                        if (optionalFieldsVisibility[fieldKey] === true) {
                            optionalFieldsIndices.push(index);
                        }
                    }
                });
            }
            
            // Store optional field indices in signalData
            if (optionalFieldsIndices.length > 0) {
                signalData['_optional_fields'] = optionalFieldsIndices;
            }
            
            // Store title and description visibility preferences
            const showTitleCheckbox = document.getElementById('showTitleCheckbox');
            const showDescriptionCheckbox = document.getElementById('showDescriptionCheckbox');
            if (showTitleCheckbox) {
                signalData['_show_title'] = showTitleCheckbox.checked;
            }
            if (showDescriptionCheckbox) {
                signalData['_show_description'] = showDescriptionCheckbox.checked;
            }
            
            // Set the data field value
            const dataInput = form.querySelector('input[name="data"]');
            if (dataInput) {
                dataInput.value = JSON.stringify(signalData);
            } else {
                // If data field doesn't exist, add it to the form
                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = 'data';
                hiddenInput.value = JSON.stringify(signalData);
                form.appendChild(hiddenInput);
            }
            
            // Let form submit naturally if validation passes
        });
    }

    // Recompute best option when trade type changes (Scalp/Swing/Leap)
    const tradeTypeEl = document.getElementById('trade_type');
    if (tradeTypeEl) {
        tradeTypeEl.addEventListener('change', async () => {
            await maybeAutoPickBestOption();
            updatePreview();
        });
    }
});
</script>
{% endblock %}

